<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Vikrant Mehta">
<meta name="dcterms.date" content="2024-10-03">

<title>Graphs: BFS &amp; DFS – Vikrant</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../../site_libs/quarto-contrib/fontawesome6-0.1.0/all.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/fontawesome6-0.1.0/latex-fontsize.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-CKDPXJ4Y38"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-CKDPXJ4Y38', { 'anonymize_ip': true});
</script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Sofia&amp;family=WindSong:wght@400;500&amp;display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Vikrant</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../dsa/index.html" aria-current="page"> 
<span class="menu-text">DSA</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/vikrant-mehta/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/vikrantmehta123"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://leetcode.com/u/vikrantmehta123/"> <i class="bi bi-code" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://lichess.org/@/vikrant-123"> 
<span class="menu-text"><i class="fa-solid fa-chess-queen" aria-label="chess-queen"></i></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../dsa/index.html">Leet Coding Using Python</a></li><li class="breadcrumb-item"><a href="../../dsa/graphs/index.html">Graphs: BFS &amp; DFS</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../dsa/index.html">Leet Coding Using Python</a></li><li class="breadcrumb-item"><a href="../../dsa/graphs/index.html">Graphs: BFS &amp; DFS</a></li></ol></nav>
      <h1 class="title">Graphs: BFS &amp; DFS</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">DSA</div>
                <div class="quarto-category">BFS</div>
                <div class="quarto-category">DFS</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta column-body">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Vikrant Mehta </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">October 3, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../dsa/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Leet Coding Using Python</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../dsa/sorting-and-searching/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Sorting and Searching</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../dsa/linked-lists-stacks-and-queues/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Stacks, Queues, Linked Lists, and Arrays</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../dsa/graphs/index.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Graphs: BFS &amp; DFS</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../dsa/shortest-paths-and-mcst/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Shortest Paths and Minimum Cost Spanning Trees</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../dsa/heaps-and-trees/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Heaps and Trees</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../dsa/greedy/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Greedy</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../dsa/divide-and-conquer/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Divide and Conquer</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../dsa/dynamic-programming/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Dynamic Programming</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../dsa/string-matching/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">String Matching and Tries</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#find-the-town-judge" id="toc-find-the-town-judge" class="nav-link active" data-scroll-target="#find-the-town-judge">1. Find the Town Judge</a></li>
  <li><a href="#course-schedule-i" id="toc-course-schedule-i" class="nav-link" data-scroll-target="#course-schedule-i">2. Course Schedule-I</a></li>
  <li><a href="#course-schedule-ii" id="toc-course-schedule-ii" class="nav-link" data-scroll-target="#course-schedule-ii">3. Course Schedule-II</a></li>
  <li><a href="#snakes-and-ladders" id="toc-snakes-and-ladders" class="nav-link" data-scroll-target="#snakes-and-ladders">4. Snakes and Ladders</a></li>
  <li><a href="#sort-items-by-groups-respecting-dependencies" id="toc-sort-items-by-groups-respecting-dependencies" class="nav-link" data-scroll-target="#sort-items-by-groups-respecting-dependencies">5. Sort Items By Groups Respecting Dependencies</a></li>
  <li><a href="#find-if-path-exists" id="toc-find-if-path-exists" class="nav-link" data-scroll-target="#find-if-path-exists">6. Find If Path Exists</a></li>
  <li><a href="#number-of-provinces" id="toc-number-of-provinces" class="nav-link" data-scroll-target="#number-of-provinces">7. Number of Provinces</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block column-body" id="quarto-document-content">





<section id="find-the-town-judge" class="level3">
<h3 class="anchored" data-anchor-id="find-the-town-judge">1. <a href="https://leetcode.com/problems/find-the-town-judge/description/">Find the Town Judge</a></h3>
<p><strong>🎯 Understanding the Test Cases:</strong></p>
<p><em>Test Case 1:</em></p>
<p><code>n = 3, trust = [[1, 3], [2, 3]]</code></p>
<p><em>Explanation:</em></p>
<p>There are 3 people in the town. Person 1 trusts Person 3, and Person 2 also trusts Person 3. Person 3 doesn’t trust anyone, and both other people trust Person 3. This means Person 3 meets the conditions of being the town judge: trusted by everyone but trusts nobody. Hence, he is the town judge.</p>
<p><em>Test Case 2:</em></p>
<p><code>n = 3, trust = [[1, 3], [2, 3], [3, 1]]</code></p>
<p><em>Explanation:</em></p>
<p>There are 3 people in the town. Person 1 trusts Person 3, and Person 2 also trusts Person 3. Person 3 trusts Person 1, which means Person 3 is not trusted by everyone (because Person 1 and Person 2 trust Person 3, but Person 3 also trusts Person 1). The town judge must trust nobody and be trusted by everyone else. Since Person 3 doesn’t meet this condition (because they trust Person 1), there is no town judge. So we return -1.</p>
<section id="by-counting-indegrees" class="level4">
<h4 class="anchored" data-anchor-id="by-counting-indegrees">1.1 By Counting Indegrees</h4>
<p>We have an array <code>trusts</code>, where each entry <span class="math inline">\(trusts[i] = [a_i, b_i]\)</span> tells us that <span class="math inline">\(a_i\)</span> trusts <span class="math inline">\(b_i\)</span>.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Question:
</div>
</div>
<div class="callout-body-container callout-body">
<p>If <span class="math inline">\(a_i\)</span> trusts <span class="math inline">\(b_i\)</span>, how could we represent this in a graph?</p>
</div>
</div>
<p>If <span class="math inline">\(a_i\)</span> trusts <span class="math inline">\(b_i\)</span> then we can consider it an edge from <span class="math inline">\(a_i\)</span> to <span class="math inline">\(b_i\)</span>.</p>
<p><strong>Finding the Town Judge:</strong></p>
<p>The town judge is a person who:</p>
<ol type="1">
<li><em>Trusts no one</em> <span class="math inline">\(\implies\)</span> <em>Outdegree = 0</em></li>
<li><em>Is trusted by everyone except himself</em> <span class="math inline">\(\implies\)</span> <em>Indegree = n - 1</em></li>
</ol>
<p>To solve this, we can use dictionaries:</p>
<ol type="1">
<li><em>Indegree Dictionary</em> : Tracks how many people trust each person.</li>
<li><em>Outdegree Dictionary</em> : Tracks how many people each person trusts.</li>
</ol>
<ul>
<li>How can we use these dictionaries to find the town judge?<br>
We can check if someone has an outdegree of 0 and an indegree of <code>n-1</code>. Since the town judge is unique, whenever we find such person, we can return it.</li>
</ul>
<p>Time complexity: <span class="math inline">\(O(|E| + n)\)</span>, where <span class="math inline">\(|E|\)</span> is the number of edges in the graph, and <span class="math inline">\(n\)</span> is the number of nodes.</p>
<details>
<summary>
<strong>Need help with implementation?</strong>
</summary>
<pre><code class="language-python">
class Solution:
    def findJudge(self, n: int, trust: List[List[int]]) -&gt; int:        
        if n &lt;= 1:
            return 1

        indegrees = { }
        outdegrees = { }

        # trust = [a_i, b_i]
        # a_i -&gt; b_i
        for a, b in trust:
            if a not in indegrees: indegrees[a] = 0
            if b not in indegrees: indegrees[b] = 0
            if a not in outdegrees: outdegrees[a] = 0
            if b not in outdegrees: outdegrees[b] = 0

            outdegrees[a] += 1
            indegrees[b] += 1
        
        # If indegree == n - 1 and outdegree == 0, then we have found the town judge.
        townjudge = -1
        for person in indegrees:
            if outdegrees[person] == 0:
                if indegrees[person] &gt;= n - 1:
                    townjudge = person 
                    break
        return townjudge        
</code>
</pre>
</details>
</section>
</section>
<section id="course-schedule-i" class="level3">
<h3 class="anchored" data-anchor-id="course-schedule-i">2. <a href="https://leetcode.com/problems/course-schedule/description/">Course Schedule-I</a></h3>
<p><strong>🎯 Understanding the Test Cases:</strong></p>
<p><em>Test Case 1:</em></p>
<p><code>numCourses = 3, prerequisites = [[1,0], [2, 1]]</code></p>
<p><em>Explanation:</em></p>
<p>There are a total of 3 courses to take. To take course <span class="math inline">\(1\)</span> you should have finished course <span class="math inline">\(0\)</span>. To take the course <span class="math inline">\(2\)</span>, you need to finish course <span class="math inline">\(1\)</span>. If a student decides to pursue courses as follows: <span class="math inline">\(0, 1, 2\)</span>, then all courses can be completed. So we return <code>True</code>.</p>
<p><em>Test Case 2:</em></p>
<p><code>numCourses = 2, prerequisites = [[1,0], [0, 1]]</code></p>
<p><em>Explanation:</em></p>
<p>There are a total of <span class="math inline">\(2\)</span> courses to take. To take course <span class="math inline">\(1\)</span> you should have finished course <span class="math inline">\(0\)</span>. To take the course <span class="math inline">\(0\)</span>, you need to finish course <span class="math inline">\(1\)</span>. It is not possible for a student to complete both courses. So we return <code>False</code>. In essence, there is a cycle in the prerequisites.</p>
<section id="topological-sorting" class="level4">
<h4 class="anchored" data-anchor-id="topological-sorting">2.1 Topological Sorting</h4>
<p>🔍 Problem Understanding:</p>
<p>We have a list of prerequisites where each pair <span class="math inline">\(prerequisites[i] = [a_i, b_i]\)</span> means that you need to complete <span class="math inline">\(b_i\)</span> before taking <span class="math inline">\(a_i\)</span>. In simpler terms, <span class="math inline">\(a_i\)</span> depends on <span class="math inline">\(b_i\)</span>.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Question🤔:
</div>
</div>
<div class="callout-body-container callout-body">
<p>How can we convert this into a graph?</p>
</div>
</div>
<p>If <span class="math inline">\(b_i\)</span> needs to be completed before <span class="math inline">\(a_i\)</span>, we add a directed edge from <span class="math inline">\(b_i \rightarrow a_i\)</span>. Note the direction of the edge. For this problem, we are converting the <code>prerequisites</code> array into graph using adjacency matrix.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>How do we find a sequence of courses that respects all the dependencies? Which algorithm should we use?</p>
</div>
</div>
<p>Once we have converted this problem into a graph problem, we can use the <strong>topological sorting</strong> to find the sequence that respects all the dependencies. You can also solve this problem using <strong>BFS</strong> or <strong>DFS</strong> by detecting cycles in the graph. Here, we’re using topological sort.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Question:
</div>
</div>
<div class="callout-body-container callout-body">
<p>When would we say that we have successfully found the sequence of courses satisfying the dependencies?</p>
</div>
</div>
<p>When we the sequence includes all the courses, and no course is left. If a course is left out, that means we can’t complete all the courses because there’s a cycle in the graph.</p>
<details>
<summary>
<strong>Need help with implementation?</strong>
</summary>
<pre><code class="language-python">
class Solution:
    def preprocessing(self, numCourses, prerequisites) -&gt; list[list[int]]:
        adjacency_matrix = [ [0 for i in range(numCourses)] for i in range(numCourses) ]
        for a, b in prerequisites:
            adjacency_matrix[b][a] = 1
        return adjacency_matrix

    # Implementation of Topological sort for Adjacency matrix
    def toposort(self, AMat):
        #Initialization
        (rows,cols) = len(AMat), len(AMat[0])
        indegree = {}
        toposortlist = []
        
        #Compute indegree for each vertex
        for col in range(cols):
            indegree[col] = 0
            for row in range(rows):
                if AMat[row][col] == 1:
                    indegree[col] = indegree[col] + 1
        
        # Topological sort Computing process
        for i in range(rows):
            # Select the min level vertex for removing the graph which has indegree 0
            zero_indegree = [k for k in range(cols) if indegree[k] == 0]
            if not zero_indegree:return toposortlist #Handle the case where there are no more zero indegree vertices
            
            j = zero_indegree[0]
            # Store the removed vertex j in toposortlist and reduce the indegree by one 
            toposortlist.append(j)
            indegree[j] = indegree[j] - 1
            
            # Reduce the indegree of each adjacent of the removed vertex j by 1
            for k in range(cols):
                if AMat[j][k] == 1:
                    indegree[k] = indegree[k] - 1
                    
        return(toposortlist)

    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool:
        adjacency_matrix = self.preprocessing(numCourses, prerequisites)
        toposortlist = self.toposort(adjacency_matrix)
        if len(toposortlist) == numCourses: return True
        return False
</code>
</pre>
</details>
</section>
<section id="topological-sort-better-implementation" class="level4">
<h4 class="anchored" data-anchor-id="topological-sort-better-implementation">2.2 Topological Sort: Better Implementation</h4>
<p>The approach used is similar to the above approach. However, we are using better data structures to increase our performance. Instead of keeping an adjacency matrix, we are using doubly ended queues and adjacency lists.</p>
<p>Here’s how:</p>
<ul>
<li>Keep a deque for vertices with zero degree queue such that the insert at end and delete from start operations are both constant time.</li>
<li>Keep a dictionary of indegrees which counts the indegrees for each vertex</li>
</ul>
<p>Time Complexity: <span class="math inline">\(O(|V| + |E|)\)</span></p>
<details>
<summary>
<strong>Need help with implementation?</strong>
</summary>
<pre><code class="language-python">
from collections import deque, Counter

class Solution:
    def canFinish(self, numCourse, prerequisites):
        AList = { i: [] for i in range(numCourse)}
        indegree = Counter()
        visited = { i:False for i in range(numCourse)}

        for course, prereq in prerequisites:
            AList[prereq].append(course)
            indegree[course] += 1
    
        # Initialization
        toposortlist = []
        zerodegreeq = deque()
        
        # Find the vertex with indegree 0 and added into the queue
        for u in range(numCourse):
            if indegree[u] == 0:
                zerodegreeq.append(u)
        
        # Topological sort Computing process
        while (zerodegreeq):
            # Remove one vertex from queue which have zero degree vertices
            curr_vertex = zerodegreeq.popleft()       
            # Store the removed vertex in toposortlist and reduce the indegree by one 
            toposortlist.append(curr_vertex)
            indegree[curr_vertex] = indegree[curr_vertex]-1
            
            # Repeat for each adjacent of the removed vertex
            for adj_vertex in AList[curr_vertex]:
                # Reduce the indegree of each adjacent of the removed vertex by 1
                indegree[adj_vertex] = indegree[adj_vertex] - 1
                # If after reducing the degree of adjacent, it becomes zero then insert it into the queue
                if indegree[adj_vertex] == 0:
                    zerodegreeq.append(adj_vertex)                
        
        return len(toposortlist) == numCourse
</code>
</pre>
</details>
</section>
</section>
<section id="course-schedule-ii" class="level3">
<h3 class="anchored" data-anchor-id="course-schedule-ii">3. <a href="https://leetcode.com/problems/course-schedule-ii/description/">Course Schedule-II</a></h3>
<p>This problem is an exact replica of the above problem, except that we have to return a sequence that satisfies the dependencies, instead of returning a boolean of whether or not we can create such a sequence.</p>
<p>We can use the same approaches discussed in the above question.</p>
</section>
<section id="snakes-and-ladders" class="level3">
<h3 class="anchored" data-anchor-id="snakes-and-ladders">4. <a href="https://leetcode.com/problems/snakes-and-ladders/description/">Snakes and Ladders</a></h3>
<p><strong>🎯 Understanding the Test Cases:</strong></p>
<p>Please refer to the <em>Problem Overview</em> where we have discussed the first test case.</p>
<section id="using-bfs" class="level4">
<h4 class="anchored" data-anchor-id="using-bfs">4.1 Using BFS</h4>
<p>📚 <em>Problem Overview:</em></p>
<p>We have a board with <span class="math inline">\(n^2\)</span> cells, and from any cell, we can make up to 6 possible moves. Can we turn this into a graph? Yes! Here’s how:</p>
<ol type="1">
<li>Start at cell 1.</li>
<li>We can roll a dice and move to next six cells. In the first test cases, the next possible moves are: 15, 3, 4, 5, 6, 7 (because cell 2 has a ladder to 15). If a cell has <span class="math inline">\(-1\)</span> value, then it’s an empty cell. But if it has a different value, then it is either a snake or a ladder.</li>
<li>Each possible move from a cell is an edge in our graph.</li>
<li>Once we have the graph, We need to find the least number of moves required to go from cell 1 to cell <span class="math inline">\(n^2\)</span>. This is a <strong>shortest path</strong> problem where there are no weights on the edges- we can use <em>Breadth-First Search (BFS)</em>.</li>
</ol>
<p><em>Pseudocode:</em></p>
<ul>
<li>We first need to convert the board into a graph.
<ul>
<li>For every cell, check the next six cells.
<ul>
<li>If the cell has a ladder or a snake, then we need to find out where the ladder ends which is given in cell: <code>board[row][col]</code></li>
<li>If the cell does not have a ladder or a snake, then <code>board[row][col]</code> will have the vaue <span class="math inline">\(-1\)</span>.</li>
<li>Add the edge as: <code>[cell]</code> to <code>board[row][cell]</code> or the next moves.</li>
</ul></li>
</ul></li>
<li>Once we have the graph, we can run BFS on this graph, which will return the shortest path.</li>
</ul>
<details>
<summary>
<strong>Need help with the implementation?</strong>
</summary>
<pre><code class="language-python">

from collections import deque

# The BFS code from the PDSA book
def BFSListPathLevel(AList,v):
    (level,parent) = ({},{})
    for each_vertex in AList.keys():
        level[each_vertex] = -1
        parent[each_vertex] = -1
    
    q = deque()
    
    level[v] = 0
    q.append(v)
    
    while q:
        curr_vertex = q.popleft()
        for adj_vertex in AList[curr_vertex]:
            if (level[adj_vertex] == -1):
                level[adj_vertex] = level[curr_vertex] + 1
                parent[adj_vertex] = curr_vertex
                q.append(adj_vertex)
                
    return(level,parent)

class Solution:
    def get_indices(self, cell, n):
        """
        A helper function to convert the Boustrophedon style sequence 
        into a cell's row and column index
        """
        remainder = (n - 1) % 2
        row = (n - 1) - ((cell - 1) // n)
        if row % 2 == remainder:
            col = (cell % n) - 1 if cell % n != 0 else n - 1
        else:
            col = (n) - (cell % n) if cell % n !=0 else 0
        return row, col

    def preprocessing(self, board:List[List[int]]) -&gt; list[list[int]]:
        """Converts the board into a graph"""
        n = len(board)
        AList = {i:set() for i in range(1, n*n + 1)}
        for i in range(1, n*n + 1):
            for j in range(i + 1, min(i + 7, n*n + 1)): 
                row, col = self.get_indices(j, n)
                val = board[row][col]
                if val == -1:
                    AList[i].add(j)
                else:
                    if val == i:
                        continue
                    AList[i].add(val)
        return AList            
            
    def snakesAndLadders(self, board: List[List[int]]) -&gt; int:
        n = len(board)
        AList = self.preprocessing(board)
        level, parent = BFSListPathLevel(AList, 1)
        return level[n*n] # The last cell holds shortest path from start to the last cell
</code>
</pre>
</details>
</section>
</section>
<section id="sort-items-by-groups-respecting-dependencies" class="level3">
<h3 class="anchored" data-anchor-id="sort-items-by-groups-respecting-dependencies">5. <a href="https://leetcode.com/problems/sort-items-by-groups-respecting-dependencies/description/">Sort Items By Groups Respecting Dependencies</a></h3>
<section id="using-topological-sort" class="level4">
<h4 class="anchored" data-anchor-id="using-topological-sort">5.1 Using Topological Sort</h4>
<p>📚 <strong>Problem Overview:</strong></p>
<p>We need to order a list of items so that all items in the same group are listed next to each other. Additionally, some items have dependencies, meaning one item must be completed before another. We can use topological sort to solve this problem.</p>
<p>🤔 <strong>The Issue:</strong></p>
<p>If we just run topological sort on the <code>beforeItems</code> array, it might work for some test cases, but not all.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Question:
</div>
</div>
<div class="callout-body-container callout-body">
<p>Can you think of the test cases where this approach will fail?</p>
</div>
</div>
<p><em>Imagine this situation:</em></p>
<pre><code>Group 0: Items [1, 2]
Group 1: Items [3, 4]</code></pre>
<p><em>Here’s the setup:</em></p>
<p>Item 1 has no dependencies (<code>indegree[1] = 0</code>). Item 3 also has no dependencies (<code>indegree[3] = 0</code>). Item 2 and Item 4 each have one dependency (<code>indegree[2] = 1 and indegree[4] = 1</code>).</p>
<p><em>Now, assume:</em></p>
<p>Item 2 must come before Item 4. Item 1 must come before Item 2. This means the correct order should be: 1 → 2 → 4.</p>
<p>The problem arises when choosing between Item 1 and Item 3, as both have no dependencies. If we choose Item 3 first, we should list the other items from Group 1 next to it, leading to an order like this: 3, 4. This leaves us with Group 0 and the sequence 1, 2. The final order would be 3, 4, 1, 2, which breaks the dependency 1 → 2 → 4. (Draw these nodes and edges to get a clearer picture!)</p>
<p>💡 <strong>The Solution:</strong></p>
<p>To solve this, we need to track the dependencies of both individual items and groups. Here’s how we can do that:</p>
<ul>
<li>Create Two Graphs:
<ul>
<li>Item Graph: Use the <code>beforeItems</code> array to build a graph showing how items depend on each other.</li>
<li>Group Graph: Also use the <code>beforeItems</code> array to build a graph showing how groups depend on each other.</li>
<li>We can use either the adjacency list or the adjacency matrix representation. Here, we are using the adjacency list representation.</li>
</ul></li>
<li>Run Nested Topological Sort:
<ul>
<li>Outer graph to perform topological sorting on the <code>group</code> graph.</li>
<li>Then, within each group, sort the items using topological sorting.</li>
</ul></li>
</ul>
<details>
<summary>
<strong>Need help with the implementation?</strong>
</summary>
<pre><code class="language-python">
from collections import deque

class Solution:
    def get_group_wise_elements(self, group, m):
        """Helper function to quickly access all items belonging to a group"""
        group_wise_elements = { i:[] for i in range(m) }
        for i in range(len(group)):
            grp = group[i] if group[i] &gt;= 0 else -i-1
            if grp not in group_wise_elements:
                group_wise_elements[grp] = []
            group_wise_elements[grp].append(i)
        return group_wise_elements

    def preprocessing(self, beforeItems, group, m, n, groupwise_items):
        """
        Given the beforeItems array, this function converts it into two graphs- Groups and Items. 
        Along with it, we are also returning the indegrees of each of the graphs' nodes so that we 
        can smoothly run topological sort. 
        """
        group_indegree, items_indegree = {}, {i:0 for i in range(n)}
        items_alist =  {i:[] for i in range(n)}
        group_alist = {}

        for key in groupwise_items:
            group_alist[key] = set()
            group_indegree[key] = 0
 
        for i in range(len(beforeItems)):
            before = beforeItems[i]
            for num in before:
                if num not in items_alist:
                    items_alist[num] = [ ]
                items_alist[num].append(i)
                items_indegree[i] += 1

                grp_num = group[num] if group[num] &gt;= 0 else -num-1
                grp_i = group[i] if group[i] &gt;= 0 else -i-1  
                if grp_num != grp_i:
                    if grp_num not in group_alist:
                        group_alist[grp_num] = set()
                    group_alist[grp_num].add(grp_i)
        
        for key in group_alist.keys():
            group_alist[key] = list(group_alist[key])

        for start_node in group_alist.keys():
            for end_node in group_alist[u]:
                if end_node not in group_indegree:
                    group_indegree[end_node] = 0
                group_indegree[end_node] += 1

        return items_alist, group_alist, items_indegree, group_indegree

    
    def lpath(self, items_alist, group_alist, items_indegree, group_indegree, groupwise_items, n, group):
        """The actual nested topological sorting algorithm"""
        output = [ ]

        grp_queue = deque()
        items_queue = deque()

        for grp in group_indegree:
            if group_indegree[grp] == 0:
                grp_queue.append(grp)

        # Outer topological sort is for groups
        while grp_queue:
            curr_grp = grp_queue.popleft()
            group_indegree[curr_grp] -= 1
            for adj_grp in group_alist[curr_grp]:
                # Reduce the indegree of each adjacent group of the removed vertex by 1
                group_indegree[adj_grp] -= 1

                # Add new zero degree groups to the group deque
                if group_indegree[adj_grp] == 0 :
                    grp_queue.append(adj_grp)

            # For popped group, find out zero degree items
            for i in groupwise_items[curr_grp]:
                if items_indegree[i] == 0 :
                    items_queue.append(i)

            # Topological sort is for the items
            while items_queue:

                # Remove one vertex from items queue which have zero degree items and reduce the indegree
                curr_vertex = items_queue.popleft()
                output.append(curr_vertex)
                items_indegree[curr_vertex] = items_indegree[curr_vertex] - 1
                
                # Repeat for each adjacent of the removed item 
                for adj_vertex in items_alist[curr_vertex]:
                    # Reduce the indegree of each adjacent of the removed item by 1
                    items_indegree[adj_vertex] = items_indegree[adj_vertex] - 1

                    # Add items to items deque if their indegree becomes zero
                    if items_indegree[adj_vertex] == 0 and group[adj_vertex] == curr_grp:
                        items_queue.append(adj_vertex)

        if len(output) != n: return []
        return output

    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -&gt; List[int]:
        group_wise_items = self.get_group_wise_elements(group, m)

        items_alist, group_alist, items_indegree, group_indegree = self.preprocessing(beforeItems,group, m, n, group_wise_items)
        
        return self.lpath(items_alist, group_alist, items_indegree, group_indegree, group_wise_items, n, group)
</code>
</pre>
</details>
</section>
</section>
<section id="find-if-path-exists" class="level3">
<h3 class="anchored" data-anchor-id="find-if-path-exists">6. <a href="https://leetcode.com/problems/find-if-path-exists-in-graph/description/">Find If Path Exists</a></h3>
<section id="using-bfs-1" class="level4">
<h4 class="anchored" data-anchor-id="using-bfs-1">6.1 Using BFS</h4>
<p><strong>🎯 Understanding the Test Cases:</strong></p>
<p>We have not discussed test cases as it is an easy problem.</p>
<p>📚 <strong>Problem Overview:</strong></p>
<p>We need to figure out if we can go from a source node to a destination node. This is a reachability problem in a graph. We know we can use <em>BFS</em> or <em>DFS</em> on an adjacency list or a matrix for reachability problem.</p>
<p>Can you convert the given <code>edges</code> list into an adjacency list or an adjacency matrix representation? - We have a list of edges where each <code>edges[i] = [u, v]</code> shows an edge between nodes <code>u</code> and <code>v</code>. - To create an adjacency list, we can do:</p>
<pre><code>for u, v in edges:
    adj_list[u].append(v)
    adj_list[v].append(u)</code></pre>
<section id="code-implementation" class="level5">
<h5 class="anchored" data-anchor-id="code-implementation">💻 Code Implementation:</h5>
<p>Note: For a better, more neat code, we have used the <code>deque</code> data structure from the <code>collections</code> module in Python. We can use it to implement a <code>queue</code> used in BFS. It’s a useful data structure to know.</p>
<details>
<summary>
<strong>Need help with the implementation?</strong>
</summary>
<pre><code class="language-python">
from collections import deque

class Solution:
    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -&gt; bool:
        adj_list = { i:[ ] for i in range(n) }
        visited = set()

        # Create the adjacency list representation from Graph
        for u, v in edges:
            adj_list[u].append(v)
            adj_list[v].append(u)

        queue = deque([source])
        visited.add(source)
        while queue:
            vertex = queue.popleft()
            if vertex == destination:
                return True
            for neighbor in adj_list[vertex]:
                if neighbor not in visited:
                    queue.append(neighbor)
                    visited.add(neighbor)
        return False
</code>
</pre>
</details>
</section>
</section>
</section>
<section id="number-of-provinces" class="level3">
<h3 class="anchored" data-anchor-id="number-of-provinces">7. <a href="https://leetcode.com/problems/number-of-provinces/description/">Number of Provinces</a></h3>
<p><strong>🎯 Understanding the Test Cases:</strong></p>
<p>We have not discussed test cases as it is an easy problem.</p>
<p><strong>📚 Problem Overview:</strong></p>
<p>We are given a matrix <code>isConnected</code> where each entry <code>[i][j]</code> tells us if there is a connection (edge) between nodes <code>i</code> and <code>j</code>. We can think of this as an <strong>adjacency matrix</strong> for a graph.</p>
<p>A <strong>province</strong> is a group of nodes that are all connected. The task is to count how many such provinces exist.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>🤔 Can you think of a similar problem that we saw in the lectures?</p>
</div>
</div>
<p>This is a <strong>connected components</strong> problem. We need to find how many separate groups of connected nodes exist in the graph.</p>
<p><strong>💡 The Solution:</strong></p>
<p>To solve this, we can use either <strong>BFS</strong> or <strong>DFS</strong>. For this explanation, we’ll go with <strong>BFS</strong> to explore each connected component one by one.</p>
<details>
<summary>
<strong>Need help with the implementation?</strong>
</summary>
<pre><code class="language-python">
from collections import deque

class Solution:
    def get_neighbors(self, AMat, vertex):
        """Helper function to find out all neighbors of a node given the adjacency matrix."""
        neighbors = []
        for i in range(len(AMat)):
            if AMat[vertex][i] == 1:
                neighbors.append(i)
        return neighbors

    def BFS(self, AMat, source):
        """
        Runs BFS from a given source vertex and returns the set of vertices visited in that run of BFS.
        That is, each run of the BFS will give us one province, or one connected component.
        """
        visited = set()
        queue = deque([source])  # Initialize the queue with the source vertex
        visited.add(source)
        while queue:
            vertex = queue.popleft()
            neighbors = self.get_neighbors(AMat, vertex)  # Pass both AMat and vertex
            for neighbor in neighbors:
                if neighbor not in visited:
                    queue.append(neighbor)
                    visited.add(neighbor)
        return visited

    def findCircleNum(self, isConnected):

        # Initially, every vertex gets an invalid component number
        components = {i: -1 for i in range(len(isConnected))}

        # Keep track of the component number and the number of vertices already visited across BFS runs
        component_number = 0
        seen = 0
        
        while seen &lt; len(isConnected):
            startvertex = min([i for i in range(len(isConnected)) if components[i] == -1])
            visited = self.BFS(isConnected, startvertex)

            # For every vertex that was visited in the current run of BFS, update its component number and update 
            # the number of vertices seen.
            for vertex in visited:
                components[vertex] = component_number
                seen += 1

            # Increment component number such that for the next run of BFS, 
            # a different component number will be assigned
            component_number += 1
            
        return component_number 
</code>
</pre>
</details>
<!-- Add DFS Backtracking problems here. You can add a callout tip for problem patterns. -->
<hr>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>




</body></html>