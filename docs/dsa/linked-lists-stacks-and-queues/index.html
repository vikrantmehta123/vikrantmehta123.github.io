<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Vikrant Mehta">
<meta name="dcterms.date" content="2024-10-03">

<title>Stacks, Queues, Linked Lists, and Arrays – Vikrant</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../../site_libs/quarto-contrib/fontawesome6-0.1.0/all.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/fontawesome6-0.1.0/latex-fontsize.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-CKDPXJ4Y38"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-CKDPXJ4Y38', { 'anonymize_ip': true});
</script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Sofia&amp;family=WindSong:wght@400;500&amp;display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Vikrant</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../dsa/index.html" aria-current="page"> 
<span class="menu-text">DSA</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/vikrant-mehta/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/vikrantmehta123"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://leetcode.com/u/vikrantmehta123/"> <i class="bi bi-code" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://lichess.org/@/vikrant-123"> 
<span class="menu-text"><i class="fa-solid fa-chess-queen" aria-label="chess-queen"></i></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../dsa/index.html">Leet Coding Using Python</a></li><li class="breadcrumb-item"><a href="../../dsa/linked-lists-stacks-and-queues/index.html">Stacks, Queues, Linked Lists, and Arrays</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../dsa/index.html">Leet Coding Using Python</a></li><li class="breadcrumb-item"><a href="../../dsa/linked-lists-stacks-and-queues/index.html">Stacks, Queues, Linked Lists, and Arrays</a></li></ol></nav>
      <h1 class="title">Stacks, Queues, Linked Lists, and Arrays</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">DSA</div>
                <div class="quarto-category">Linked Lists</div>
                <div class="quarto-category">Queues</div>
                <div class="quarto-category">Stacks</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta column-body">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Vikrant Mehta </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">October 3, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../dsa/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Leet Coding Using Python</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../dsa/sorting-and-searching/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Sorting and Searching</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../dsa/linked-lists-stacks-and-queues/index.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Stacks, Queues, Linked Lists, and Arrays</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../dsa/graphs/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Graphs: BFS &amp; DFS</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../dsa/shortest-paths-and-mcst/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Shortest Paths and Minimum Cost Spanning Trees</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../dsa/heaps-and-trees/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Heaps and Trees</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../dsa/greedy/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Greedy</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../dsa/divide-and-conquer/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Divide and Conquer</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../dsa/dynamic-programming/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Dynamic Programming</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../dsa/string-matching/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">String Matching and Tries</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#valid-parentheses" id="toc-valid-parentheses" class="nav-link active" data-scroll-target="#valid-parentheses">1. Valid Parentheses</a></li>
  <li><a href="#longest-consecutive-sequence" id="toc-longest-consecutive-sequence" class="nav-link" data-scroll-target="#longest-consecutive-sequence">2. Longest Consecutive Sequence</a></li>
  <li><a href="#rotate-list" id="toc-rotate-list" class="nav-link" data-scroll-target="#rotate-list">3. Rotate List</a></li>
  <li><a href="#swap-nodes-in-pairs" id="toc-swap-nodes-in-pairs" class="nav-link" data-scroll-target="#swap-nodes-in-pairs">4. Swap Nodes in Pairs</a></li>
  <li><a href="#reverse-nodes-in-k-groups" id="toc-reverse-nodes-in-k-groups" class="nav-link" data-scroll-target="#reverse-nodes-in-k-groups">5. Reverse Nodes in K Groups</a></li>
  <li><a href="#middle-of-the-linked-list" id="toc-middle-of-the-linked-list" class="nav-link" data-scroll-target="#middle-of-the-linked-list">6. Middle of The Linked List</a></li>
  <li><a href="#delete-the-middle-node" id="toc-delete-the-middle-node" class="nav-link" data-scroll-target="#delete-the-middle-node">7. Delete the Middle Node</a></li>
  <li><a href="#delete-nth-node-from-end" id="toc-delete-nth-node-from-end" class="nav-link" data-scroll-target="#delete-nth-node-from-end">8. Delete nth Node From End</a></li>
  <li><a href="#merge-two-sorted-lists" id="toc-merge-two-sorted-lists" class="nav-link" data-scroll-target="#merge-two-sorted-lists">9. Merge Two Sorted Lists</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block column-body" id="quarto-document-content">





<section id="valid-parentheses" class="level3">
<h3 class="anchored" data-anchor-id="valid-parentheses">1. <a href="https://leetcode.com/problems/valid-parentheses/description/">Valid Parentheses</a></h3>
<section id="using-stacks" class="level4">
<h4 class="anchored" data-anchor-id="using-stacks">1.1 Using Stacks</h4>
<p><strong>🎯 Understanding the Test Cases:</strong></p>
<p><em>Test Case 1:</em></p>
<p>Input: <code>s = "[()]"</code></p>
<p><em>Explanation:</em> The string <code>"([])"</code> is valid because each open bracket has a matching closing bracket, and they close in the correct order. Since all brackets are properly paired, the string evaluates to <code>True</code>.</p>
<p><em>Test Case 2:</em></p>
<p><em>Explanation:</em> The string <code>"(]"</code> is invalid because the open bracket <code>(</code> is not closed by the correct type of bracket. The closing bracket <code>]</code> doesn’t match the opening <code>(</code>, so the string evaluates to <code>False</code>.</p>
<p><strong>🔍 Problem Understanding:</strong></p>
<p>We only have three types of brackets: <code>[], (), {}</code>. And we need to close the last opened bracket first. What do you do when you need to close the last opened bracket first? You need a system where the last thing you add is the first thing you take out, right? This is the Last In, First Out (LIFO) system. So, what data structure works best for LIFO? A <strong>stack</strong>! A stack can help us keep track of the brackets. Whenever we find an opening bracket, we push it onto the stack. When we encounter a closing bracket, we pop the stack to see if it matches the last opened bracket.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
🤔Think about this:
</div>
</div>
<div class="callout-body-container callout-body">
<p>Let’s say you’ve read the first two characters of a string and added them to the stack. Your stack might look like this:</p>
<p><code>stack = ['(', '{']</code>.</p>
<p>Now, what if the next character is <code>}</code>? How do you know if this closing bracket matches the last opened one? To figure this out, we can use a simple mapping: each closing bracket corresponds to its opening bracket, like this: <code>closing bracket : Corresponding opening bracket</code>. This way, we can check if every closing bracket matches the correct opening one.</p>
</div>
</div>
<p><em>⚠️ Edge Cases:</em></p>
<p>What happens if you have opening brackets left in the stack, but the string ends? Or what if there are closing brackets, but the stack is empty? How would you handle these situations?</p>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span><br>
Space Complexity: <span class="math inline">\(O(n)\)</span></p>
<details>
<summary>
<strong>Need help with implementation?</strong>
</summary>
<pre><code class="language-python">
class Solution:
    def isValid(self, s: str) -&gt; bool:
        # Keep the mapping as 'closing bracket' : 'Correspoding opening bracket'
        mapping = { 
            ')' : '(', 
            ']' : '[', 
            '}' : '{'
        }

        stack = [ ]

        # O(n)
        for char in s:
            if char not in mapping: # This means that the bracket is an open bracket
                stack.append(char)  # Simply add the open bracket to the stack     
            else:
                # Corner case- stack has no elements but the string has closing bracket
                if len(stack) == 0:
                    return False

                # Check if opening bracket in the stack matches with the closing bracket in the string
                if mapping[char] != stack.pop():
                    return False

        # if stack is empty after checking every char of string
        # that means that we found the closing bracket for every opening bracket. Thus, return True
        # And vice versa. Return False

        return not stack # Returns True if stack is empty, False otherwise
</code>
</pre>
</details>
</section>
</section>
<section id="longest-consecutive-sequence" class="level3">
<h3 class="anchored" data-anchor-id="longest-consecutive-sequence">2. <a href="https://leetcode.com/problems/longest-consecutive-sequence/description/">Longest Consecutive Sequence</a></h3>
<p><strong>🎯 Understanding the Test Cases:</strong></p>
<p><em>Test Case 1:</em></p>
<p><code>nums=[100, 4, 200, 1, 3, 2]</code></p>
<p><em>Explanation:</em></p>
<p>The longest consecutive sequence in the array is [1, 2, 3, 4], which has a length of 4. Note that it is okay if the numbers do not appear contiguously or as a subsequence in the array. For example, in this the number <code>4</code> occurs before the the other numbers in the sequence. All that we are asked is to return the length of the longest sequence whose elements are consecutive integers.</p>
<section id="brute-force" class="level4">
<h4 class="anchored" data-anchor-id="brute-force">2.1 Brute Force</h4>
<p>Can you think of a brute force way to solve this problem? You would look at each number and then search the entire array to see if the next number exists. You would do this for each element in the array, and keep track of the longest one.</p>
<p>But what’s the problem with this approach? It takes a lot of time—specifically, the time complexity is <span class="math inline">\(O(n^2)\)</span>. But we’re asked to find a solution that’s faster, with a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
</section>
<section id="improved-approach-using-sets" class="level4">
<h4 class="anchored" data-anchor-id="improved-approach-using-sets">2.2 Improved Approach Using Sets</h4>
<p>When using brute force, we had to search the entire array to check if the next number existed. Do you think there’s a way to speed up this check? What if we had a data structure that allows us to check if a number exists in constant time?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Hint:
</div>
</div>
<div class="callout-body-container callout-body">
<p>Think of a data structure that has constant-time lookups.</p>
</div>
</div>
<p>We can use a <strong>set</strong> here!</p>
<p>So, how can we solve this using sets?</p>
<ul>
<li>For each number, while the next consecutive number exists, we keep counting.</li>
<li>But wait! If we use this method directly, some numbers might get checked more than once, which still gives us <span class="math inline">\(O(n^2)\)</span> time. How can we improve this?</li>
</ul>
<p>Which numbers can start a consecutive sequence?</p>
<ul>
<li>Only those numbers <code>n</code> where <code>n-1</code> is not in the set. Only these numbers can be the starting points of the longest consecutive sequence. Do you see why?</li>
<li>By finding these starting points, we can run our loop efficiently on only these elements.</li>
</ul>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span> Space Complexity: <span class="math inline">\(O(n)\)</span></p>
<details>
<summary>
<strong>Need help with implementation?</strong>
</summary>
<pre><code class="language-python">
class Solution:
    def longestConsecutive(self, nums: List[int]) -&gt; int:    

        # Convert nums to a set
        num_set = set(nums)

        starting_points = set()
        
        # Only those elements can be starting points where n - 1 is not in num_set
        # O(n)
        for num in nums:
            if num - 1 not in num_set: 
                starting_points.add(num)

        max_length = 0
        # Overall O(n), because the inner while loop is just going to run once for other elements
        for current_num in starting_points:
                current_length = 1
                
                while current_num + 1 in num_set:
                    current_num += 1
                    current_length += 1
                
                max_length = max(max_length, current_length)
        
        return max_length
</code>
</pre>
</details>
<hr>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tips for Linked List Problems:
</div>
</div>
<div class="callout-body-container callout-body">
<p>Before you jump into these problems, here are some tips on solving linked list problems:</p>
<ol type="1">
<li>Debugging linked lists can be a nightmare! So, it’s always better to get the code right the first time.</li>
<li>When solving Linked List problems, it <strong>ALWAYS</strong> helps to draw the diagrams.</li>
<li>Whenever you see a Linked List problem, the first thing that you should do is: handle the base / edge cases like an empty linked list or a list with just one node. It’ll save you a lot of time and stress, especially during the OPPE!</li>
</ol>
</div>
</div>
<hr>
</section>
</section>
<section id="rotate-list" class="level3">
<h3 class="anchored" data-anchor-id="rotate-list">3. <a href="https://leetcode.com/problems/rotate-list/description/">Rotate List</a></h3>
<section id="rotation-logic" class="level4">
<h4 class="anchored" data-anchor-id="rotation-logic">3.1 Rotation Logic:</h4>
<ul>
<li>If <span class="math inline">\(k \gt n\)</span>, then the number of effective rotations is: <span class="math inline">\(k = k \% n\)</span>.</li>
<li>Think about this as a three step problem:
<ol type="1">
<li>First, traverse <span class="math inline">\(k\)</span> nodes. This <code>n - k</code>th node becomes the <code>newhead</code> of the rotated list.</li>
<li>Next, connect the original list’s tail to its <code>head</code>to create a cycle in the linked list.</li>
<li>Finally, walk from the <code>newhead</code> for <code>n</code> nodes to find the <code>newtail</code>, which will become the tail of the rotated list by marking its next pointer as None.</li>
</ol></li>
</ul>
<p><em>Note</em>: Readers are encouraged to look for cleaner and more efficient solution on the platform and take this approach as a starting point.</p>
<details>
<summary>
<strong>Need help with implementation?</strong>
</summary>
<pre><code class="language-python">
class Solution:
    # Gets the length of node: 'n'
    def get_length(self, head):
        current = head
        count = 0
        while current:
            current = current.next
            count += 1        
        return count

    def rotateRight(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:
        n = self.get_length(head)
        
        # Corner case
        if n &lt;= 1:
            return head

        k = k % n # Number of effective rotations

        # In the original list, you need to walk these many steps to get to new head
        walk_these_many_steps = n - k 

        if k == 0 or walk_these_many_steps == 0:
            return head

        # Get the new head of the list that you will get after you rotate
        current = head
        count = 0
        newhead = None
        while current:
            if count == walk_these_many_steps:
                newhead = current
                break

            current = current.next
            count += 1

        # Get to the end of the list so that you can link tail with the head. 
        # But now your linked list is a cycle
        current = head
        count = 0
        while current:
            if not current.next:
                current.next = head
                break
            current = current.next

        # Now you need to make the new tail point to None to break the cycle
        current = newhead
        count = 0
        while current and count &lt; n:
            current = current.next
            count += 1
            if count == n - 1:
                current.next = None

        return newhead
</code>
</pre>
</details>
</section>
</section>
<section id="swap-nodes-in-pairs" class="level3">
<h3 class="anchored" data-anchor-id="swap-nodes-in-pairs">4. <a href="https://leetcode.com/problems/swap-nodes-in-pairs/description/">Swap Nodes in Pairs</a></h3>
<section id="intuition" class="level4">
<h4 class="anchored" data-anchor-id="intuition">4.1 Intuition</h4>
<p>Let’s break this problem down step by step with the help of an image. Imagine we have a linked list, and we want to swap every two nodes. To make this easier, we’ll look at an illustration. We’re going to use some colors and a little helper node.</p>
<ol type="1">
<li><p>We make a dummy node at the front of the list. This dummy points to the head and we’ll call it <code>prev</code> for “previous”. It’ll help us easily swap the first two nodes.</p></li>
<li><p>In each step, we’ll change certain links between nodes. These important links will be marked in <strong>pink</strong>.</p></li>
<li><p>To swap the nodes, we use pointers, shown in <strong>blue</strong>. These pointers help us know which nodes we’re swapping and how to connect them.</p></li>
<li><p>Next to the diagram of each step, we’ll show simple code steps for changing the links.</p></li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Swap Pairs of Nodes.png" class="img-fluid figure-img"></p>
<figcaption>Swap Nodes</figcaption>
</figure>
</div>
<p>Now let’s code this!</p>
<details>
<summary>
<strong>Need help with implementation?</strong>
</summary>
<pre><code class="language-python">
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:
         # Create a Dummy node that becomes "prev"
        dummy = ListNode(0)
        dummy.next = head
        
        prev = dummy 

        # Since we are going to update using prev.next and prev.next.next
        # they both should exist

        while prev.next and prev.next.next:
            # Find the "curr" and "nxt" nodes
            curr = prev.next
            nxt = prev.next.next
            
            # Pink links for swap
            prev.next = nxt
            curr.next = nxt.next
            nxt.next = curr
            
            # Move the "prev" pointer to the next pair
            prev = curr
        
        # The new head of the list is next to the dummy node
        return dummy.next
</code>
</pre>
</details>
</section>
</section>
<section id="reverse-nodes-in-k-groups" class="level3">
<h3 class="anchored" data-anchor-id="reverse-nodes-in-k-groups">5. <a href="https://leetcode.com/problems/reverse-nodes-in-k-group/description/">Reverse Nodes in K Groups</a></h3>
<section id="using-recursion" class="level4">
<h4 class="anchored" data-anchor-id="using-recursion">5.1 Using Recursion</h4>
<p><strong>Intuition:</strong></p>
<p>You know how to reverse a linked list from the Graded Assignment question. Given a number <code>k</code>, can you reverse the first <code>k</code> nodes and return the <code>head</code> and <code>tail</code> after reversing? Now that we have reversed the first <code>k</code> nodes, can you repeat the same thing for the next <code>k</code> nodes? We have a way of reversing groups of <code>k</code> nodes. But here’s the important part: how do you connect these reversed groups?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>🤔 Can you think of a recursive way?</p>
</div>
</div>
<ul>
<li>Remember that the last reversed <code>k</code> nodes will be the first to return when called recursively!</li>
<li>Let’s take an example list: <code>1 -&gt; 2 -&gt; 3 -&gt; 4</code>, and <code>k = 2</code>.
<ul>
<li>First, reverse <code>1 -&gt; 2</code> as <code>2 -&gt; 1</code>, and return the head as <code>2</code> and tail as <code>1</code>.</li>
<li>Then, reverse <code>3 -&gt; 4</code> recursively as <code>4 -&gt; 3</code>, and return the head as <code>4</code> and tail as <code>3</code>.</li>
<li>Now, you just need to connect the tail of the first reversed group (1) to the head of the second reversed group (4). Voilà! You’ve connected the reversed groups.</li>
</ul></li>
</ul>
<details>
<summary>
<strong>Need help with implementation?</strong>
</summary>
<pre><code class="language-python">
class Solution:
    # Helper function: returns the number of nodes in the linked list
    def get_length(self, head):
        count = 0
        current = head
        while current:
            current = current.next
            count += 1
        return count

    def reverse(self, head, k, n):
        # Edge Case: The group is empty
        if not head:
            return head, None

        # Edge case: If k &gt; n, then remaining nodes should remain as they are
        if k &gt; n:
            return head, None

        # Reverse the K nodes in groups starting from "head"
        current = head
        prev = None
        next_node = None
        count = 0
        while current and count &lt;= k:
            # Counting because we want to mark the tail also
            if count &lt; k:
                next_node = current.next
                current.next = prev       
                prev = current            
                current = next_node       

            count += 1
        
        curr_head = prev # The head of the reversed k nodes
        curr_tail = head # tail of the reversed k nodes

        # Recursively call reverse on the next k nodes. Observe that the number of nodes in remaining list is: n - k
        next_head, next_tail = self.reverse(next_node, k, n - k)
        
        # Connect the current group's tail with the head of the next group
        curr_tail.next = next_head 

        return curr_head, curr_tail

    def reverseKGroup(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:
        n = self.get_length(head)
        head, tail = self.reverse(head, k, n)
        return head
</code>
</pre>
</details>
</section>
</section>
<section id="middle-of-the-linked-list" class="level3">
<h3 class="anchored" data-anchor-id="middle-of-the-linked-list">6. <a href="https://leetcode.com/problems/middle-of-the-linked-list/description/">Middle of The Linked List</a></h3>
<section id="using-iteration" class="level4">
<h4 class="anchored" data-anchor-id="using-iteration">6.1 Using Iteration</h4>
<p>Let’s think about how we can find the middle element in a linked list, similar to how we do it in an array. We usually find the middle index by calculating <code>mid = len(L) // 2</code> and then return <code>L[mid]</code>. This works because arrays let us access any element directly by its index.</p>
<p>But in a linked list, we don’t have direct access to an element by index. So, how could we find the middle element?</p>
<p>Here’s how:</p>
<ol type="1">
<li>First, we need to compute <code>len(L)</code>. How can we do this? We could iterate through the entire list, counting each node as we go.</li>
<li>Once we know the length, we can compute the middle index just like we did with the array: <code>mid = len(L) // 2</code></li>
<li>Finally, we would traverse the list again, stopping when we reach the middle node.</li>
</ol>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<details>
<summary>
<strong>Need help with implementation?</strong>
</summary>
<pre><code class="language-python">
class Solution:
    def get_length(self, head):
        """
        Helper function- iterates over the entire linked list and returns the length of the list
        """
        counter = 0
        while head:
            counter += 1
            head = head.next
        return counter


    def middleNode(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:
        # Handle the base case
        if not head:
            return 

        # Compute the middle index 
        n = self.get_length(head)
        mid = n // 2

        # Iterate mid number of steps
        idx = 0
        while idx &lt; mid: 
            head = head.next # note that we are updating the head. So after "mid" iterations, head = middle node
            idx += 1
        
        # Since head = mid after iterating, we return head
        return head
</code>
</pre>
</details>
</section>
</section>
<section id="delete-the-middle-node" class="level3">
<h3 class="anchored" data-anchor-id="delete-the-middle-node">7. <a href="https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/description/">Delete the Middle Node</a></h3>
<section id="using-iteration-1" class="level4">
<h4 class="anchored" data-anchor-id="using-iteration-1">7.1 Using Iteration</h4>
<p>We’ve already discussed how to find the middle node in a linked list. So, if we know how to reach the middle node, can we figure out how to delete it? 🤔</p>
<p>To delete a node in a linked list, here’s what we need to do:</p>
<ol type="1">
<li>Stop at the node before the one we want to delete.</li>
<li>Redirect the pointer: Change the next pointer of the current node to skip the node we want to delete and point to the node after it. Essentially, <code>current.next = current.next.next</code>.</li>
</ol>
<p>⚠️ Edge Cases: What if the linked list has only one node? In this scenario, we need to handle cases where <code>current.next.next</code> doesn’t exist.</p>
<ul>
<li>Time Complexity: <span class="math inline">\(O(n)\)</span></li>
</ul>
<details>
<summary>
<strong>Need help with implementation?</strong>
</summary>
<pre><code class="language-python">
class Solution:
    def get_length(self, head):
        """
        Helper function- iterates over the entire linked list and returns the length of the list
        """
        counter = 0
        while head:
            counter += 1
            head = head.next
        return counter

    def deleteMiddle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:
        mid = self.get_length(head) // 2
        
        current = head # Iterate using current because we want to return the head

        idx = 0
        # Stopping one node before the middle node
        while idx &lt; mid - 1:
            current = current.next
            idx += 1
        
        # Change links of the node before to the next to next node by handling corner case
        if current.next and current.next.next:
            current.next = current.next.next
        else:
            current.next = None
        return head
</code>
</pre>
</details>
</section>
</section>
<section id="delete-nth-node-from-end" class="level3">
<h3 class="anchored" data-anchor-id="delete-nth-node-from-end">8. <a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/">Delete nth Node From End</a></h3>
<section id="using-iteration-2" class="level4">
<h4 class="anchored" data-anchor-id="using-iteration-2">8.1 Using Iteration</h4>
<p>We now know how to delete the middle node. Can you try to solve this problem using the ideas from that question?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Hint: Deleting the <code>nth</code> node from the end is the same as deleting <code>(length - n)th</code> node from the front.</p>
</div>
</div>
</section>
</section>
<section id="merge-two-sorted-lists" class="level3">
<h3 class="anchored" data-anchor-id="merge-two-sorted-lists">9. <a href="https://leetcode.com/problems/merge-two-sorted-lists/description/">Merge Two Sorted Lists</a></h3>
<p>Remember Merge Sort algorithm? Can you see how this question is similar to the <code>merge(A, B)</code> operation from the merge sort algorithm? Only instead of merging arrays, we’re merging linked lists! 🔗</p>
<details>
<summary>
<strong>Need help with implementation?</strong>
</summary>
<pre><code class="language-python">
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:

        # Dummy node to serve as a proxy for head of the list to return      
        dummy = ListNode()
        current = dummy

        # Iterate as long as neither list is exhausted
        while list1 and list2:
            if list1.val &lt; list2.val:
                current.next = list1
                list1 = list1.next
            else:
                current.next = list2
                list2 = list2.next
            current = current.next

        # Attach the remaining nodes of list1 or list2
        if list1:
            current.next = list1
        elif list2:
            current.next = list2

        # The merged list is next to the dummy node
        return dummy.next
</code>
</pre>
</details>
<hr>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>




</body></html>