[
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Vikrant",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nScreener Scraper\n\n\n2 min\n\n\n\nSoftware Engineering\n\n\n\nManually getting data from websites like Screener can be tedious, especially if you want to run a simple computational model. I built a tool to automate the time-consuming…\n\n\n\nOct 29, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDeep Learning Digit Classifier\n\n\n1 min\n\n\n\nData Science\n\n\n\nI implemented MNIST digit classifier using deep learning as a part of exercise in the Fast AI course: Deep Learning for Coders.\n\n\n\nOct 26, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHTTP Server From Scratch\n\n\n2 min\n\n\n\nSoftware Engineering\n\n\n\nI always wondered how HTTP and servers worked under the hood. So I decided to build an HTTP web server from scratch, without relying on existing frameworks!\n\n\n\nOct 25, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMoney Map\n\n\n1 min\n\n\n\nSoftware Engineering\n\n\n\nMoney Map is a financial tool that lets you run simulations with different inputs and get an approximation of your financial plans.\n\n\n\nOct 18, 2024\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "projects/money-map/index.html",
    "href": "projects/money-map/index.html",
    "title": "Money Map",
    "section": "",
    "text": "Project Overview\nFinancial planning is of great importance, especially if you’re young and starting out in your career. As a part of the CFA curriculum, I created simulations for my personal financial planning. These simulations, I figured, were important to keep in the back of the mind as we went about our lives. They give us a sense of what decisions should we take and what decisions should we avoid. Not only that, but they make us think about budgeting and expenditures.\nMoney Map does exactly that. It lets you run simulations that you can use for your financial planning. It also includes additional resources that you can explore as you go about planning your finances. You can access the project live here.\n\n\nFeatures\n\nSimulator based on different input parameters\nPlots of the simulation\nResources for further study\n\n\n\nTech Stack\n\nReactJS\nPlotly\n\nGitHub Repository\nFor more details, the full source code can be found on GitHub: Source Code"
  },
  {
    "objectID": "projects/digit-classifier-from-scratch/index.html",
    "href": "projects/digit-classifier-from-scratch/index.html",
    "title": "Deep Learning Digit Classifier",
    "section": "",
    "text": "Project Overview\nMNIST dataset is the one of the first datasets that you come across in your deep learning journey. In this project, we build a classifier for digits using the MNIST dataset. We build a simple model first, and then see how we can improve this model. We’ll also pass in custom images that we draw ourselves and see how our model performs on them as well!\nGitHub Repository\nFor more details, the full source code can be found on GitHub: Source Code"
  },
  {
    "objectID": "posts/meeting-bhavesh-bhatia/index.html",
    "href": "posts/meeting-bhavesh-bhatia/index.html",
    "title": "A Visionary Leader",
    "section": "",
    "text": "Background\nDad, a schizophrenic, with a minuscule salary of ₹700 per month; mom, a cancer patient; elder brother, deceased from a dog bite reaction; home at a place which was dominated by Naxalite activities, Gondia. With this as his background, came the light of the Bhatia family—Bhavesh.\n Photo With Bhavesh Bhatia\n\n\nHis Story\nBhavesh’s childhood was a continuous struggle. Yet, he had a hankering for adventures.\n\n“मुझे adventures पसंद है। (I love adventures.) In the 8th grade, I made a friend who had an amputated leg. After finishing our 10th grade, we made a trip from our hometown to Kathmandu, Nepal—a distance of 5,620 km—on a bicycle. I had to do the pedalling. He had to do the handling.”\n\nAnd together, they managed their ride. The trip was to make an identity of his own, to prove himself to the world. He did prove himself. He was welcomed like a hero in his hometown.\n\n“गाँवसे २०-३० km बाहर, ४००-५०० लोग welcome करने आए थे। (There were 400-500 people outside my town to welcome me.)”\n\nBut the euphoria of success didn’t last long.\nSoon after returning, his mother was taken seriously ill with stage IV blood cancer.\n\n“घर, ज़मीन, जो भी बचाया था, सब बेच दिया। दोस्तों, रिश्तेदारों से जितना हो सके उतना क़र्ज़ा लिया। (We sold everything we had and took out as much loan as we could for her treatment.) But fate operates on her own accord. We lost her, regardless of our efforts.”\n\nBereft of a great loving support, left alone with a relapsed dad, he was now an unemployed double graduate. This is how Bhavesh’s life stood in the early 1990s.\n\n“माँ चली गयी, पर मैं और daddy बिल्कुल footpath पर आ गए। (Mom left us, but me and dad were on the streets.)”\n\n“I had a master’s degree in Psychology and Economics, yet I was without a job. To be honest, I didn’t want to do a job; I wanted to do business. But what business could I do back then? There was none. I had to find a job. I worked as a telephone operator for a while, 18-20 hours a day for a handful of coins. Later, I got trained as a massage therapist. In fact, I was awarded ‘The Best Massage Therapist in Maharashtra’ award. I worked day and night; I worked till my hands were swollen and somehow managed to save ₹5,000.”\nThese hard-earned ₹5,000 were put to the best use possible.\nBhavesh learned a skill—candle making—a skill that would transform his life. With the ₹5,000, he bought 20 kg of wax and a simple candle die for raw material. Thus, he embarked on his dream of starting a business. His manufacturing unit? A single wooden table. His retail store? A rented handcart. The name registered—Sunrise Candles. The year was 1994 and the place, Mahabaleshwar.\n\n“Back in the day, candles worth thousands of crores were imported from countries like China. Even today, the scenario hasn’t changed much. It was obvious that there was a tremendous opportunity in the candle business, especially in the ‘fancy’ candle business. And Mahabaleshwar, being a tourist destination, played to my advantage.”\n\nBhavesh’s mornings became reserved for manufacturing candles and his evenings, for selling them. He started with plain candles but soon, he was designing fancy candles. Within the first few years, he had created thousands of beautiful designs.\n\n“People used to come to my handcart and fall in love with what I was doing. They would buy a few candles, and then send more people to my handcart. On my handcart came tourists who were specialists in business. They helped me with marketing, packaging, sales, and whatnot. The business grew in this way.”\n\nYet, there was the sword of debt hanging over his head.\n\n“We knew that if we wanted to expand, we had to reach outside Mahabaleshwar. So we started taking part in exhibitions. At one such exhibition, there came a couple who worked at Infosys. It was their wedding anniversary. I gave them a small gift from my side. They were so impressed that they invited me to stay at Infosys for three days and mailed all the 25,000 employees of Infosys to encourage them to buy my products.”\n\nIt’s miraculous what a small act of kindness can do. A ₹60 gift brought in a business of ₹23 lakhs. The whole debt was paid off, with interest.\nBy now, Bhavesh was employing about 30 people. The production was now far exceeding the selling capacity of a handcart. He had to find more places to sell his candles. Again, the tourism value of Mahabaleshwar came to the rescue.\n\n“A few hoteliers were now willing to put up a small selling unit of ours at their hotels. By now, even we’d understood where we should sell the candles, you know, tourist places and such. We put up our stall wherever we got the opportunity and the whole ownership of the stall was given to the guy running it. We could expand even more in this way. More than a thousand corporates are now associated with us including the Taj Group and Grand Hyatt Group.”\n\nHis business now ran smoothly. Yet, the hunger for adventures wouldn’t let him sit still. He took up mountaineering.\n\n“अगर आपको कभी trekking वगैरे करना हो, तो आओ हमारे साथ। (If you want to go on a trek, join us.) I have just finished climbing Kilimanjaro, and my dream is to climb Mount Everest. It’s, like, a real bucket list item.”\n\nWith an annual turnover of more than ₹200 crores, Bhavesh’s company, Sunrise Candles, enlightens more than 70 countries across the globe. It employs more than 10,000 people all over India at its 71 manufacturing units and more than 4,500 selling units.\nGood story, eh? But what is the big deal about Bhavesh Bhatia?\nThe big deal is that he is totally blind.\nBhavesh finished his double degree with the help of his mother who read all his books to him. The institute where he learned candle making was, in fact, the National Association for the Blind, Mumbai (NAB).\nHe was awarded the national award at the hands of the President of India, twice, out of which, one was for being the best employer in the country, which was the best among 58,000 nominations. Out of the 10,000 people he employs, about 9,500 people are blind.\nHe has won a staggering 114 medals in national Paralympics, and still competes for more. As if that wasn’t enough, he became the first-ever blind person to climb Mount Kilimanjaro and aspires to be the first blind person to climb Mount Everest.\nAnd that is a pretty big deal!\n\n\n\nAdvice to the Youth:\n\n“Never tell your destinations where your problems are. Tell your problems where your destinations are.”\n“Success is nothing but being able to sleep well at night. Do whatever you want but never do anything that’ll take away your night’s good sleep.”\n“And don’t wait. Each day is the best day to start doing what you want to do. Just start doing it.”\n\n\nBhavesh sees the world in a way none of us can see. He has a uniquely different perspective on life, a perspective that sits at the far end of the positivity spectrum—something we can emulate. Here’s a story he shared with me that illustrates my point:\n\n“The turning point of my life came when Baba Ramdev hosted a huge shibir of 40-50,000 people in Mahabaleshwar.”\n\n\n“I went there with my friend to see if I could get a cure to my mother’s illness and also, my own. Baba Ramdev was tired telling all these people, “आँखे बंद करो और अंदर झाँको। आँखे बंद करो और अंदर झाँको।” (Close your eyes and peek within, close your eyes and peek within.) Then, I heard an inner voice. It said that these people had to try to close their eyes, and even then, they were failing. And here I was, lucky to have been spared of the trouble. “Treatment तो नही मिला पर मेरा काम हो गया।” (I didn’t get a treatment to our illnesses but I got a cure for my problems.)”"
  },
  {
    "objectID": "posts/how-to-learn-dl/index.html",
    "href": "posts/how-to-learn-dl/index.html",
    "title": "Mastering Deep Learning as a Non-Techie",
    "section": "",
    "text": "Even if you closely follow AI and deep learning, chances are you haven’t heard of Radek Osmulski. He’s a deep learning engineer at Nvidia and a top competitor on Kaggle. But what’s really inspiring about Radek’s story is that he didn’t write a single line of code until he was 29! So how did he go from not knowing how to program to landing a job at Nvidia? How did he master deep learning so well? Radek answers these questions in his book, Meta Learning, which you can buy here.\nIn this blog post, I’ll summarize the key ideas from Meta Learning, so that even if you’re not a technical expert, you can get started and master deep learning yourself.\n\nThe Essential Skills\nYou might think deep learning requires advanced knowledge of statistics, algorithms, data structures, or calculus. But in reality, Radek argues that what you really need are these four skills:\n\nNavigating Stack Overflow: Get familiar with the interface, learn to navigate the site.\nReading documentation: Start with open-source projects—it’s intimidating at first, but it gets easier. By seeing how others code, you’ll improve your own. Take any open-source project in your preferred language and start exploring it.\nUnderstanding code repositories: No matter which one you use, editors have powerful features that make your life easy. Know them!\nUsing version control (Git): Nearly all of the world’s code is managed through Git, so learning how to use basic Git is extremely important. Get started here.\n\nIt sounds simple, right? None of these are deep learning-specific skills, but they are essential for implementing deep learning projects (or any software project, for that matter). If you have these skills, you can build on these to learn anything!\nYou can parallely take FastAI’s deep learning course as well to get familiar with Deep Learning. More on this later.\n\n\nShare Your Work\nYou learn best by doing, but even better by sharing. Sharing isn’t about showing off; it’s about reflecting. If, like me, you’re not someone who posts on social media often, this can be tough. But it’s worth breaking the barrier.\nSharing what you’re learning forces you to reflect, and reflection means deeper understanding. Start a blog, even if it’s just for yourself. Write about what you’re learning, then share it. Remember, you don’t have to be an expert to start writing a blog. Your journey as a beginner is just as important, especially for your own growth.\n\n\nBUILD. BUILD. BUILD.\nOne of the biggest barriers to learning deep learning is there’s just too much theory. You are told that you need to know statistics, calculus, and basic machine learning to just get started with deep learning. Radek’s advice is clear: stop focusing on theory, and start building. It’s better to build first and figure out the theory later. In his words, a better approach is: “Use one cup of theory, one cup of practice. Rinse and repeat.”\nDon’t overdo it with too many courses—pick one. By far, the best course on learning deep learning is the FastAI’s Deep Learning course. In fact, engineers at OpenAI are required to take this course before joining. You can start with this course, build the basics, and get your hands dirty!\n Meta Learning by Radek Osmulski\n\nI claim no credit for the information presented here. All insights are from Radek’s book. My goal was to present a small summary and to absorb the learnings better myself."
  },
  {
    "objectID": "posts/creating-http-server-from-scratch/index.html",
    "href": "posts/creating-http-server-from-scratch/index.html",
    "title": "Building an HTTP Server From Scratch",
    "section": "",
    "text": "Running a web server can seem like magic- you type a command fastapi dev main.py or node app.js, and boom, your app is live on a server. But have you ever wondered what’s happening behind the scenes? In this post, we’ll build our own HTTP server from scratch and know what really goes on under the hood!\n\nWhat’s HTTP?\nHTTP is one set of rules (called a protocol) that computers use to talk to each other over the internet. It’s ‘text-based,’ meaning it sends and receives plain text messages. Don’t worry if this doesn’t make sense just yet- by the end of this blog, you’ll know exactly how it works!\n\n\nWhat’s a Server?\nAt its core, a server responds to requests of clients. Think of it like this: a client (like your web browser) asks for something, and the server sends it back. But how do they “talk” to each other? How does the server know what to send?\nTo make this interaction happen, there are two things we need:\n\nThe server needs to listen for and accept connections from clients. Clients will send requests as bytes (just raw data).\nThe server should then figure out what the client wants (like a webpage) and respond with the right data- again, as bytes.\n\nThis is our wishlist for the server. Now, let’s see how we can make this happen:\nTo start, we need a TCP Server. A TCP server listens for requests and ensures that data is sent and received reliably. This will let us connect with clients, the first item in our wishlist. Let’s break this down step by step with code:\n\nImplementing a TCP Server:\nFirst, we need to import the socket library, which is needed to set up the server to accept connections. It’s for handling low-level networking interfaces, which we don’t need to worry ourselves with.\nimport socket\nNow, let’s define a class called TCPServer. This class will set up a server that listens for client connections.\nclass TCPServer:\n    def __init__(self, port=8080) -&gt; None:\n        self.host = \"127.0.0.1\"  # Localhost IP\n        self.port = port  # The port number the server will listen on\nHere, we are specifying that our server will run on localhost (127.0.0.1) on port 8080. The __init__ function initializes our server with these default values.\nTo make our server actually do something, we need to set it up to listen for client requests:\ndef start(self):\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.bind((self.host, self.port))  # Bind the server to the host and port\n    s.listen(5)  # The server can accept up to 5 connections at a time\nWe don’t need to know details of these methods right now. Just know that this code sets up a server that listens for up to 5 client requests at a time. That’s all we need for now!\nOnce the server is listening, we need to accept the connection request from the client and handle it. This is done using accept() and recv() methods. And we need the server to keep listening to incoming requests, so put this in an infinite loop:\nwhile True:\n    conn, addr = s.accept()  # Accept a new connection\n    print(f\"Connection established with {addr}\")\n    data = conn.recv(2048)  # Read data from the client (2KB max)\ns.accept() waits until a client connects. Once connected, it returns two things:\n\nconn: the connection object to communicate with the client.\naddr: the client’s address.\n\nrecv(2048) reads up to 2048 bytes (2 KB) of data sent from the client.\nAt this point, the server is simply waiting for a request from client and accepting the data sent in the request.\nAfter receiving the data, we need to process it and send a response back to the client:\n    response = self.handle_request(data)  # Process the client request\n    conn.sendall(response)  # Send the response back to the client\n    conn.close()  # Close the connection\nhandle_request(data) is a method that we’ll implement later to process the client’s request. This is where we meet the second requirement of the server- understanding what the client wants and sending the response back.\nsendall() sends the response back to the client, and conn.close() closes the connection.\nAnd that’s it! With this setup, our server can accept and respond to client requests.\nHere’s the full version of the code:\nimport socket\n\nclass TCPServer:\n    def __init__(self, port=8080) -&gt; None:\n        self.host = \"127.0.0.1\"\n        self.port = port\n\n    def start(self):\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.bind((self.host, self.port))\n        s.listen(5)\n\n        while True:\n            conn, addr = s.accept()  # Accept new connection\n            print(f\"Connection established with {addr}\")\n            data = conn.recv(2048)  # Receive data from client\n            response = self.handle_request(data)  # Process the request\n            conn.sendall(response)  # Send the response back to the client\n            conn.close()  # Close the connection\n\n    def handle_request(self, data):\n        pass  # To be implemented later\n\n\n\n\nBuilding the HTTP Server\nOkay, so we’ve got our TCP server ready, and it’s time to implement the most important part—the handle_request function. This is where our server takes the request, figures out what the client wants, and then sends back a proper response.\nBut how does the server know what the client wants?\nThe client’s request comes as a stream of bytes. But HTTP is a text-based protocol, meaning that the request can be converted to text and it follows specific rules and formats. So we convert those bytes into strings and parse that string to understand what the client is asking for.\nHTTP requests have a fixed format which we can use to extract information from the request, like:\n\nThe method (e.g., GET or POST)\nThe URI (what page or resource the client wants)\nThe headers (extra info about the request)\nThe body (optional data sent by the client)\n\nNote: Refer to this website to know the structure of HTTP request.\n\nclass HTTPServer(TCPServer):\n    def __init__(self, port=8080) -&gt; None:\n        super().__init__(port)\n\n    def handle_request(self, data):\n        data = data.decode() # convert bytes into string\n        request = self.parse(data)\n\n        self.create_response() # Implemented later\n\n    def parse(self, data:str):\n        \"\"\"\n        This function will parse the HTTP request and return the method, URI, headers, and body.\n        \"\"\"\n        request = {}\n        lines = data.split(\"\\r\\n\")  # Split the request by line\n\n        # First line contains method, URI, and HTTP version\n        request_line = lines[0]\n        words = request_line.split(\" \")\n        request['method'] = words[0]\n\n        if len(words) &gt; 1:\n            # For some requests, URI might be missing (e.g., homepage)\n            request['uri'] = words[1] \n\n        if len(words) &gt; 2:\n            request['http_version'] = words[2]\n\n        # Now let's extract headers and body\n        body = ''\n        in_headers = True\n        request['headers'] = {}\n\n        for line in lines[1:]:\n            if line == '':  # Blank line separates headers from body\n                in_headers = False\n            elif in_headers:\n                key, value = line.split(': ', 1)\n                request['headers'][key] = value\n            else:\n                body += line\n\n        request['body'] = body\n        return request\nWhat’s happening here?\nWe are converting the request into a string first, then we are parsing it using simple string manipulating in Python to extract information like the HTTP method, the URI that the client wants, along with the HTTP request headers and body.\nIf we didn’t know the structure of an HTTP request, we can’t do this string manipulation, and we won’t know what the client wants! But because HTTP has a fixed format (a “protocol”), we can parse the request accurately .\nOnce we know what the client wants, it’s time to respond. But remember, HTTP has format for responses too! We can’t just send plain text back. We have to structure our response according to the HTTP protocol:\n\nA response line (e.g., HTTP/1.1 200 OK)\nThe headers (e.g., server info)\nA blank line (separating headers from the body)\nThe body (the actual content)\n\nHere’s how we can do it:\n\ndef create_response(self, request) :\n    if request['method'] == 'GET' and request['uri'] == '/hi':\n        return hello()\n    elif request['method'] == 'GET' and request['uri'] == '/namaste':\n        return namaste()\n\ndef namaste():\n    response_line = \"HTTP/1.1 200 OK\\r\\n\" \n    response_headers = f\"Server: {socket.gethostname()}\"\n    blank_line = b\"\\r\\n\"\n    response_body = \"Namaste!\"\n\n    # Concatenate everything and return it as bytes\n    return b\"\".join([response_line, response_headers, blank_line, response_body])\n\ndef hello():\n    response_line = \"HTTP/1.1 200 OK\\r\\n\" \n    response_headers = f\"Server: {socket.gethostname()}\"\n    blank_line = b\"\\r\\n\"\n    response_body = \"Hello World!\"\n\n    # Concatenate everything and return it as bytes\n    return b\"\".join([response_line, response_headers, blank_line, response_body])\nHere’s the entire code for the HTTP Server:\n\nclass HTTPServer(TCPServer):\n    def __init__(self, port=8080) -&gt; None:\n        super().__init__(port)\n\n    def handle_request(self, data):\n        data = data.decode() \n        request = self.parse(data)\n\n        self.create_response() \n\n    def parse(self, data:str):\n        \"\"\"\n        This function will parse the HTTP request and return the method, URI, headers, and body.\n        \"\"\"\n        request = {}\n        lines = data.split(\"\\r\\n\") \n        request_line = lines[0]\n        words = request_line.split(\" \")\n        request['method'] = words[0]\n\n        if len(words) &gt; 1:\n            request['uri'] = words[1] \n\n        if len(words) &gt; 2:\n            request['http_version'] = words[2]\n\n        body = ''\n        in_headers = True\n        request['headers'] = {}\n\n        for line in lines[1:]:\n            if line == '':  \n                in_headers = False\n            elif in_headers:\n                key, value = line.split(': ', 1)\n                request['headers'][key] = value\n            else:\n                body += line\n\n        request['body'] = body\n        return request\n\n\n    def create_response(self, request) :\n        if request['method'] == 'GET' and request['uri'] == '/hi':\n            return hello()\n        elif request['method'] == 'GET' and request['uri'] == '/namaste':\n            return namaste()\n\n    def namaste():\n        response_line = \"HTTP/1.1 200 OK\\r\\n\" \n        response_headers = f\"Server: {socket.gethostname()}\"\n        blank_line = b\"\\r\\n\"\n        response_body = \"Namaste!\"\n\n        # Concatenate everything and return it as bytes\n        return b\"\".join([response_line, response_headers, blank_line, response_body])\n\n    def hello():\n        response_line = \"HTTP/1.1 200 OK\\r\\n\" \n        response_headers = f\"Server: {socket.gethostname()}\"\n        blank_line = b\"\\r\\n\"\n        response_body = \"Hello World!\"\n\n        # Concatenate everything and return it as bytes\n        return b\"\".join([response_line, response_headers, blank_line, response_body])\nThis is already a perfectly valid HTTP server! But imagine we had 100s of functions and URI combinations. The if-else conditions will very quickly get messy. But we can make this better! We’ll use a dictionary to map specific requests to their handler functions. This is how modern web frameworks cna handle routes!\n\nroutes = {\n    ('GET', '/hi'): hello,\n    ('GET', '/namaste'): namaste\n}\n\ndef create_response(self, request):\n    # Look up the appropriate function in the routes dictionary\n    handler = routes[(request['method'], request['uri'])]\n    return handler()\nThis is a great improvement. An even better one is if you use decorators. You can add more routes, handle different HTTP methods, or experiment with cookies and sessions. I’ll leave that for you to implement! Now, hopefully, commands like fastapi dev main.py are not magic blackboxes anymore.\nHappy coding!😄\n\n\n\nCredits and Resources:\nTo build this server, I’ve relied on the following resources:\n\nBharat Chauhan Blog\nNeso Academy Course on Networking\nMDN Documentation\nYou can check out this repository for an improved version of the HTTP server we built."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Vikrant",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nBuilding an HTTP Server From Scratch\n\n\n\n\n\n\nSoftware Engineering\n\n\n\nServing a web application is as simple as running a single command. But this hides a lot of details. In this post, we create an HTTP server from scratch in Python to peek under the hood.\n\n\n\n\n\nOct 27, 2024\n\n\n14 min\n\n\n\n\n\n\n\n\n\n\n\n\nBuilding a Digit Classifier From Scratch\n\n\n\n\n\n\nData Science\n\n\n\nIn this post, I’ll share how I created my first deep learning model. I created a neural network from scratch using FastAI and PyTorch. While I didn’t write code for backpropagation (thankfully, PyTorch is there!), I did write the building blocks myself, which made this incredibly fun!\n\n\n\n\n\nOct 23, 2024\n\n\n8 min\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge Accepted!\n\n\n\n\n\n\nBusiness\n\n\n\nThe incredible journey of Shashikant Parakh, the man who transformed NAMCO Hospital and built a legacy of success through relentless challenges. From business ventures to life lessons, his story is a testament to dreaming big and making a difference.\n\n\n\n\n\nOct 20, 2024\n\n\n5 min\n\n\n\n\n\n\n\n\n\n\n\n\nMastering Deep Learning as a Non-Techie\n\n\n\n\n\n\nData Science\n\n\nPsychology\n\n\nBooks\n\n\n\nHow do you master deep learning, especially if you’re not a ‘techie’? Radek Osmulski did just this. He went from having a boring job to an exciting career at NVidia. This post tells you how.\n\n\n\n\n\nOct 18, 2024\n\n\n3 min\n\n\n\n\n\n\n\n\n\n\n\n\nA Visionary Leader\n\n\n\n\n\n\nBusiness\n\n\n\nBhavesh Bhatia’s story is nothing short of inspirational. He started with a rented handcart as a store, and built a business employing more than 10,000 people. Read on to know how he did it.\n\n\n\n\n\nOct 15, 2024\n\n\n7 min\n\n\n\n\n\n\n\n\n\n\n\n\nMastering Life Like a Grandmaster\n\n\n\n\n\n\nChess\n\n\nBooks\n\n\n\nVishy Anand, the five-time world champion, is a person who inspires many. His advice, like his chess, is well thought out and worth listening to. Recently, he published his book: “Mind Master: Winning Lessons from a Champion’s life”. Read on to find out what’s Vishy’s take on life.\n\n\n\n\n\nOct 13, 2024\n\n\n4 min\n\n\n\n\n\n\n\n\n\n\n\n\nHow Good Is Sleep!\n\n\n\n\n\n\nBooks\n\n\nPsychology\n\n\n\nWhy do we sleep? How do we sleep? What are dreams? Until now, sleep was a mystery. But the developments in technology allow us to answer such questions. In his bestselling book “ Why We Sleep: The New Science of Sleep and Dreams”, neurologist and sleep researcher Matt Walker answers the same questions. He takes us on a journey from ‘Sleep is good’ to ‘How good is sleep?’\n\n\n\n\n\nMay 16, 2021\n\n\n10 min\n\n\n\n\n\n\n\n\n\n\n\n\nMastering Anything With Deliberate Practice\n\n\n\n\n\n\nPsychology\n\n\nBooks\n\n\n\n\n\n\n\n\n\nAug 28, 2020\n\n\n10 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "dsa/week8.html",
    "href": "dsa/week8.html",
    "title": "Leet Code Divide and Conquer Problems",
    "section": "",
    "text": "1. Merge K Sorted Lists\n📚 Problem Overview:\nWe need to merge several lists into one sorted list. We can use divide and conquer to do this faster!\n💡 The Solution:\n\nIf there are only two lists in the input, merge them.\nOtherwise, split the input list into two halves.\n\nRecursively call merge on the left half\nRecursively call merge on the right half.\nMerge the output from the two halves.\n\n\n\n💻 Code Implementation:\nclass Solution:\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"Code to merge two linked lists\"\"\"\n        if not list1: return list2\n        if not list2: return list1\n        dummy = ListNode()\n        current = dummy\n\n        # Iterate as long as neither list is exhausted\n        while list1 and list2:\n            if list1.val &lt; list2.val:\n                current.next = list1\n                list1 = list1.next\n            else:\n                current.next = list2\n                list2 = list2.next\n            current = current.next\n\n        # Attach the remaining nodes of list1 or list2\n        if list1:\n            current.next = list1\n        elif list2:\n            current.next = list2\n\n        # The merged list is next to the dummy node\n        return dummy.next\n\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n        # Base Cases\n        if not lists:\n            return \n        if len(lists) == 1:\n            return lists[0]\n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n\n        # Split lists into two halves and recursively call merge on them\n        mid = len(lists) // 2\n        left_half = self.mergeKLists(lists[:mid])\n        right_half = self.mergeKLists(lists[mid:])\n\n        return self.mergeTwoLists(left_half, right_half)"
  },
  {
    "objectID": "dsa/week6.html",
    "href": "dsa/week6.html",
    "title": "Leet Code Problems on Heaps and Trees",
    "section": "",
    "text": "1. Validate Binary Search Tree\n\n1.1 Using Inorder Traversal\n🎯 Understanding the Test Cases:\nTest Case 1:\nroot = [ 2, 1, 3]\nExplanation:\nThis is the first test case from the problem description. A valid binary search tree is a one where every node’s left child has value less than the node, and the right child has a value greater than the node. That is: \\(left &lt; current &lt; right\\). We can see from the tree that this is indeed the case. So, it is a valid binary search tree.\nTest Case 2:\nroot = [ 5, 1, 4, None, None, 3, 6]\nExplanation:\nThis is the second test case from the problem description. The node with value \\(4\\) is the right child of the node with value \\(5\\). This violates the conditions of a binary search tree. So, we return False. Note that this violation can occur in any internal node- not just the root node.\n📚 Problem Overview:\nIn a binary search tree (BST), the inorder traversal gives a sorted list of elements. If the BST is valid, then it’s inorder traversal will produce a sorted list. If it is not valid, the inorder traversal will not produce a sorted list.\n💡 Approach:\n\nDo inorder traversal on the tree.\nCheck if the result is sorted by comparing each element with the previous one.\n\nIf the list is sorted, the tree is a valid BST. If not, it’s invalid.\n⏳ Time Complexity: \\(O(n)\\)\n\n💻 Code Implementation:\nclass Solution:\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n\n        tree = self.inorder_traversal(root) # Do inorder traversal\n\n        # Base Case: if tree has just one element, then it is a valid BST\n        if len(tree) &lt;= 1:\n            return True\n\n        # If the list is sorted, then the L[i - 1] will always be smaller than L[i]\n        for i in range(1, len(tree)):\n            if tree[i - 1] &gt;= tree[i]:\n                return False\n        return True\n\n    def inorder_traversal(self, root):\n        if not root:\n            return []\n        return self.inorder_traversal(root.left) + [root.val] + self.inorder_traversal(root.right)     \n\n\n\n\n2. Network Delay Time\n\n2.1 Using Dijkstra\n🎯 Understanding the Test Cases:\nTest Case 1:\ntimes = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2\nExplanation:\nThis is the first test case from the problem description. Starting node is given as \\(k=2\\). From \\(2\\), it will take 1 unit of time to reach both nodes 1 and 3. The signal can travel along both edges in parallel. So reaching both nodes only takes 1 unit of time. But we still have one more node left. After reaching node 3, it will take another 1 unit of time to reach node 4. Once the last node is reached, we return the time taken. In this case, it was 2. Can you relate this to the analogy discussed in one of the lectures?\n📚 Problem Overview:\nWe have an array times where each element times[i] = [u, v, w] represents a directed edge from node u to node v with weight w. The edges are directed and weighted.\nCan you convert the times array into a graph?\nWe can represent the times array as an adjacency list:\nWList = { i:[] for i in range(1, n+1) }\nfor u, v, w in times:\n    WList[u].append((v, w))\nWe need to find out the minimum time it will take for the signal to reach all nodes if started from the node k. Can you identify what type of a problem this is? 🤔\nThis is a shortest path problem. Since the weights are non-negative, we can solve it using Dijkstra’s algorithm. The minimum time for the signal to reach all nodes is the maximum shortest path found after running Dijkstra. In other words, it’s the time when the last node receives the signal.\n\n💻 Code Implementation:\nimport heapq\n\nclass Solution:\n    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -&gt; int:\n        # Convert the \"times\" array into an adjacency list\n        WList = { i:[] for i in range(1, n+1) }\n        visited = {i : False for i in range(1, n+1)}\n        for u, v, w in times:\n            WList[u].append((v, w))\n\n\n        # Run Dijkstra on it\n        dist = {node: float('inf') for node in range(1, n+1)}\n        dist[k] = 0\n\n        # Priority queue\n        heap = [(0, k)]  # (distance, node)\n\n        while heap:\n            # By default, heapq.heappop(heap) returns the minimum element from heap\n            current_dist, node = heapq.heappop(heap) \n            visited[node] = True\n\n            if current_dist &gt; dist[node]:\n                continue\n\n            for neighbor, weight in WList[node]:\n                if visited[neighbor]:\n                    continue\n                distance = current_dist + weight\n                if distance &lt; dist[neighbor]:\n                    dist[neighbor] = distance\n                    heapq.heappush(heap, (distance, neighbor))\n\n        # The minimum time taken for the signal to reach all the vertices, is the same as the last vertex to \n        # get \"burnt\" in Dijkstra's algorithm, which is the same as maximum of shortest distance values\n        max_dist = max(dist.values())\n        return max_dist if max_dist != float('inf') else -1 # Check if all nodes can be reached or not.\n\n\n\n\n3 Maximum Spending After Buying Items\n🎯 Understanding the Test Cases:\nThe test cases given in the problem statement are detailed. So we have not discussed them here. One thing to note in the given test cases: The order in which possible values are getting removed from the matrix is from smallest to largest. Can you think of the reason why?\n\n3.1 Brute Force\nWe are given an \\(m \\times n\\) matrix, and we can take out values only from the right end of each row. Further, the amount spent on a day is defined as day number * value of the product.\nTo maximize spending over m * n days, can you think of which element do we need to remove first? It should be the smallest element that we can remove, because the spending can be maximized if larger values are taken near the end of m * nth day. So, from each rows’ last column, we need to pop the one that is the smallest.\nPseudocode: - Keep a variable for max spending. - Iterate day counter $ m n$ times - Keep a minimum value variable. - Find out the minimum last element for every row- since we can only take elements from the rightmost end. - Pop and multiply the minimum with the day counter and add this to the max spending.\nTime Complexity: \\(O(m^2n)\\)\n\n💻 Code Implementation:\nclass Solution:\n    def maxSpending(self, values: List[List[int]]) -&gt; int:\n        m, n = len(values), len(values[0])  \n        \n        max_spending = 0\n\n        # Iterate over all days\n        for day in range(1, m*n + 1):\n            # Find out the minimum val of the product that can be bought\n            min_val, min_index = float('inf'), None\n            for j in range(m):\n                # Check if the row is not empty\n                # And since only rightmost product can be bought, only compare L[j][-1]th element\n                if values[j] and values[j][-1] &lt; min_val: \n                    min_val = values[j][-1]\n                    min_index = j\n\n            # Pop the minimum value product and add the value to answer\n            product_val = values[min_index].pop()\n            max_spending += day * product_val\n        return max_spending\n\n\n\n3.2 Using Minheaps\nWe still need to find the minimum of the rightmost elements and add it to the counter. Can you think of a data structure that lets us efficiently remove the minimum element? Minheaps can be used.\nLet’s see how: Let’s assume we have the values array as follows: \\[\n\\begin{bmatrix}\n4 & 3 \\\\\n7 & 5\n\\end{bmatrix}\n\\]\nThe heap will consist of all the rightmost elements: $heap = [ 3, 5] $. From this minheap, we can remove the minimum easily. After delete_min operation, heap looks like: $ heap = [ 5] $ and the matrix values looks like this:\n\\[\n\\begin{bmatrix}\n4 \\\\\n7 & 5\n\\end{bmatrix}\n\\]\nNow, for the first row, the rightmost element is \\(4\\). We need to add it to the minheap for the next iteration for this approach to work well as this: $ heap = [4, 5]$. To do this well, we’ll keep track of the row_index to note from which row was this minimum popped.\nHere’s the pseudocode:\n\nKeep the max spending variable\nCreate the minheap for the rightmost elements.\nIterate day counter over $ m n$ times\nRemove the minimum from the Minheap.\nFrom the row from which the minimum was popped, insert the new last element in the heap.\n\nTime Complexity: \\(O(mn \\cdot log(m))\\)\n\n💻 Code Implementation:\nclass Minheap:\n    def __init__(self):\n        self.A = []\n\n    def min_heapify(self,k):\n        l = 2 * k + 1\n        r = 2 * k + 2\n        smallest = k\n        if l &lt; len(self.A) and self.A[l][0] &lt; self.A[smallest][0]:\n            smallest = l\n        if r &lt; len(self.A) and self.A[r][0] &lt; self.A[smallest][0]:\n            smallest = r\n        if smallest != k:\n            self.A[k], self.A[smallest] = self.A[smallest], self.A[k]\n            self.min_heapify(smallest)\n        \n    def delete_min(self):\n        item = None\n        if self.A != []:\n            self.A[0],self.A[-1] = self.A[-1],self.A[0]\n            item = self.A.pop()\n            self.min_heapify(0)\n        return item\n\n    def insert_in_minheap(self,d):\n        self.A.append(d)\n        index = len(self.A)-1\n        while index &gt; 0:\n            parent = (index-1)//2\n            if self.A[index][0] &lt; self.A[parent][0]:\n                self.A[index],self.A[parent] = self.A[parent],self.A[index]\n                index = parent\n            else:\n                break\n            \nclass Solution:\n    def maxSpending(self, values: List[List[int]]) -&gt; int:\n        m, n = len(values), len(values[0])  \n\n        # Using Priority Queues- O(mn log(m))\n        heap, max_spending = Minheap(), 0\n\n        # Create a minimum heap from the last elements\n        for i in range(m):\n            heap.insert_in_minheap([values[i][-1], i]) # Every elem in heap is: [value, row_number]\n        \n        # Iterate over days\n        for day in range(1, m*n+1):\n            min_val, min_store_index = heap.delete_min() # Delete based on value\n            values[min_store_index].pop() # Pop from values array\n            max_spending += day * min_val\n            if values[min_store_index]:\n                heap.insert_in_minheap([values[min_store_index][-1], min_store_index])\n\n        return max_spending\n\n\n\n\n4. Average of Levels in Binary Tree\n🎯 Understanding the Test Cases:\nTest Case 1:\nroot = [3,9,20,null,null,15,7]\nExplanation:\nIn the given figure, the first level has only one node. So the average of 1st level is: \\(3\\). In the second level, there are two nodes: 9 and 20. So, the average of the second level is: \\(\\dfrac{(9 + 20 )}{2}\\). Similarly, the third level has two nodes: 15 and 7. So, the average of the third level is: \\(\\dfrac{(15 + 7)}{2}\\). In general, if there are \\(n\\) nodes in a level, we need to return average as: \\(\\dfrac{\\text{sum of the n nodes' values}}{n}\\)\n\nUsing BFS:\n📚 Problem Overview:\nTo find the average of values for each level of the tree, we need to process the tree level-by-level. Remember, a tree is just a graph with no cycles , so we can apply graph algorithms to trees too!\nWhen you hear “level-by-level,” which algorithm comes to mind? 🤔\nYep, good old BFS (Breadth-First Search)! BFS helps us traverse the tree one level at a time, which is exactly what we need here. For each level, we collect all the nodes, then simply compute the average of their values.😊\n\n💻 Code Implementation:\nfrom collections import deque\n\nclass Solution:\n    def averageOfLevels(self, root: Optional[TreeNode]) -&gt; List[float]:\n        q = deque()\n        q.append(root)\n\n        answer = []\n        \n        while q:\n            level_sum = 0 # The sum of the values of a given level\n            level_nodes = len(q)  # Number of nodes at the current level\n\n            # Since we use FIFO, this loop ensures that all nodes belonging to one level are popped\n            for i in range(level_nodes):\n                node = q.popleft()\n                \n                level_sum += node.val\n\n                # Add left and right children to the queue if they exist. \n                # Nodes in binary tree have at most 2 neighbors only- the right and left child\n                if node.right: \n                    q.append(node.right)\n                if node.left: \n                    q.append(node.left)\n                    \n            # Calculate the average for the current level\n            answer.append(level_sum / level_nodes)\n\n        return answer\n\n\n\n\n5. Kth Largest Element in an Array\n📚 Problem Overview:\nThe problem is straightforward. The easiest way to solve this is by sorting the list in descending order and then selecting kth element in the list. But we’re told that we cannot use sorting.\n\nUsing Heaps:\n💡 The Solution:\n\nWe can maintain a min-heap of k elements.\nWhenever we find an element which is bigger than the minimum element in the heap, we need to insert that element in the heap. By doing this, at the end of the iteration, we will have the min-heap of k elements which are the k largest numbers in the array.\nAmong these k largest elements, kth largest element, is the smallest element (if you’re given a list of k elements and you want to find kth largest element, that’s the same as finding the minimum in the list). So at the end, we can pop the smallest element from the min-heap, and return it.\n\n\n💻 Code Implementation:\nimport heapq\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -&gt; int:\n        heap = [ ]\n        i = 0\n        ### Initialize heap with the first `k` elements\n        while i &lt; k:\n            heapq.heappush(heap, nums[i])\n            i += 1\n        \n        # If you find greater element than the smallest, pop minimum from heap and insert nums[i].\n        for i in range(i, len(nums)):\n            if heap and heap[0] &lt; nums[i]:\n                heapq.heappop(heap)\n                heapq.heappush(heap, nums[i])\n\n        # minimum of top k largest number = kth largest in the list\n        return heapq.heappop(heap)"
  },
  {
    "objectID": "dsa/week4.html",
    "href": "dsa/week4.html",
    "title": "Leet Code Problems on Graphs",
    "section": "",
    "text": "1. Find the Town Judge\n🎯 Understanding the Test Cases:\nTest Case 1:\nn = 3, trust = [[1, 3], [2, 3]]\nExplanation:\nThere are 3 people in the town. Person 1 trusts Person 3, and Person 2 also trusts Person 3. Person 3 doesn’t trust anyone, and both other people trust Person 3. This means Person 3 meets the conditions of being the town judge: trusted by everyone but trusts nobody. Hence, he is the town judge.\nTest Case 2:\nn = 3, trust = [[1, 3], [2, 3], [3, 1]]\nExplanation:\nThere are 3 people in the town. Person 1 trusts Person 3, and Person 2 also trusts Person 3. Person 3 trusts Person 1, which means Person 3 is not trusted by everyone (because Person 1 and Person 2 trust Person 3, but Person 3 also trusts Person 1). The town judge must trust nobody and be trusted by everyone else. Since Person 3 doesn’t meet this condition (because they trust Person 1), there is no town judge. So we return -1.\n\n1.1 By Counting Indegrees\nHow Can We Think of Trust as a Graph?🤔\nWe have an array trusts, where each entry trust[i] = [a_i, b_i] tells us that a_i trusts b_i. What if we turned this into a graph?\n\nQuestion: If a_i trusts b_i, how could we represent this in a graph?\nIf a_i trusts b_i, then we can consider it an edge from a_i to b_i.\n\nFinding the Town Judge:\nThe town judge is a person who:\n\nTrusts no one \\(\\implies\\) Outdegree = 0\nIs trusted by everyone except himself \\(\\implies\\) Indegree = n - 1\n\nTo solve this, we can use dictionaries:\n\nIndegree Dictionary : Tracks how many people trust each person.\nOutdegree Dictionary : Tracks how many people each person trusts.\n\n\nHow can we use these dictionaries to find the town judge?\nWe can check if someone has an outdegree of 0 and an indegree of n-1. Since the town judge is unique, whenever we find such person, we can return it.\n\nTime complexity: \\(O(|E| + n)\\), where \\(|E|\\) is the number of edges in the graph, and \\(n\\) is the number of nodes.\n\n💻 Code Implementation:\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -&gt; int:        \n        if n &lt;= 1:\n            return 1\n\n        indegrees = { }\n        outdegrees = { }\n\n        # trust = [a_i, b_i]\n        # a_i -&gt; b_i\n        for a, b in trust:\n            if a not in indegrees: indegrees[a] = 0\n            if b not in indegrees: indegrees[b] = 0\n            if a not in outdegrees: outdegrees[a] = 0\n            if b not in outdegrees: outdegrees[b] = 0\n\n            outdegrees[a] += 1\n            indegrees[b] += 1\n        \n        # If indegree == n - 1 and outdegree == 0, then we have found the town judge.\n        townjudge = -1\n        for person in indegrees:\n            if outdegrees[person] == 0:\n                if indegrees[person] &gt;= n - 1:\n                    townjudge = person \n                    break\n        return townjudge        \n\n\n\n\n2. Course Schedule-I\n🎯 Understanding the Test Cases:\nTest Case 1:\nnumCourses = 3, prerequisites = [[1,0], [2, 1]]\nExplanation:\nThere are a total of 3 courses to take. To take course \\(1\\) you should have finished course \\(0\\). To take the course \\(2\\), you need to finish course \\(1\\). If a student decides to pursue courses as follows: \\(0, 1, 2\\), then all courses can be completed. So we return True.\nTest Case 2:\nnumCourses = 2, prerequisites = [[1,0], [0, 1]]\nExplanation:\nThere are a total of \\(2\\) courses to take. To take course \\(1\\) you should have finished course \\(0\\). To take the course \\(0\\), you need to finish course \\(1\\). It is not possible for a student to complete both courses. So we return False. In essence, there is a cycle in the prerequisites.\n\n2.1 Topological Sorting\n🔍 Problem Understanding:\nWe have a list of prerequisites where each pair \\(prerequisites[i] = [a_i, b_i]\\) means that you need to complete \\(b_i\\) before taking \\(a_i\\). In simpler terms, \\(a_i\\) depends on \\(b_i\\). How can we convert this into a graph? And, the big question: how do we find a sequence of courses that respects all the dependencies? Which algorithm should we use?🤔\nWe can use topological sorting to get this sequence.\nIf \\(b_i\\) needs to be completed before \\(a_i\\), we add a directed edge from \\(b_i \\rightarrow a_i\\). Note the direction of the edge. For this problem, we are converting the prerequisites array into graph using adjacency matrix. Once we have converted this problem into a graph problem, we can use the topological sorting.\nQuestion: When would we say that we have successfully found the sequence of courses satisfying the dependencies?\nWhen we the sequence includes all the courses, and no course is left. If a course is left out, there’s likely a cycle or unresolved dependency.\n\n💻 Code Implementation:\nclass Solution:\n    def preprocessing(self, numCourses, prerequisites) -&gt; list[list[int]]:\n        adjacency_matrix = [ [0 for i in range(numCourses)] for i in range(numCourses) ]\n        for a, b in prerequisites:\n            adjacency_matrix[b][a] = 1\n        return adjacency_matrix\n\n    # Implementation of Topological sort for Adjacency matrix\n    def toposort(self, AMat):\n        #Initialization\n        (rows,cols) = len(AMat), len(AMat[0])\n        indegree = {}\n        toposortlist = []\n        \n        #Compute indegree for each vertex\n        for col in range(cols):\n            indegree[col] = 0\n            for row in range(rows):\n                if AMat[row][col] == 1:\n                    indegree[col] = indegree[col] + 1\n        \n        # Topological sort Computing process\n        for i in range(rows):\n            # Select the min level vertex for removing the graph which has indegree 0\n            zero_indegree = [k for k in range(cols) if indegree[k] == 0]\n            if not zero_indegree:return toposortlist #Handle the case where there are no more zero indegree vertices\n            \n            j = zero_indegree[0]\n            # Store the removed vertex j in toposortlist and reduce the indegree by one \n            toposortlist.append(j)\n            indegree[j] = indegree[j] - 1\n            \n            # Reduce the indegree of each adjacent of the removed vertex j by 1\n            for k in range(cols):\n                if AMat[j][k] == 1:\n                    indegree[k] = indegree[k] - 1\n                    \n        return(toposortlist)\n\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n        adjacency_matrix = self.preprocessing(numCourses, prerequisites)\n        toposortlist = self.toposort(adjacency_matrix)\n        if len(toposortlist) == numCourses: return True\n        return False\n\n\n\n2.2 Topological Sort: Better Implementation\nThe approach used is similar to the above approach. However, we are using better data structures to increase our performance. Instead of keeping an adjacency matrix, we are using doubly ended queues and adjacency lists.\nHere’s how:\n\nKeep a deque for vertices with zero degree queue such that the insert at end and delete from start operations are both constant time.\nKeep a dictionary of indegrees which counts the indegrees for each vertex\n\nTime Complexity: \\(O(|V| + |E|)\\)\n\n💻 Code Implementation:\nfrom collections import deque, Counter\n\nclass Solution:\n    def canFinish(self, numCourse, prerequisites):\n        AList = { i: [] for i in range(numCourse)}\n        indegree = Counter()\n        visited = { i:False for i in range(numCourse)}\n\n        for course, prereq in prerequisites:\n            AList[prereq].append(course)\n            indegree[course] += 1\n    \n        # Initialization\n        toposortlist = []\n        zerodegreeq = deque()\n        \n        # Find the vertex with indegree 0 and added into the queue\n        for u in range(numCourse):\n            if indegree[u] == 0:\n                zerodegreeq.append(u)\n        \n        # Topological sort Computing process\n        while (zerodegreeq):\n            # Remove one vertex from queue which have zero degree vertices\n            curr_vertex = zerodegreeq.popleft()       \n            # Store the removed vertex in toposortlist and reduce the indegree by one \n            toposortlist.append(curr_vertex)\n            indegree[curr_vertex] = indegree[curr_vertex]-1\n            \n            # Repeat for each adjacent of the removed vertex\n            for adj_vertex in AList[curr_vertex]:\n                # Reduce the indegree of each adjacent of the removed vertex by 1\n                indegree[adj_vertex] = indegree[adj_vertex] - 1\n                # If after reducing the degree of adjacent, it becomes zero then insert it into the queue\n                if indegree[adj_vertex] == 0:\n                    zerodegreeq.append(adj_vertex)                \n        \n        return len(toposortlist) == numCourse\n\n\n\n\n3. Course Schedule-II\nThis problem is an exact replica of the above problem, except that we have to return a sequence that satisfies the dependencies, instead of returning a boolean of whether or not we can create such a sequence.\nWe can use the same approaches discussed in the above question.\n\n\n4. Snakes and Ladders\n🎯 Understanding the Test Cases:\nPlease refer to the Problem Overview where we have discussed the first test case.\n\n4.1 Using BFS\n📚 Problem Overview:\nWe have a board with \\(n^2\\) cells, and from any cell, we can make up to 6 possible moves. Can we turn this into a graph? Yes! Here’s how:\n\nStart at cell 1.\nWe can roll a dice and move to next six cells. In the first test cases, the next possible moves are: 15, 3, 4, 5, 6, 7 (because cell 2 has a ladder to 15). If a cell has \\(-1\\) value, then it’s an empty cell. But if it has a different value, then it is either a snake or a ladder.\nEach possible move from a cell is an edge in our graph.\nOnce we have the graph, We need to find the least number of moves required to go from cell 1 to cell \\(n^2\\). This is a shortest path problem where there are no weights on the edges- we can use Breadth-First Search (BFS).\n\nPseudocode:\n\nWe first need to convert the board into a graph.\n\nFor every cell, check the next six cells.\n\nIf the cell has a ladder or a snake, then we need to find out where the ladder ends which is given in cell: board[row][col]\nIf the cell does not have a ladder or a snake, then board[row][col] will have the vaue \\(-1\\).\nAdd the edge as: [cell] to board[row][cell] or the next moves.\n\n\nOnce we have the graph, we can run BFS on this graph, which will return the shortest path.\n\n\n💻 Code Implementation:\nfrom collections import deque\n# Using BFS approch For Adjacency list, for path, maintaining the parent of each vertex\n# Using BFS approch maintaing the adjacent level number from source vertrex\ndef BFSListPathLevel(AList,v):\n    # Initialization\n    (level,parent) = ({},{})\n    for each_vertex in AList.keys():\n        level[each_vertex] = -1\n        parent[each_vertex] = -1\n    \n    # Create Queue object q\n    q = deque()\n    \n    # Assigning the level 0 for start_vertex and insert it into the queue\n    level[v] = 0\n    q.append(v)\n    \n    # Repeat the following until the queue is empty\n    while q:\n        # Remove the one vertex from queue\n        curr_vertex = q.popleft()\n        # Visit the each adjacent of curr_vertex(if level value is -1) and insert into the queue\n        for adj_vertex in AList[curr_vertex]:\n            if (level[adj_vertex] == -1):\n                # Assign the level value on each adjacent one more than the curr_vertex level\n                level[adj_vertex] = level[curr_vertex] + 1\n                # Assigne the curr_vertex as parent of adjacent vertex of curr_vertex\n                parent[adj_vertex] = curr_vertex\n                q.append(adj_vertex)\n                \n    return(level,parent)\n\n\nclass Solution:\n    def get_indices(self, cell, n):\n        \"\"\"A helper function to convert the Boustrophedon style sequence into a cell's row and column index\"\"\"\n        remainder = (n - 1) % 2\n        row = (n - 1) - ((cell - 1) // n)\n        if row % 2 == remainder:\n            col = (cell % n) - 1 if cell % n != 0 else n - 1\n        else:\n            col = (n) - (cell % n) if cell % n !=0 else 0\n        return row, col\n\n    def preprocessing(self, board:List[List[int]]) -&gt; list[list[int]]:\n        \"\"\"Converts the board into a graph\"\"\"\n        n = len(board)\n        AList = {i:set() for i in range(1, n*n + 1)}\n        for i in range(1, n*n + 1):\n            for j in range(i + 1, min(i + 7, n*n + 1)): \n                row, col = self.get_indices(j, n)\n                val = board[row][col]\n                if val == -1:\n                    AList[i].add(j)\n                else:\n                    if val == i:\n                        continue\n                    AList[i].add(val)\n        return AList            \n            \n    def snakesAndLadders(self, board: List[List[int]]) -&gt; int:\n        n = len(board)\n        AList = self.preprocessing(board)\n        level, parent = BFSListPathLevel(AList, 1)\n        return level[n*n] # The last cell holds shortest path from start to the last cell\n\n\n\n\n5. Sort Items By Groups Respecting Dependencies\n\n5.1 Using Topological Sort\n📚 Problem Overview:\nWe need to order a list of items so that all items in the same group are listed next to each other. Additionally, some items have dependencies, meaning one item must be completed before another. We can use topological sort to solve this problem.\n🤔 The Issue:\nIf we just run topological sort on the beforeItems array, it might work for some test cases. But can you think of the test cases where this approach will fail?\nImagine this situation:\nGroup 0: Items [1, 2]\nGroup 1: Items [3, 4]\nHere’s the setup:\nItem 1 has no dependencies (indegree[1] = 0)\nItem 3 also has no dependencies (indegree[3] = 0)\nItem 2 and Item 4 each have one dependency (indegree[2] = 1 and indegree[4] = 1)\n\nNow, assume:\nItem 2 must come before Item 4\nItem 1 must come before Item 2\nThis means the correct order should be: 1 → 2 → 4.\n\nThe problem arises when choosing between Item 1 and Item 3, as both have no dependencies. If we choose Item 3 first, we should list the other items from Group 1 next to it, leading to an order like this: 3, 4. This leaves us with Group 0 and the sequence 1, 2. The final order would be 3, 4, 1, 2, which breaks the dependency 1 → 2 → 4. (Draw these nodes and edges to get a clearer picture!)\n💡 The Solution:\nTo solve this, we need to track the dependencies of both individual items and groups. Here’s how we can do that:\n\nCreate Two Graphs:\n\nItem Graph: Use the beforeItems array to build a graph showing how items depend on each other.\nGroup Graph: Also use the beforeItems array to build a graph showing how groups depend on each other.\nWe can use either the adjacency list or the adjacency matrix representation. Here, we are using the adjacency list representation.\n\nRun Nested Topological Sort:\n\nOuter graph to perform topological sorting on the group graph.\nThen, within each group, sort the items using topological sorting.\n\n\n\n💻 Code Implementation:\nfrom collections import deque\n\nclass Solution:\n    def get_group_wise_elements(self, group, m):\n        \"\"\"Helper function to quickly access all items belonging to a group\"\"\"\n        group_wise_elements = { i:[] for i in range(m) }\n        for i in range(len(group)):\n            grp = group[i] if group[i] &gt;= 0 else -i-1\n            if grp not in group_wise_elements:\n                group_wise_elements[grp] = []\n            group_wise_elements[grp].append(i)\n        return group_wise_elements\n\n    def preprocessing(self, beforeItems, group, m, n, groupwise_items):\n        \"\"\"\n        Given the beforeItems array, this function converts it into two graphs- Groups and Items. \n        Along with it, we are also returning the indegrees of each of the graphs' nodes so that we \n        can smoothly run topological sort. \n        \"\"\"\n        group_indegree, items_indegree = {}, {i:0 for i in range(n)}\n        items_alist =  {i:[] for i in range(n)}\n        group_alist = {}\n\n        for key in groupwise_items:\n            group_alist[key] = set()\n            group_indegree[key] = 0\n \n        for i in range(len(beforeItems)):\n            before = beforeItems[i]\n            for num in before:\n                if num not in items_alist:\n                    items_alist[num] = [ ]\n                items_alist[num].append(i)\n                items_indegree[i] += 1\n\n                grp_num = group[num] if group[num] &gt;= 0 else -num-1\n                grp_i = group[i] if group[i] &gt;= 0 else -i-1  \n                if grp_num != grp_i:\n                    if grp_num not in group_alist:\n                        group_alist[grp_num] = set()\n                    group_alist[grp_num].add(grp_i)\n        \n        for key in group_alist.keys():\n            group_alist[key] = list(group_alist[key])\n\n        for start_node in group_alist.keys():\n            for end_node in group_alist[u]:\n                if end_node not in group_indegree:\n                    group_indegree[end_node] = 0\n                group_indegree[end_node] += 1\n\n        return items_alist, group_alist, items_indegree, group_indegree\n\n    \n    def lpath(self, items_alist, group_alist, items_indegree, group_indegree, groupwise_items, n, group):\n        \"\"\"The actual nested topological sorting algorithm\"\"\"\n        output = [ ]\n\n        grp_queue = deque()\n        items_queue = deque()\n\n        for grp in group_indegree:\n            if group_indegree[grp] == 0:\n                grp_queue.append(grp)\n\n        # Outer topological sort is for groups\n        while grp_queue:\n            curr_grp = grp_queue.popleft()\n            group_indegree[curr_grp] -= 1\n            for adj_grp in group_alist[curr_grp]:\n                # Reduce the indegree of each adjacent group of the removed vertex by 1\n                group_indegree[adj_grp] -= 1\n\n                # Add new zero degree groups to the group deque\n                if group_indegree[adj_grp] == 0 :\n                    grp_queue.append(adj_grp)\n\n            # For popped group, find out zero degree items\n            for i in groupwise_items[curr_grp]:\n                if items_indegree[i] == 0 :\n                    items_queue.append(i)\n\n            # Topological sort is for the items\n            while items_queue:\n\n                # Remove one vertex from items queue which have zero degree items and reduce the indegree\n                curr_vertex = items_queue.popleft()\n                output.append(curr_vertex)\n                items_indegree[curr_vertex] = items_indegree[curr_vertex] - 1\n                \n                # Repeat for each adjacent of the removed item \n                for adj_vertex in items_alist[curr_vertex]:\n                    # Reduce the indegree of each adjacent of the removed item by 1\n                    items_indegree[adj_vertex] = items_indegree[adj_vertex] - 1\n\n                    # Add items to items deque if their indegree becomes zero\n                    if items_indegree[adj_vertex] == 0 and group[adj_vertex] == curr_grp:\n                        items_queue.append(adj_vertex)\n\n        if len(output) != n: return []\n        return output\n\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -&gt; List[int]:\n        group_wise_items = self.get_group_wise_elements(group, m)\n\n        items_alist, group_alist, items_indegree, group_indegree = self.preprocessing(beforeItems,group, m, n, group_wise_items)\n        \n        return self.lpath(items_alist, group_alist, items_indegree, group_indegree, group_wise_items, n, group)\n\n\n\n\n6. Find If Path Exists\n\n6.1 Using BFS\n🎯 Understanding the Test Cases:\nWe have not discussed test cases as it is an easy problem.\n📚 Problem Overview:\nWe need to figure out if we can go from a source node to a destination node. This is a reachability problem in a graph. We know we can use BFS or DFS on an adjacency list or a matrix for reachability problem.\nCan you convert the given edges list into an adjacency list or an adjacency matrix representation? - We have a list of edges where each edges[i] = [u, v] shows an edge between nodes u and v. - To create an adjacency list, we can do:\nfor u, v in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n💻 Code Implementation:\nNote: For a better, more neat code, we have used the deque data structure from the collections module in Python. We can use it to implement a queue used in BFS. It’s a useful data structure to know.\nfrom collections import deque\n\nclass Solution:\n    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -&gt; bool:\n        adj_list = { i:[ ] for i in range(n) }\n        visited = set()\n\n        # Create the adjacency list representation from Graph\n        for u, v in edges:\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n\n        queue = deque([source])\n        visited.add(source)\n        while queue:\n            vertex = queue.popleft()\n            if vertex == destination:\n                return True\n            for neighbor in adj_list[vertex]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n                    visited.add(neighbor)\n        return False\n\n\n\n\n7. Number of Provinces\n🎯 Understanding the Test Cases:\nWe have not discussed test cases as it is an easy problem.\n📚 Problem Overview:\nWe are given a matrix isConnected where each entry [i][j] tells us if there is a connection (edge) between nodes i and j. We can think of this as an adjacency matrix for a graph.\nA province is a group of nodes that are all connected. The task is to count how many such provinces exist.\n🤔 Can you think of a similar problem that we saw in the lectures?\nThis is a connected components problem. We need to find how many separate groups of connected nodes exist in the graph.\n💡 The Solution:\nTo solve this, we can use either BFS or DFS. For this explanation, we’ll go with BFS to explore each connected component one by one.\n\n💻 Code Implementation:\nfrom collections import deque\n\nclass Solution:\n    def get_neighbors(self, AMat, vertex):\n        \"\"\"Helper function to find out all neighbors of a node given the adjacency matrix.\"\"\"\n        neighbors = []\n        for i in range(len(AMat)):\n            if AMat[vertex][i] == 1:\n                neighbors.append(i)\n        return neighbors\n\n    def BFS(self, AMat, source):\n        \"\"\"\n        Runs BFS from a given source vertex and returns the set of vertices visited in that run of BFS.\n        That is, each run of the BFS will give us one province, or one connected component.\n        \"\"\"\n        visited = set()\n        queue = deque([source])  # Initialize the queue with the source vertex\n        visited.add(source)\n        while queue:\n            vertex = queue.popleft()\n            neighbors = self.get_neighbors(AMat, vertex)  # Pass both AMat and vertex\n            for neighbor in neighbors:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n                    visited.add(neighbor)\n        return visited\n\n    def findCircleNum(self, isConnected):\n\n        # Initially, every vertex gets an invalid component number\n        components = {i: -1 for i in range(len(isConnected))}\n\n        # Keep track of the component number and the number of vertices already visited across BFS runs\n        component_number = 0\n        seen = 0\n        \n        while seen &lt; len(isConnected):\n            startvertex = min([i for i in range(len(isConnected)) if components[i] == -1])\n            visited = self.BFS(isConnected, startvertex)\n\n            # For every vertex that was visited in the current run of BFS, update its component number and update \n            # the number of vertices seen.\n            for vertex in visited:\n                components[vertex] = component_number\n                seen += 1\n\n            # Increment component number such that for the next run of BFS, \n            # a different component number will be assigned\n            component_number += 1\n            \n        return component_number"
  },
  {
    "objectID": "dsa/week2.html",
    "href": "dsa/week2.html",
    "title": "Leet Code Problems on Sorting and Searching",
    "section": "",
    "text": "1. Longest Subsequence With Limited Sum\n🎯 Understanding the Test Cases:\nTest Case 1:\nnums = [4, 5, 2, 1], queries = [3, 10, 21]\nExplanation:\nFor queries[0] = 3: The longest subsequence we can take from nums is [2, 1] because \\(2 + 1 = 3\\), which has 2 elements. So, the answer is 2. If we add any other element, the sum becomes greater than 3. Note that in a subsequence, you can drop certain elements but the relative order stays same.\nFor queries[1] = 10: We can take [4, 2, 1], with a sum of \\(7\\), which has 3 elements. So, the answer is 3.\nFor queries[2] = 21: We can take the whole array [4, 5, 2, 1], with a sum of 12, which has 4 elements. So, the answer is 4.\n\n1.1: Brute Force\n\nTo find out the maximum number of elements less than or equal to some number, just add the smallest numbers.\nSort the list first.\nFor every query in queries, find out how many elements can be added by iterating over the array nums.\nComplexity: \\(O(m \\cdot n)\\)\n\n\n💻 Code Implementation:\nclass Solution(object):\n    def answerQueries(self, nums: List[int], queries: List[int]) -&gt; List[int]:\n        answer = [ 0 for i in range(len(queries))]\n        nums.sort() # Sort so that adding smallest elements is easier\n\n        for i in range(len(queries)):\n            query = queries[i]\n            index, count, total = 0, 0, 0\n            \n            # For every query, keep adding the smallest element to get the maximum number of \n            # elements whose total is less than or equal to that query\n            while total &lt;= query and index &lt; len(nums):\n                if total + nums[index] &gt; query:\n                    answer[i] = count\n                    break\n                else:\n                    total += nums[index]\n                    index += 1\n                    count += 1\n            answer[i] = count\n        return answer\n\n\n\n1.2 Prefix Sum\n\nSort the list first.\nKeep a prefix_sum array that has this interpretation: ith index stores the sum of first i smallest elements. Note that this array will be sorted.\nFor each queries[i], use binary search on prefix_sum to find out the largest element less than equal to queries[i]\nComplexity: \\(O(n \\cdot \\log(n))\\)\n\n\n💻 Code Implementation:\nclass Solution:\n    def answerQueries(self, nums: List[int], queries: List[int]) -&gt; List[int]:\n        answer = [0 for i in range(len(queries))] # O(n)\n        nums.sort() # O(nlogn)\n        prefix_sum = [ ] \n\n        # O(n)\n        for i in range(len(nums)):\n            prefix_sum.append(nums[0]) if i == 0 else prefix_sum.append(prefix_sum[i - 1] + nums[i])\n\n        # O (m log n)\n        for i in range(len(queries)): # O(m)\n            query = queries[i]\n            count = self.binarysearch(query, prefix_sum) #O(log n)\n            answer[i] = count\n        return answer\n\n\n    def binarysearch( self,v, L):  #v = target element\n        low, high = 0, len(L) - 1\n        while low &lt;= high: \n            mid = (low + high) // 2\n            if L[mid ] &lt; v:\n                low = mid  + 1\n            elif L[mid ] &gt; v:\n                high = mid  - 1\n            else:\n                return mid + 1 # return the next index than where the element was found\n        return low # Returns index where the element should go if not found\n\n\n\n\n2. Top K Frequent Elements\n🎯 Understanding the Test Cases:\nTest Case 1:\nnums= [ 1, 1, 1, 2, 2, 3], k = 2\nExplanation:\nIn this test case, the number \\(1\\) occurs thrice, the number \\(2\\) occurs twice, and the number \\(3\\) occurs once. Since we have to return top \\(2\\) most frequent numbers, we return \\(1\\) and \\(2\\). Important to note here is that the question says nothing about whether the nums array is sorted or not. If it is not explicitly given in the question, we cannot assume it.\n\n2.1 Using Dictionaries and Sorting\n\nInitialize a dictionary. For every element in nums, you count occurrences of that element. We can do this in a single pass. Plus this has the added benefit of eliminating duplicates, which we will use later. A useful library class to explore here is: from collections import Counter\nFor every unique element from the nums array, create a new 2D array where each element is of the format: [element from nums, it's count]\nSort this array based on the counts in descending order.\nPick the first k elements.\nComplexity: \\(O(m \\cdot \\log(m))\\), where \\(m\\) is the number of unique elements in nums.\n\n\n💻 Code Implementation:\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:\n        counts = { } # init counts dictionary\n\n        # count the number of occurrences for each element\n        for num in nums: # O(n)\n            if num in counts:\n                counts[num] += 1 \n            else:\n                counts[num] = 1\n        \n        # [ [elem1, it's count], [elem2, it's count], [elem3, it's count] ]\n        L = [[x, counts[x]] for x in counts.keys()] # O(m), where m = number of unique elems in nums\n\n        # Sort in descending order based on counts\n        L.sort(key=lambda x:x[1], reverse=True) # NOT O(n log n), it's O(m log m)!\n\n        output = [ ]\n\n        # O(k)\n        # Pick out the top k elements. Note that we don't need counts. So we return L[i][0]\n        for i in range(k):\n            output.append(L[i][0])\n\n        return output\n\n\n\n\n3. Sort Colors\nThis problem is similar to what is discussed in one the practice programming assignments for this week, and we need to solve this problem in \\(O(n)\\) complexity.\n\n3.1 Sort the nums in place\nWe can simply sort the array nums in place are return it. We can use nums.sort() for this. But the comlpexity for this will be: \\(O(n \\cdot \\log (n))\\). Can we do better?\n\n\n3.2 Take Count of Colors\nWe know that there are only three distinct elements in the list. So can we count the occurrences for each distinct color element, and then replace the original array using these counts. For example, consider an array nums = [ 2, 0, 2, 1, 1, 0, 1]. We can keep a dictionary for counts as follows:\ncounts[0] = 2\ncounts[1] = 3\ncounts[2] = 2\nThen for every color, we can replace nums[i] to nums[i + count] with the color.\nTime Complexity: \\(O(n)\\)\n\n💻 Code Implementation:\nclass Solution:\n    def sortColors(self, nums: List[int]) -&gt; None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        counts = { \n            0 : 0, \n            1: 0, \n            2: 0\n        }\n\n        # O(n). Take counts for each color\n        for i in range(len(nums)):\n            counts[nums[i]] += 1\n\n        index = 0\n\n        # O(n). For each color, update the nums[i] to nums[i + count] to the color.\n        for i in range(3):\n            for count in range(counts[i]):\n                nums[index] = i\n                index += 1\n\n\n\n\n4. Merge Intervals\n🎯 Understanding the Test Cases:\nTest Case 1:\nintervals = [[1,3], [2,6], [8,10], [15,18]]\nExplanation:\nWe start with the first interval [1, 3]. The next interval [2, 6] overlaps with [1, 3], so we merge them into [1, 6]. The next interval [8, 10] doesn’t overlap with [1, 6], so we keep it as is. The last interval [15, 18] also doesn’t overlap with any previous intervals, so we keep it as is.\nTest Case 2:\nintervals = [[1, 4], [2, 3], [5, 10]]\nExplanation:\nWe start with the first interval [1, 4]. The next interval [2, 3] overlaps with [1, 4]. But note that the first interval subsumes this one. So the merged interval is: [1, 4]\nThe last interval [5, 10] doesn’t overlap with any previous intervals so we keep it as it is.\n\n4.1 Sorting intervals\n\nIf we want to merge intervals, it would be easier if overlapping intervals come adjacently in the input list, which means… Sorting!\nSort based on the start of the interval.\nFor every interval, check whether start of the interval falls within the end of the merged interval\nBut we will need to consider the below corner cases:\n\nOne interval subsumes another, then what? This means that the second interval’s end is smaller than the first. Such as: [1, 10] and [2, 5]\nHow do you handle last interval?\n\n\nWe also need to keep track of the start and the end of the merged intervals.\nTime Complexity: \\(O(n \\cdot \\log(n))\\)\n\n💻 Code Implementation:\nclass Solution:\n    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:\n        if not intervals:\n            return []\n        \n        # Sort intervals based on the start\n        intervals.sort(key=lambda x: x[0])\n        \n        merged_intervals = []\n        current_start, current_end = intervals[0]\n        \n        for interval in intervals[1:]:\n            # Overlapping intervals, merge them\n            if interval[0] &lt;= current_end:\n                current_end = max(current_end, interval[1]) # The max function is required to handle the 1st edge case\n            else:\n                # Non-overlapping interval found, add previous interval to result\n                merged_intervals.append([current_start, current_end])\n\n                # Update current interval\n                current_start, current_end = interval\n        \n        # Add the last interval\n        merged_intervals.append([current_start, current_end])\n        \n        return merged_intervals\n\n\n\n\n5. Search in Rotated Sorted Array\n🎯 Understanding the Test Cases:\nThis is a simple search problem, so the test cases are not discussed.\n\n5.1 Using Binary Search\n📚 Problem Overview:\nWe need to find the element in \\(\\log(n)\\) time. When you see \\(\\log(n)\\), what do you think of? Of course, Binary search! This question has been asked in PYQs, so better to understand it well.\n💡 The Solution:\n\nAt any mid index, there are two possibilities: either the left half of the array is sorted, or the right half is.\nIf the left side is sorted:\n\nCheck if the target within this range?\n\nIf yes, do a binary search on the left half.\nIf no, explore the right half.\n\n\nIf the right side is sorted:\n\nAgain, check if the target is in this range.\n\nIf yes, perform binary search on the right half.\nIf no, explore to the left side.\n\n\n\n\n💻 Code Implementation:\nclass Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n\n        while left &lt;= right:\n            mid = (left + right) // 2\n            \n            # If the target is found\n            if nums[mid] == target:\n                return mid\n            \n            # Check if the left half is sorted\n            if nums[left] &lt;= nums[mid]:\n                # If the target lies within the sorted left half\n                if nums[left] &lt;= target &lt; nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            # Otherwise, the right half is sorted\n            else:\n                # If the target lies within the sorted right half\n                if nums[mid] &lt; target &lt;= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        \n        # If the target is not found\n        return -1\n\n\n\n\n6. Find First and Last Position of Element in Sorted Array\n🎯 Understanding the Test Cases:\nTest Case 1:\nnums = [5,7,7,8,8,8,10], target = 8\nExplanation:\nWe need to find the starting and ending indices of the target number 8. In this case, 8 appears three times, so we return the range [3, 5], where index 3 is the first occurrence and index 5 is the last.\n\n5.1 Using Binary Search\n📚 Problem Overview:\nAgain, we need a \\(\\log(n)\\) solution. So, we think Binary Search to come up with a solution.\n💡 The Solution:\nWe know binary search is fast, but it stops when we find the target. What if we keep going to find both the first and last occurrences?\nHere’s how we can do it:\nLeftmost Occurrence: - Run a binary search, but when you find 8, don’t stop! Keep searching the left half to find the first occurrence.\nRightmost Occurrence: - Similar idea, but now after finding 8, explore the right half to find the last occurrence.\nBy running two binary searches, we find both boundaries of the target range in \\(O(\\log n)\\) time.\n\n💻 Code Implementation:\nclass Solution:\n    def searchRange(self, nums, target):\n        def findLeft(nums, target):\n            leftmost_occurrence = -1\n            # Finds the left most index of target number\n            left, right = 0, len(nums) - 1\n            while left &lt;= right:\n                mid = (left + right) // 2\n                if nums[mid] &lt; target:\n                    left = mid + 1\n                elif nums[mid] == target:\n                    leftmost_occurrence = mid\n                    right = mid - 1\n                else:\n                    right = mid - 1\n            return leftmost_occurrence\n        \n        def findRight(nums, target):\n            # Finds rightmost index of target\n            rightmost_occurrence = -1\n            left, right = 0, len(nums) - 1\n            while left &lt;= right:\n                mid = (left + right) // 2\n                if nums[mid] &lt; target:\n                    left = mid + 1\n                elif nums[mid] == target:\n                    rightmost_occurrence = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return rightmost_occurrence\n        \n        leftmost_occurrence = findLeft(nums, target)\n        rightmost_occurrence = findRight(nums, target)\n        \n        # Check if the target is not found\n        if leftmost_occurrence == -1:\n            return [-1, -1]\n        return [leftmost_occurrence, rightmost_occurrence]"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Vikrant",
    "section": "",
    "text": "Hi, I’m Vikrant👋. I’m a final-year student at IIT Madras, pursuing a B.S. in Data Science and Applications. I currently work as a Teaching Assistant for the Data Structures and Algorithms (PDSA) course and as a Software Engineering intern at VuNet Systems in Bangalore.\nOutside of academics, I love sports, theatre, and finance. I play chess, tennis, and cricket. I’m an avid reader, and I write about what I read, projects I’m building, or my learning journey.\n\n\nEducation\nIndian Institute of Technology, Madras\nB.S. in Data Science | Sept 2021 - Sept 2025\nH.P.T. Arts College, Nashik\nB.A. in Psychology | June 2018 - June 2021\n\n\n\nExperience\nVuNet Systems, Bangalore\nSoftware Engineering Intern | Oct 2024 - Present\nIIT Madras, Chennai\nTeaching Assistant | June 2024 - Present"
  },
  {
    "objectID": "dsa/week10.html",
    "href": "dsa/week10.html",
    "title": "Leet Code Problems on String Matching and Tries",
    "section": "",
    "text": "1. Implement a Trie\n📚 Problem Overview:\nWe need to implement the Trie data structure. You can read more about it here.\n💡 The Solution:\n\nFor each node in the Trie, we need to keep track of its children and whether the node is the end of a word. At maximum, each node can have 26 children- one for each letter in the alphabet. We can use a dictionary to represent children (we could also use lists, but not every node is going to have 26 children, which makes it inefficient and complicated when searching ).\nThen we implement the operations, which are similar to Tree operations.\n\n\n💻 Code Implementation:\n\n# Define a helper class for each node in the Trie\nclass TrieNode:\n    def __init__(self):\n        self.children = { }\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word:str) -&gt; None:\n        curr = self.root\n        \n        # Insert each character at new level if it doesn't exist\n        for char in word:\n            if char not in curr.children:\n                curr.children[char] = TrieNode()\n            curr = curr.children[char]\n        curr.is_end_of_word = True\n    \n    def search(self, word:str) -&gt; bool:\n        curr = self.root\n        \n        # As long as you find characters, keep traversing.\n        for char in word:\n            if char not in curr.children:\n                return False\n            curr = curr.children[char]\n        \n        # You may find a character sequence which is not a word- but a prefix. Check for it. \n        if curr.is_end_of_word: return True\n        return False\n\n    def startsWith(self, word:str) -&gt; bool:\n        # Same as above, except no prefix check. Even if you find prefix, return True\n        curr = self.root\n        for char in word:\n            if char not in curr.children:\n                return False\n            curr = curr.children[char]\n        return True"
  },
  {
    "objectID": "dsa/week3.html",
    "href": "dsa/week3.html",
    "title": "Leet Code Problems on Stacks, Queues, Linked Lists, and Arrays",
    "section": "",
    "text": "🎯 Understanding the Test Cases:\nTest Case 1:\nInput: s = \"[()]\"\nExplanation: The string \"([])\" is valid because each open bracket has a matching closing bracket, and they close in the correct order. Since all brackets are properly paired, the string evaluates to True.\nTest Case 2:\nExplanation: The string \"(]\" is invalid because the open bracket ( is not closed by the correct type of bracket. The closing bracket ] doesn’t match the opening (, so the string evaluates to False.\n🔍 Problem Understanding:\nWe only have three types of brackets: [], (), {}. And we need to close the last opened bracaket first. What do you do when you need to close the last opened bracket first? You need a system where the last thing you add is the first thing you take out, right? This is the Last In, First Out (LIFO) system. So, what data structure works best for LIFO? A stack! A stack can help us keep track of the brackets. Whenever we find an opening bracket, we push it onto the stack. When we encounter a closing bracket, we pop the stack to see if it matches the last opened bracket.\n🤔 Think about this:\nLet’s say you’ve read the first two characters of a string and added them to the stack. Your stack might look like this: stack = ['(', '{']. Now, what if the next character is }? How do you know if this closing bracket matches the last opened one? To figure this out, we can use a simple mapping: each closing bracket corresponds to its opening bracket, like this: closing bracket : Corresponding opening bracket. This way, we can check if every closing bracket matches the correct opening one.\n⚠️ Edge Cases:\nWhat happens if you have opening brackets left in the stack, but the string ends? Or what if there are closing brackets, but the stack is empty? How would you handle these situations?\nTime Complexity: \\(O(n)\\)\nSpace Complexity: \\(O(n)\\)\n\n\nclass Solution:\n    def isValid(self, s: str) -&gt; bool:\n        # Keep the mapping as 'closing bracket' : 'Correspoding opening bracket'\n        mapping = { \n            ')' : '(', \n            ']' : '[', \n            '}' : '{'\n        }\n\n        stack = [ ]\n\n        # O(n)\n        for char in s:\n            if char not in mapping: # This means that the bracket is an open bracket\n                stack.append(char)  # Simply add the open bracket to the stack     \n            else:\n                # Corner case- stack has no elements but the string has closing bracket\n                if len(stack) == 0:\n                    return False\n\n                # Check if opening bracket in the stack matches with the closing bracket in the string\n                if mapping[char] != stack.pop():\n                    return False\n\n        # if stack is empty after checking every char of string\n        # that means that we found the closing bracket for every opening bracket. Thus, return True\n        # And vice versa. Return False\n\n        return not stack # Returns True if stack is empty, False otherwise"
  },
  {
    "objectID": "dsa/week3.html#leet-code-problems-on-linked-lists-and-arrays",
    "href": "dsa/week3.html#leet-code-problems-on-linked-lists-and-arrays",
    "title": "Leet Code Problems on Stacks, Queues, Linked Lists, and Arrays",
    "section": "Leet Code Problems on Linked Lists and Arrays",
    "text": "Leet Code Problems on Linked Lists and Arrays\nBefore you jump into these problems: 1. When solving Linked List problems, ALWAYS draw the diagrams. 2. Whenever you see a Linked List problem, the first thing that you should do is: handle the base / edge cases like an empty linked list or a list with just one node. It’ll save you a lot of time and stress, especially during the OPPE!\n\n3. Rotate List\n\n3.1 Rotation Logic:\n\nIf \\(k \\gt n\\), then the number of effective rotations is: \\(k = k \\mod n\\).\nThink about this as a three step problem:\n\nFirst, traverse \\(k\\) nodes. This n - kth node becomes the newhead of the rotated list.\nNext, connect the original list’s tail to its headto create a cycle in the linked list.\nFinally, walk from the newhead for n nodes to find the newtail, which will become the tail of the rotated list by marking its next pointer as None.\n\n\n\n💻 Code Implementation:\nclass Solution:\n    # Gets the length of node: 'n'\n    def get_length(self, head):\n        current = head\n        count = 0\n        while current:\n            current = current.next\n            count += 1        \n        return count\n\n    def rotateRight(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:\n        n = self.get_length(head)\n        \n        # Corner case\n        if n &lt;= 1:\n            return head\n\n        k = k % n # Number of effective rotations\n\n        # In the original list, you need to walk these many steps to get to new head\n        walk_these_many_steps = n - k \n\n        if k == 0 or walk_these_many_steps == 0:\n            return head\n\n        # Get the new head of the list that you will get after you rotate\n        current = head\n        count = 0\n        newhead = None\n        while current:\n            if count == walk_these_many_steps:\n                newhead = current\n                break\n\n            current = current.next\n            count += 1\n\n        # Get to the end of the list so that you can link tail with the head. \n        # But now your linked list is a cycle\n        current = head\n        count = 0\n        while current:\n            if not current.next:\n                current.next = head\n                break\n            current = current.next\n\n        # Now you need to make the new tail point to None to break the cycle\n        current = newhead\n        count = 0\n        while current and count &lt; n:\n            current = current.next\n            count += 1\n            if count == n - 1:\n                current.next = None\n\n        return newhead\n\n\n\n\n4. Swap Nodes in Pairs\n\n4.1 Intuition\nLet’s break this problem down step by step with the help of an image. Imagine we have a linked list, and we want to swap every two nodes. To make this easier, we’ll look at an illustration. We’re going to use some colors and a little helper node.\n\nWe make a dummy node at the front of the list. This dummy points to the head and we’ll call it prev for “previous”. It’ll help us easily swap the first two nodes.\nIn each step, we’ll change certain links between nodes. These important links will be marked in pink.\nTo swap the nodes, we use pointers, shown in blue. These pointers help us know which nodes we’re swapping and how to connect them.\nNext to the diagram of each step, we’ll show simple code steps for changing the links.\n\n\n\n\nSwap Nodes\n\n\nNow let’s code this!\n\n💻 Code Implementation:\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n         # Create a Dummy node that becomes \"prev\"\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy \n\n        # Since we are going to update using prev.next and prev.next.next\n        # they both should exist\n\n        while prev.next and prev.next.next:\n            # Find the \"curr\" and \"nxt\" nodes\n            curr = prev.next\n            nxt = prev.next.next\n            \n            # Pink links for swap\n            prev.next = nxt\n            curr.next = nxt.next\n            nxt.next = curr\n            \n            # Move the \"prev\" pointer to the next pair\n            prev = curr\n        \n        # The new head of the list is next to the dummy node\n        return dummy.next\n\n\n\n\n5. Reverse Nodes in K Groups\n\n5.1 Using Recursion\n\nYou know how to reverse a linked list from the Graded Assignment question. Given a number k, can you reverse the first k nodes and return the head and tail after reversing?\nNow that we have successfully reversed the first k nodes, can you repeat the same thing for the next k nodes? So we have a way of reversing groups of k nodes.\nBut here’s the important part: how do you connect these reversed groups?\n\n🤔 Can you think of a recursive way? - Remember that the last reversed k nodes will be the first to return! - Let’s take an example list: 1 -&gt; 2 -&gt; 3 -&gt; 4, and k = 2. - First, reverse 1 -&gt; 2 as 2 -&gt; 1, and return the head as 2 and tail as 1. - Then, reverse 3 -&gt; 4 recursively as 4 -&gt; 3, and return the head as 4 and tail as 3. - Now, Now, you just need to connect the tail of the first reversed group (1) to the head of the second reversed group (4). Voilà! You’ve connected the reversed groups.\n\n💻 Code Implementation:\nclass Solution:\n    # Helper function: returns the number of nodes in the linked list\n    def get_length(self, head):\n        count = 0\n        current = head\n        while current:\n            current = current.next\n            count += 1\n        return count\n\n    def reverse(self, head, k, n):\n        # Edge Case: The group is empty\n        if not head:\n            return head, None\n\n        # Edge case: If k &gt; n, then remaining nodes should remain as they are\n        if k &gt; n:\n            return head, None\n\n        # Reverse the K nodes in groups starting from \"head\"\n        current = head\n        prev = None\n        next_node = None\n        count = 0\n        while current and count &lt;= k:\n            # Counting because we want to mark the tail also\n            if count &lt; k:\n                next_node = current.next\n                current.next = prev       \n                prev = current            \n                current = next_node       \n\n            count += 1\n        \n        curr_head = prev # The head of the reversed k nodes\n        curr_tail = head # tail of the reversed k nodes\n\n        # Recursively call reverse on the next k nodes. Observe that the number of nodes in remaining list is: n - k\n        next_head, next_tail = self.reverse(next_node, k, n - k)\n        \n        # Connect the current group's tail with the head of the next group\n        curr_tail.next = next_head \n\n        return curr_head, curr_tail\n\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:\n        n = self.get_length(head)\n        head, tail = self.reverse(head, k, n)\n        return head\n\n\n\n\n6. Middle of The Linked List\n\n6.1 Using Iteration\nLet’s think about how we can find the middle element in a linked list, similar to how we do it in an array. We usually find the middle index by calculating mid = len(L) // 2 and then return L[mid]. This works because arrays let us access any element directly by its index.\nBut in a linked list, we don’t have direct access to an element by index. So, how could we find the middle element?\nHere’s how: 1. First, we need to compute len(L). How can we do this? We could iterate through the entire list, counting each node as we go. 2. Once we know the length, we can compute the middle index just like we did with the array: mid = len(L) // 2 3. Finally, we would traverse the list again, stopping when we reach the middle node.\n\nTime Complexity: \\(O(n)\\)\n\n\n💻 Code Implementation:\nclass Solution:\n    def get_length(self, head):\n        \"\"\"\n        Helper function- iterates over the entire linked list and returns the length of the list\n        \"\"\"\n        counter = 0\n        while head:\n            counter += 1\n            head = head.next\n        return counter\n\n\n    def middleNode(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        # Handle the base case\n        if not head:\n            return \n\n        # Compute the middle index \n        n = self.get_length(head)\n        mid = n // 2\n\n        # Iterate mid number of steps\n        idx = 0\n        while idx &lt; mid: \n            head = head.next # note that we are updating the head. So after \"mid\" iterations, head = middle node\n            idx += 1\n        \n        # Since head = mid after iterating, we return head\n        return head\n\n\n\n\n7. Delete the Middle Node\n\n7.1 Using Iteration\nWe’ve already discussed how to find the middle node in a linked list. So, if we know how to reach the middle node, can we figure out how to delete it? 🤔\nTo delete a node in a linked list, here’s what we need to do:\n\nStop at the node before the one we want to delete.\nRedirect the pointer: Change the next pointer of the current node to skip the node we want to delete and point to the node after it. Essentially, current.next = current.next.next.\n\n⚠️ Edge Cases: What if the linked list has only one node? In this scenario, we need to handle cases where current.next.next doesn’t exist.\n\nTime Complexity: \\(O(n)\\)\n\n\n💻 Code Implementation:\nclass Solution:\n    def get_length(self, head):\n        \"\"\"\n        Helper function- iterates over the entire linked list and returns the length of the list\n        \"\"\"\n        counter = 0\n        while head:\n            counter += 1\n            head = head.next\n        return counter\n\n    def deleteMiddle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        mid = self.get_length(head) // 2\n        \n        current = head # Iterate using current because we want to return the head\n\n        idx = 0\n        # Stopping one node before the middle node\n        while idx &lt; mid - 1:\n            current = current.next\n            idx += 1\n        \n        # Change links of the node before to the next to next node by handling corner case\n        if current.next and current.next.next:\n            current.next = current.next.next\n        else:\n            current.next = None\n        return head\n\n\n\n\n8. Delete nth Node From End\n\n8.1 Using Iteration\nWe now know how to delete the middle node. Can you try to solve this problem using the ideas from that question?\nHere’s a hint: Deleting the nth node from the end is the same as deleting (length - n)th node from the front.\n\n\n\n9. Merge Two Sorted Lists\nRemember Merge Sort algorithm? Can you see how this question is similar to the merge(A, B) operation from the merge sort algorithm? Only instead of merging arrays, we’re merging linked lists! 🔗\n\n💻 Code Implementation:\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:\n\n        # Dummy node to serve as a proxy for head of the list to return      \n        dummy = ListNode()\n        current = dummy\n\n        # Iterate as long as neither list is exhausted\n        while list1 and list2:\n            if list1.val &lt; list2.val:\n                current.next = list1\n                list1 = list1.next\n            else:\n                current.next = list2\n                list2 = list2.next\n            current = current.next\n\n        # Attach the remaining nodes of list1 or list2\n        if list1:\n            current.next = list1\n        elif list2:\n            current.next = list2\n\n        # The merged list is next to the dummy node\n        return dummy.next"
  },
  {
    "objectID": "dsa/week5.html",
    "href": "dsa/week5.html",
    "title": "Leet Code Problems on Shortest Paths and Minimum Cost Spanning Trees",
    "section": "",
    "text": "1. Min Cost To Connect All Points\n🎯 Understanding the Test Cases:\nTest Case 1:\npoints = [[0,0],[2,2],[3,10],[5,2],[7,0]]\nThe first test case from the problem statement.\nExplanation:\nThere are many ways to connect all points. For example: - Path: [0,0] -&gt; [7,0] -&gt; [3,10] -&gt; [2,2] -&gt; [5,2] - Total Manhattan Distance: \\(7 + 14 + 9 + 3 = 33\\) (not optimal)\nBut the optimal way connects them with a total distance of 20, as shown in the problem description.\nKey idea: From any point, you can connect to any other point, and the edge cost is the Manhattan distance. The goal is to minimize the total cost (sum of all edges).\n\n1.1 Minimum Cost Spanning Trees\n📚 Problem Overview:\nWe need to find the minimum cost to connect all points. This is a Minimum Cost Spanning Tree (MCST) problem!\n🛠️ How do we turn the points into a graph?\n\nEach point can be a node.\nThe edges are the Mahattan distances between every pair of points in the graph. That means it’s a complete graph—each node is connected to every other one.\n\nPseudocode for building this graph:\n\nRun a nested loop:\n\nFor each point\n\nFor every other point,\n\nCompute the distance and store the edge in an adjacency matrix or an adjacency list\n\n\n\n\n💡 The Solution:\n\nBuild the Graph\nFind the MCST:\n\nUse Prim’s or Kruskal’s algorithm to find the Minimum Cost Spanning Tree. 🌐\nThen, just sum up the edge weights of the Tree. That’s our minimum cost! 🏆\n\n\n\n💻 Code Implementation:\ndef kruskal(WList):\n    \"\"\"Kruskal's as per the PDSA book\"\"\"\n    (edges,component,TE) = ([],{},[])\n    for u in WList.keys():\n        edges.extend([(d,u,v) for (v,d) in WList[u]])\n        component[u] = u\n\n    edges.sort()\n\n    for (d,u,v) in edges:\n        if component[u] != component[v]:\n            TE.append((u,v, d))\n            c = component[u]\n            for w in WList.keys():\n                if component[w] == c:\n                    component[w] = component[v]\n    return TE\n\ndef compute_min_cost(TE) -&gt; int:\n    # Compute the Minimum Cost based on Tree Edges\n    min_cost = 0\n    for u, v, d in TE:\n        min_cost += d\n    return(min_cost)\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -&gt; int:\n        # Init Adjacency Matrix\n        AList = { i : [] for i in range(len(points))}\n\n        # Each point can be connected to every other point and their manhattan distance can be computed.\n        for i in range(len(points)):\n            x1, y1 = points[i][0], points[i][1]\n\n            for j in range(i + 1, len(points)):\n                x2, y2 = points[j][0], points[j][1]\n                dist = abs(x1 - x2) + abs(y1 - y2)\n\n                # Distance from point i to j is same as from j to i. So init both entries\n                AList[i].append((j, dist))\n                AList[j].append((i, dist))\n\n        tree_edges = kruskal(AList)\n        minimum_cost = compute_min_cost(tree_edges)\n        return minimum_cost\n\n\n\n\n2. Path with Maximum Probability\n\n2.1 Using Dijkstra\n📚 Problem Overview:\nWe need to find the maximum probability of getting from a start_node to an end_node in a graph. Each edge in the graph has a success probability, and we want to maximize the total probability along the path. For example, if there’s a path A -&gt; B -&gt; C with probabilities A -&gt; B = 0.5 and B -&gt; C = 0.5, the total probability for the path A -&gt; C is \\(0.5 \\times 0.5 = 0.25\\).\n💡 The Solution:\nIt’s similar to finding the shortest path, but here we are finding the path with the highest probability!\n\nWe create an adjacency list where each node is connected to its neighbors with the probability of success for each edge.\nMax-Heap: To keep track of the most promising path, we can use a max-heap. But since Python’s heapq is a min-heap, we store negative probabilities (because minimizing negatives is same as maximizing positives).\nWe can run Dijkstra’s algorithm, but instead of minimizing distance, we maximize probability. We stop as soon as we reach the end_node.\n\nIf we never reach the end node, we return 0.0 because there’s no valid path!\n\n💻 Code Implementation:\nclass Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start_node: int, end_node: int) -&gt; float:\n        # Create an adjacency list\n        WList = defaultdict(list)\n        for i, (start, end) in enumerate(edges):\n            probab = succProb[i]\n            WList[start].append((end, probab))\n            WList[end].append((start, probab))\n\n        # Max-heap (negative probabilities to simulate a max-heap)\n        heap = [(-1.0, start_node)]  # (negative probability, node)\n        dist = [-1.0] * n            # Store the maximum probability to reach each node\n        dist[start_node] = 1.0        # Start node has a probability of 1\n\n        while heap:\n            # Pop the node with the maximum probability\n            current_prob, node = heapq.heappop(heap)\n            current_prob = -current_prob  # Convert back to positive\n\n            # If we reached the end node, return the probability\n            if node == end_node:\n                return current_prob\n\n            # Explore neighbors\n            for neighbor, weight in WList[node]:\n                new_prob = current_prob * weight\n                # Only update if we found a higher probability path to neighbor\n                if new_prob &gt; dist[neighbor]:\n                    dist[neighbor] = new_prob\n                    heapq.heappush(heap, (-new_prob, neighbor))\n\n        # If we never reach the end node\n        return 0.0\n\n\n\n\n3. Cheapest Flight Within K Stops\n\n3.1 Using Dijkstra\n\n💻 Code Implementation:\nclass Solution:\n    def findCheapestPrice(self, n, flights, src, dst, k):\n        # Create the adjacency list\n        adj_list = {i: [] for i in range(n)}\n        for flight in flights:\n            from_city, to_city, price = flight\n            adj_list[from_city].append((to_city, price))\n        \n        # Priority queue -&gt; (current price, city, stops)\n        pq = [(0, src, 0)]  # (price, city, stops)\n        \n        ## BFS with Heap\n\n        # visited[city] stores min number of stops to reach the city\n        visited = {}\n        \n        while pq:\n            price, city, stops = heapq.heappop(pq)\n            \n            # If we reach the destination, return the price\n            if city == dst:\n                return price\n            \n            # If we have visited this city with fewer stops before, skip\n            if city in visited and visited[city] &lt; stops:\n                continue\n            \n            # Store the minimum number of stops to this city\n            visited[city] = stops\n            \n            # If we have more stops than k, continue to the next city\n            if stops &gt; k:\n                continue\n            \n            # Add neighbors to explore\n            for neighbor, cost in adj_list[city]:\n                new_price = price + cost\n                heapq.heappush(pq, (new_price, neighbor, stops + 1))\n        \n        # If no valid route found\n        return -1"
  },
  {
    "objectID": "dsa/week7.html",
    "href": "dsa/week7.html",
    "title": "Leet Code Greedy Problems",
    "section": "",
    "text": "1. N Meetings in One Room\n\n1.1 Using Greedy Approach\n📚 Problem Overview:\nWe need to schedule the maximum number of meetings without any conflicts, given two arrays: start and end.\n🤔 Can you find out what type of problem this is?\n\nIt is a classic interval scheduling problem.\nFrom the lectures, we know we can solve such problems by sorting the schedules based on end times, and selecting the meetings that don’t conflict.\nHere’s how we can solve this: - Combine the start and end arrays into a single array of the form: \\([(start_i, end_i)]\\) - Sort the list based on the end times- earliest end times come first. - Track of the end time of the last meeting. - For each new meeting: - If it overlaps with the previous one (starts before the previous one ends), then skip it. - Else, we increment the meeting count, and update the end time.\n\n💻 Code Implementation:\nclass Solution:\n    def maximumMeetings(self,n,start,end):\n        # Combine two lists into one\n        times = [ [start[i], end[i]] for i in range(n)]\n        \n        # Sort based on end times\n        times.sort(key=lambda x:x[1])\n        \n        count = 0\n        prev_endtime = None\n        for start_time, end_time in times:\n            # First meeting\n            if not prev_endtime:\n                prev_endtime = end_time\n                count += 1\n            else:\n                # Check if the previous meet's endtime clashes with the start time of the current meet\n                if prev_endtime &lt; start_time:\n                    prev_endtime = end_time\n                    count += 1\n        return count    \n\n\n\n\n2. Activity Selection\n\n2.1 Greedy Approach\nSame approach as the above question.\n\n💻 Code Implementation:\nclass Solution:\n    def activitySelection(self,n,start,end):\n        # Rearrange the start and end arrays into a single array\n        arr = [ [start[i], end[i]] for i in range(n) ]\n\n        # Sort based on end times\n        arr.sort(key=lambda x:x[1])\n\n        count = 0\n        prev_endtime = None\n        for start_time, end_time in arr:\n            # First activity\n            if not prev_endtime:\n                prev_endtime = end_time\n                count += 1\n            else:\n                # Check if the previous activity's endtime clashes with the start time of the current activity\n                if prev_endtime &lt; start_time:\n                    count += 1\n                    prev_endtime = end_time\n        return count\n\n\n\n\n3. Minimum Number of Coins\n🎯 Understanding the Test Cases:\nTest Case 1:\nN = 43\nExplanation:\nThis is the first test case given in the question.\nWe need to find the minimum number of coins/notes to make ₹43. The best combination is:\n\n2 notes of ₹20\n1 coin of ₹2\n1 coin of ₹1\n\nSo, we return [20, 20, 2, 1].\nOther combinations, like [10, 10, 10, 10, 2, 1], are valid but require more coins/notes, so they aren’t optimal.\n\n3.1 Using Greedy\nNote: In general, we cannot say that greedy algorithm will produce correct output for such problems ( we need to use dynamic programming to solve these ). But in this problem, larger denominations can represent multiple smaller ones. For example, 3 coins of value 2 can be replaced by 1 coin of value 5 and 1 coin of value 1. So, we can use fewer large coins to replace many smaller ones.\nThus, we can use Greedy Approach: - Start with the largest denomination. - Subtract it from the amount until you can’t anymore. - Move to the next largest and repeat. - Add each coin/note used to the result.\n\n💻 Code Implementation:\nclass Solution:\n    def minPartition(self, N):\n        denominations = [2000, 500, 200, 100, 50, 20, 10, 5, 2, 1]  # List of denominations in descending order\n        result = []  # List to store the coins/notes used\n        \n        for coin in denominations:\n            while N &gt;= coin:  # Check how many times the coin/note can fit into the remaining amount\n                N -= coin  # Subtract the coin/note value from target\n                result.append(coin)  # Add the coin/note to the result list\n        \n        return result\n\n\n\n\n4. Jump Game\n🎯 Understanding the Test Cases:\nTest Case 1:\nnums = [2,3,1,1,4]\nExplanation:\nFirst, let’s understand the input. \\(nums[0] = 2\\) means that from the \\(0\\) th index we can jump at most 2 steps. That is, we can jump to index 1 or 2. \\(nums[1] = 3\\) means that from \\(1\\) st index we can jump at most 3 steps. That is, we can jump to indices 2, 3, or 4 from the 1st index. We need to find out whether we can reach the last index- index 4- by making the jumps.\n\nFrom index 0, you can jump up to 2 steps (to indices 1 or 2).\nFrom index 1, you can jump up to 3 steps (to indices 2, 3, or 4).\n\nBy jumping 1 step from index 0 to 1, and then 3 steps from index 1 to 4, you reach the last index. So, return True.\nTest Case 2:\nnums = [3,2,1,0,4]\nExplanation:\nFrom index 0, you can jump up to 3 steps (to index 3). But at index 3, you can’t jump any further. No matter how you jump, you can’t reach index 4.\nBut we can also take a jump of 2 steps ( or 1 steps ). Even then the maximum index that we can reach is the index 3. We cannot reach the last index- index 4.\nSo, we return False.\n\n4.1 Using Greedy Approach\n📚 Problem Overview:\nWe need to check if we can reach the last index of the nums array. Each element in nums[i] tells us the maximum jump we can take from index i.\nWe can solve this problem using the Greedy Approach.\n🤔 Greedy Approach:\n\nUse a max_jump variable to keep track of the furthest index we can reach so far.\nIterate Over nums:\n\nAt each step, update max_jump using: max_jump = max(max_jump, nums[idx] + idx).\nIf max_jump reaches or exceeds the last index, return True (we can reach the end!).\n\nIf idx &gt; max_jump, it means we are stuck and can’t move forward, so return False.\n\n\n💻 Code Implementation:\nclass Solution:\n    def canJump(self, nums: List[int]) -&gt; bool:\n        max_jump = 0\n        for idx in range(len(nums)):\n            # idx &lt;= max_jump -&gt; case to check [1, 0, 2] like condition\n            # nums[idx] + idx &gt; max_jump to update the jump\n\n            if idx &lt;= max_jump and nums[idx] + idx &gt; max_jump :\n                max_jump = nums[idx] + idx\n        \n        # Check whether you can reach the last index or not.\n        return max_jump &gt;= len(nums) - 1\n\n\n\n\n5 Jump Game-II\n\nUsing Greedy Approach\nWe can use similar approach as the above question.\n\n💻 Code Implementation:\nclass Solution:\n    def jump(self, nums: List[int]) -&gt; bool:\n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        jump_count = 0\n        current_end = 0\n        max_jump = 0\n        \n        for i in range(n - 1):\n            max_jump = max(max_jump, i + nums[i])\n\n            # When we reach the end of the current jump. For example, [3, 5, 1, 1, 1, 1]\n            if i == current_end:\n                jump_count += 1\n                current_end = max_jump\n                \n                # If we can reach the end, break early\n                if current_end &gt;= n - 1:\n                    break\n        \n        return jump_count"
  },
  {
    "objectID": "dsa/week9.html",
    "href": "dsa/week9.html",
    "title": "Leet Code Dynamic Programming Problems",
    "section": "",
    "text": "1. Climbing Stairs\n📚 Problem Overview:\nWe need to find the number of ways to reach the top of a staircase with n steps. At each step, you can either: 1. Take a single step, or 2. Take a double step.\n🎯 Understanding the Test Cases:\nTest Case 1: n = 3\nThere are three ways to reach the third step:\n\n\\(0\\) \\(\\rightarrow\\) \\(1\\) \\(\\rightarrow\\) \\(2\\) \\(\\rightarrow\\) \\(3\\). In this way, we are taking one step every time.\n\\(0\\) \\(\\rightarrow\\) \\(1\\) \\(\\rightarrow\\) \\(3\\). Here, we jumped \\(2\\) places from the \\(1\\) st step.\n\\(0\\) \\(\\rightarrow\\) \\(2\\) \\(\\rightarrow\\) \\(3\\). Here, we jumped \\(2\\) places from the \\(0\\) th step, and then \\(1\\) step from the \\(2\\) nd step.\n\nSince there are three ways we return 3.\n🤔 Key Observations:\n\nBase Cases:\n\nTo reach step 0, you need to take \\(0\\) steps ( no need to take any step!).\nTo reach step 1, there is only \\(1\\) way.\nTo reach step \\(2\\), there are two ways: $ 0 $ and $0 $\n\nRecursive Relationship:\n\nIf you’re on step n, you don’t require further steps.\nFrom step n-1, you have 1 way to reach the top.\nFrom step n-2, you have 2 ways (you can jump directly to n or take two steps).\nTo reach step i, you can either come from step i-1 or step i-2. So the relation is: \\[ \\text{ways}(i) = \\text{ways}(i-1) + \\text{ways}(i-2) \\]\n\n\n💡 The Solution: Dynamic Programming\nWe can solve this problem in linear time using dynamic programming by storing the number of ways to reach each step and using the above relation to build up from the base cases.\n\nUse an array to store the number of ways to reach each step.\nStart from step 0 and build up using the relation:\n\nways(i) = ways(i-1) + ways(i-2)\n\n\nTime Complexity: \\(O(n)\\)\n\n💻 Code Implementation:\nclass Solution:\n    def climbStairs(self, n: int) -&gt; int:\n        L = [0]*n # Initialize the dynamic programming array\n        \n        # Base Cases\n        if n == 1: return 1 \n        if n == 2: return 2\n        \n        L[0] = 1\n        L[1] = 2\n\n        # ways[i] = ways[i - 1] + ways[i - 2]\n        for i in range(2, n):\n            L[i] = L[i - 1] + L[i - 2]\n        \n        # Last element corresponds to the nth stair. So return that value.\n        return L[-1]\n\n\n\n2. House Robber\n\n2.1 Using Dynamic Programming\n📚 Problem Overview:\nYou need to rob houses along a street, but you can’t rob two adjacent houses. The goal is to figure out the maximum amount of money you can rob, without breaking the adjacency rule.\n🤔 Key Observations:\n\nIf you’re at the first house, you can only rob that house.\n\nSo, the maximum money you can rob up to house \\(1\\) is just nums[0].\n\nFor the second house, you either rob the first or the second, but not both.\n\nSo, the max money that you can steal up to house \\(2\\) is \\(max(nums[0], nums[1])\\).\n\nFor any house from the third house onwards, you have two choices:\n\nRob this house and add its money to the max amount from two houses back (since you can’t rob the adjacent house).\nSkip this house and keep the money robbed up to the previous house.\n\n\n💡 The Solution:\nWe use a dynamic programming array maximum_amount where each maximum_amount[i] holds the maximum money you can rob up to house i: - Base cases: - maximum_amount[0] = nums[0] - maximum_amount[1] = max(nums[0], nums[1])\n\nRecursive relation:\n\n\\(maximum\\_amount[i] = max(maximum\\_amount[i-1], maximum\\_amount[i-2] + nums[i])\\)\n\n\nThis ensures that for each house, you decide whether to rob it (and add the money from two houses ago) or skip it (and take the max up to the last house). The result will be the value in maximum_amount[n-1], where n is the total number of houses.\nTime complexity: \\(O(n)\\)\n\n💻 Code Implementation:\nclass Solution:\n    def rob(self, nums: List[int]) -&gt; int:\n        if len(nums) == 1:\n            return nums[0]\n\n        maximum_amount = [0] * len(nums)\n        \n        # Base cases\n        maximum_amount[0] = nums[0]\n        maximum_amount[1] = max(nums[0], nums[1])\n\n        for i in range(2, len(nums)):\n            maximum_amount[i] = max(maximum_amount[i-1], maximum_amount[i-2] + nums[i])\n        \n        return maximum_amount[-1]\n\n\n\n\n3. Fibonacci Numbers\n\n3.1 Using Dynamic Programming\nThis problem is discussed in the lectures. The approach used here is exactly the same.\n\n💻 Code Implementation:\nclass Solution:\n    def fib(self, n: int) -&gt; int:\n        # Initialize the fibtable array to be all zeros\n        fibtable = [0] * (n + 1)\n\n        # Base Case 1: Where n == 0\n        if n == 0: return fibtable[0]\n\n        # Base Case 2: Where n == 1\n        fibtable[1] = 1\n\n        for i in range(2, n + 1):\n            #F(n) = F(n - 1) + F(n - 2)\n            fibtable[i] = fibtable[i - 1] + fibtable[i - 2]\n        \n        # fibtable[i] is the ith fibonacci number. Thus, to get nth fibonacci number, return fibtable[n]\n        return fibtable[n]\n\n\n\n\n4. Triangle\n\n4.1 Using Dynamic Programming\n📚 Problem Overview:\nWe need to find the minimum path sum in a triangle from the top to the bottom. At each step, we can move to the element directly below or diagonally below-right. The task is to minimize the sum of the numbers along this path.\nIn other words, the question is asking for us to find the minimum path sum from the top to the bottom of the triangle, where each step can be to only the ith or i + 1 th cell in the row below.\nOne way we can do this is by listing down all the paths and then take the minimum sum path from that. But it won’t be efficient!\n🤔 Key Observations:\n\nTo get to a certain cell, you can only come from the cell directly above it or the one diagonally left above it.\nThe problem can be broken into smaller subproblems. The minimum path sum at any cell depends on the minimum of the two cells below it.\nFor a cell triangle[row][col], the relation is: \\[MPS(triangle[row][col]) = triangle[row][col] + \\min(MPS(triangle[row + 1][col]), MPS(triangle[row + 1][col + 1]))\\]\nThe base cases are the last row of the triangle. There are no children below, so the values in the last row stay the same.\n\nSince we are solving overlapping subproblems and then combining those subproblems to solve the original problem, we’ll use dynamic programming, starting from the bottom of the triangle and working our way up to the top.\n💡 The Solution Approach: - After processing the last row, that is- the row of the base cases, we can move one level up in the triangle. - After processing that level, we get a minimum path of length 2 for each of the cells in the second last row. More generally, after processing a row, each element in that row would hold the minimum path sum from that element to the bottom of the triangle. - After processing the entire triangle, the top element of the triangle would hold the minimum path sum from the top to the bottom of the triangle, which is the answer to the problem.\n\n💻 Code Implementation:\nclass Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -&gt; int:\n        # Start from the second-to-last row of the triangle\n        for row in range(len(triangle) - 2, -1, -1):\n            for col in range(len(triangle[row])):\n                # Update the current element with the sum of the element itself\n                # and the minimum of the two adjacent elements in the row below\n                triangle[row][col] = triangle[row][col] +  min(triangle[row + 1][col], triangle[row + 1][col + 1])\n\n        # The top element now contains the minimum path sum\n        return triangle[0][0]\n\n\n\n\n5. Coin Change\n\n5.1 Using Dynamic Programming\n📚 Problem Overview:\nWe need to find the minimum number of coins required to make a given amount. We can use coins from the given list. If it’s impossible to make the amount, return \\(-1\\).\nThe first thought here can be that we need to use the greedy strategy. But as we can see from the test cases, the greedy strategy won’t always give us the optimal solution.\n🤔 Key Observations:\n\nFor any amount, the minimum number of coins to make that amount can be thought of as: \\[ \\text{mincoins}(amount) = \\text{mincoins}(amount - coin) + 1 \\]\nThis means for any amount, we can take a coin and reduce the problem to finding the minimum coins needed for the remaining amount.\nCan you figure out why the subproblems are overlapping?\n\n💡 The Solution Approach:\nSince we have overlapping subproblems, we use dynamic programming: - Keep an array of length \\(amount + 1\\), where each index i stores the minimum number of coins required to get change for amount i. Let this array be called dp. 1. Create a dp array of size amount + 1, where dp[i] stores the minimum number of coins to make amount i. Initially, set all values to infinity (inf), except dp[0] = 0, because we need 0 coins to make amount 0. 2. For each coin, update the dp array: - For every amount from 0 to the given amount, update the minimum coins: - $ = (, + 1) $\n\nAfter processing all amounts, if dp[amount] is still inf, return \\(-1\\) (because it’s impossible to make that amount). Otherwise, return dp[amount].\n\nTime Complexity: \\(O(amount * coins)\\)\n\n💻 Code Implementation:\nclass Solution:\n    def coinChange(self, coins, amount):\n        # Initialize a dp array where dp[i] will hold the minimum number of coins required for amount i\n        dp = [float('inf')] * (amount + 1)\n        \n        # Base case: No coins are needed to make amount 0\n        dp[0] = 0\n\n        for coin in coins:\n            dp[coin] = 1\n        \n        # Fill the dp array\n        for coin in coins:\n            for x in range(coin, amount + 1):\n                dp[x] = min(dp[x], dp[x - coin] + 1)\n        \n        # If dp[amount] is still inf, it means it's not possible to make that amount with given coins\n        return dp[amount] if dp[amount] != float('inf') else -1\n\n\n\n\n6. Best Time to Buy and Sell Stock III\n\n6.1 Using Dynamic Programming\n📚 Problem Overview:\nWe need to find the maximum profit we can earn by buying and selling a stock at most two times. We need to buy before we can sell the stock. Further, we are allowed to transact either once or twice but not more than twice.\n🤔 Key Observations:\nSince we’re allowed to make two transactions, for any given day, the total profit is the sum of:\n\nMaximum profit before that day.\nMaximum profit after that day.\n\nFor example, let’s take the prices list: [3, 3, 5, 0, 0, 3, 1, 4].\n🔹 On day 3 (price = 0): - Maximum Profit before day 3: The best time to buy and sell before day 3 is buying at 3 (day 0) and selling at 5 (day 2). So, 5 - 3 = 2. - Maximum Profit after day 3: The best time to buy after day 3 is buying at 0 (day 3) and selling at 4 (day 7). So, 4 - 0 = 4.\nBy adding them together, the total profit on day 3 would be 2 + 4 = 6.\nWe repeat this process for each day to find the total maximum profit. The day with the highest total profit is where we should ideally transact to make the most money!\nThe key idea here is that we can compute the before and after arrays in linear time.\nFor the after array: - We start from the end of the prices list and keep track of the largest number we’ve seen so far. This largest number will be the selling price for any prices[i] we see along the way. - So, for each day, the profit is the difference between the largest number (sell price) and prices[i] (buy price).\nWe can do a similar thing for the before array, but instead of keeping track of the largest number, we will track smallest number.\n\n💻 Code Implementation:\nclass Solution:\n    def maxProfit(self, prices: List[int]) -&gt; int:\n        n = len(prices)\n        after = [ 0 ] * n\n        max_from_right = prices[-1]\n\n        # Find out the maximum profit we can earn in one transaction after an index 'i'\n        for i in range(n - 2, -1, -1):\n            max_from_right = max(max_from_right, prices[i + 1])\n            after[i] = max(max_from_right - prices[i], 0)\n            after[i] = max(after[i], after[i + 1])\n\n        # Find out the maximum profit we can earn in one transaction before an index 'i'\n        before = [ 0 ] * n\n        min_from_left = prices[0]\n        for i in range(1, n):\n            min_from_left = min(min_from_left, prices[i - 1])\n            before[i] = max(prices[i] - min_from_left, 0)\n            before[i] = max(before[i], before[i - 1])\n        \n        # Total Profit[i] = before[i] + after[i]\n        # Maximum total profit = max(Total Profit)\n        max_profit = 0 \n        for i in range(n):\n            max_profit = max(before[i] + after[i], max_profit)\n\n        return max_profit\n\n\n\n\n7. Unique Paths-II\n\n7.1 Using Dynamic Programming\nThis is the grid paths with barriers problem discussed in the lecture. We will use the same idea and the code to solve this problem.\n\n💻 Code Implementation:\nimport numpy as np\nclass Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int:\n        x, y = len(obstacleGrid), len(obstacleGrid[0])\n\n        M = np.zeros((x,y))\n\n        # Handle corner case where the starting cell has a barrier\n        if obstacleGrid[0][0] == 0: M[0, 0] = 1\n        else: M[0, 0] = 0\n\n        # Initialize the base cases\n        for i in range(x):\n            for j in range(y):\n                if i == 0 and j &gt; 0 and (obstacleGrid[i][j] == 0):\n                    M[i,j] = M[i, j - 1]\n                if j == 0 and i &gt; 0 and (obstacleGrid[i][j] == 0):\n                    M[i, j] = M[i - 1, j]\n                \n        # If there is obstacle, then there are 0 ways. Else we sum the left and bottom ways\n        for i in range(1,x):\n            for j in range(1,y):\n                if obstacleGrid[i][j] == 1:\n                    M[i,j] = 0\n                else:\n                    M[i,j] = M[i-1,j] + M[i,j-1]\n        return int(M[x-1,y-1])\n\n\n\n\n8. Word Break\n\n💻 Code Implementation:\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool:\n        # Length of the input string\n        n = len(s)\n        \n        # Convert word dictionary to a set for O(1) lookup\n        word_set = set(wordDict)\n        \n        # Initialize the dp array, where dp[i] represents the minimum number of extra chars needed from index i to the end\n        dp = [float('inf')] * (n + 1)\n        dp[n] = 0  # Base case: no extra characters are needed at the end of the string\n        \n        # Populate the dp array from right to left\n        for i in range(n - 1, -1, -1):\n            # Start by treating the character at s[i] as an extra character\n            dp[i] = dp[i + 1] + 1\n            \n            # Check substrings starting from index i to find words in the dictionary\n            for j in range(i + 1, n + 1):\n                substring = s[i:j]\n                \n                # If the substring is a valid word, minimize extra chars by checking dp[j]\n                if substring in word_set:\n                    dp[i] = min(dp[i], dp[j])\n\n                # Early break if dp[i] reaches 0 (no extra chars needed from i onward)\n                if dp[i] == 0:\n                    break\n        \n        # If dp[0] is 0, then the whole string can be segmented without extra chars\n        return dp[0] == 0\n\n\n\n9. Maximal Square\n\n💻 Code Implementation:\nclass Solution:\n    def maximalSquare(self, matrix: List[List[str]]) -&gt; int:\n        # Dimensions of the matrix\n        m, n = len(matrix), len(matrix[0])\n\n        # Initialize scores table\n        scores = [[0] * n for _ in range(m)]\n\n        # Build the scores table from bottom-right to top-left\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                if matrix[i][j] == \"1\":\n                    # Calculate score for each cell based on \"1\"s around it\n                    score = 1\n                    if i &lt; m - 1 and j &lt; n - 1:\n                        score += int(matrix[i + 1][j + 1])\n                    if i &lt; m - 1:\n                        score += int(matrix[i + 1][j])\n                    if j &lt; n - 1:\n                        score += int(matrix[i][j + 1])\n                    \n                    scores[i][j] = score\n\n\n        # Initialize DP table\n        # dp[i] = maximum size of square from (i, j) cell\n        dp = [[0] * n for _ in range(m)]\n        \n        # Populate the DP table bottom up\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                if matrix[i][j] == \"1\":\n                    # Check for the size of square based on neighboring cells\n                    if i &lt; m - 1 and j &lt; n - 1:\n                        if (scores[i + 1][j] == scores[i + 1][j + 1] == scores[i][j + 1] \n                            and scores[i][j] &gt; 0):\n                            dp[i][j] = 1 + min(dp[i + 1][j + 1], dp[i + 1][j], dp[i][j + 1])\n                        elif scores[i][j] == 4:\n                            dp[i][j] = 2\n                        else:\n                            dp[i][j] = 1\n                    else:\n                        dp[i][j] = 1\n\n        # Find the maximum square size\n        max_square_size = max(max(row) for row in dp)\n        \n        return max_square_size ** 2 # Return Area of the square\n\n\n\n10. Maximum Number of Moves in a Grid\n\n💻 Code Implementation:\ndef maxMoves(grid):\n    # Dimensions of the grid\n    rows, cols = len(grid), len(grid[0])\n\n    # dp[i][j] will store the maximum moves possible starting from cell (i, j)\n    dp = [[0] * cols for _ in range(rows)]\n    max_moves = 0  # This will store the overall maximum moves starting from any cell in the first column\n\n    # Fill the DP table column by column, from right to left\n    for col in range(cols - 2, -1, -1):\n        for row in range(rows - 1, -1, -1):\n\n            # Check the possible cells we can move to in the next column\n            next_cell_up = grid[row - 1][col + 1] if row &gt; 0 else 0\n            dp_next_up = dp[row - 1][col + 1] if row &gt; 0 else 0\n\n            next_cell_right = grid[row][col + 1]\n            dp_next_right = dp[row][col + 1]\n\n            next_cell_down = grid[row + 1][col + 1] if row &lt; rows - 1 else 0\n            dp_next_down = dp[row + 1][col + 1] if row &lt; rows - 1 else 0\n\n            current_cell = grid[row][col]\n\n            # Determine the maximum moves from this cell (row, col)\n            if current_cell &gt;= next_cell_up and current_cell &gt;= next_cell_right and current_cell &gt;= next_cell_down:\n                # No move possible since all adjacent cells have equal or smaller values\n                dp[row][col] = 0\n            else:\n                # Calculate the maximum moves by considering each possible valid move direction\n                max_next_moves = 0\n                if current_cell &lt; next_cell_up:\n                    max_next_moves = max(max_next_moves, dp_next_up)\n                if current_cell &lt; next_cell_right:\n                    max_next_moves = max(max_next_moves, dp_next_right)\n                if current_cell &lt; next_cell_down:\n                    max_next_moves = max(max_next_moves, dp_next_down)\n                \n                dp[row][col] = 1 + max_next_moves\n\n            # Update the maximum moves if we're in the first column\n            if col == 0:\n                max_moves = max(max_moves, dp[row][col])\n\n    return max_moves"
  },
  {
    "objectID": "posts/challenge-accepted/index.html",
    "href": "posts/challenge-accepted/index.html",
    "title": "Challenge Accepted!",
    "section": "",
    "text": "We’d gone to meet the soul of NAMCO Hospital, Shashikant Parakh. He was in a meeting regarding the construction of a Bone Marrow Transplant unit at the hospital.\n Photo with Shashikant Parakh\nI got to hear a few bits and pieces of it. Shashikant, a commerce graduate, was talking with no less depth of knowledge than a medical professional. He talked loud and clear, and never ever drifted away from the topic. A management authority, who himself was a doctor, showed us around the hospital.\nThe hospital was different from other hospitals in many ways. It didn’t have the hospital smell. Instead, it smelled of respect for Shashikant. Its cleanliness was striking and the equipment could’ve easily put to shame the finest of super speciality hospitals. All this for patients who cannot pay for their treatment. All this because of one man — Shashikant.\n\n“I was born and brought up in the religious town of Shirdi, the town of Sai Baba. We were a joint family and owned a small shop of religious goods in front of a temple.”\n\nShirdi was, and still is, the destination of pilgrims. But the thing is that the pilgrims don’t come to visit Shirdi only. There’s a chain of destinations ahead, which is why most of the pilgrims don’t stay in Shirdi for more than half a day. This was a brilliant opportunity to develop a lodging business and it took an innovative young chap, like Shashikant, to recognise this.\n\n“There was a 34-room lodging apartment to be rented in Shirdi. I convinced my family to pay the rent and said I would handle the business. They agreed.”\n\nShashikant started the hotel in three eight-hour shifts. Since the pilgrims didn’t need to stay for the whole day, they preferred Shashikant’s hotel over others. Immediately, it was a huge success.\n\n“The rent was ₹1,11,000 per year, and I managed to earn a sum of 7-8 lakhs in the first year. I was in my first year of college.”\n\nSoon, he’d earned enough to buy another hotel, and soon after, a third one. The business had settled without facing any serious challenges. But was he settled?\nNo! A smooth ride isn’t his type. He likes a roller coaster filled with challenges.\n\n“Once the lodging business had settled, I handed it over to my family and said, ‘You take care of this business and I, am going to Nashik.’”\n\nHe came to Nashik with no riches and no recognition. He would need to build it again. Soon, he started a distribution agency. Once it had settled, he ventured into real estate. Then construction, and then, warehousing. Today, in total, he runs eight businesses, with an annual total turnover of more than a hundred crores, and employs about a hundred people.\n\n“Opportunities kept on coming, and I kept on grabbing them.”\n\nBut a nagging question haunted him: is there an end to all this? And if there’s no end, then why expand the business? He stopped expanding it around 2008-09. Now, it was time to use his entrepreneurial skills to help others. That was the biggest challenge.\n\n“I volunteered at a few places before I was given the opportunity to work at NAMCO charitable hospital.”\n\nWhen I joined, NAMCO was totally deteriorated. The first day after he joined, he called a ‘staff meeting.’\n\n“I said to them, ‘I’m the new secretary here and we are going to transform NAMCO.’ They laughed. They literally laughed and said, ‘We’ve seen a lot of people like you. You just jabber and do nothing.’”\n\nWhen I joined, NAMCO was only treating cancer patients. Bats and rats roamed around. There were only two doctors, both of whom weren’t present most of the time. We had thirty beds, out of which, at maximum, only three were occupied.\nThis was 2015. Fast forward to 2020, and you’ll see an entirely different picture.\n\n“Today, NAMCO is a multi-specialty hospital en route to becoming a super-specialty hospital with state-of-the-art technology at the cheapest rates. There is a staff of 305, out of which, 40 are highly qualified medical professionals. It now has a total of a hundred beds with a few patients always in the waiting.”\n\nStill, Shashikant’s ambitions for NAMCO run quite high, quite literally.\n\n“I’m going to construct a twelve-storey tower with each floor dedicated to each specialty,” he says nonchalantly.\n\nShashikant’s entire life has revolved around one word: challenges. He loves taking up challenges; he thrives when challenged. His life will continue to revolve around that word. He had taken up the biggest challenge of helping others, but he has a wish for a personal challenge as well: Skydiving.\n\n“Skydiving is a dream. I couldn’t do it before, but I will do it soon.”\n\nIt will not be a surprise then, if he takes a jump out of his steady flight, to take up an entirely new challenge, falling fast towards the destination, with sheer determination to glide to safety.\n\nAdvice to the Youth\n\n“Dream big. It’s as simple as that. Ever since my childhood days, I’ve always dreamt of becoming the richest man of my town. Dream big but dream with intensity. Only those dreams come true.”\n\n\n“Keep learning. Be ready to learn. I’ve always had this mindset — whichever field I’ll dabble in, I’ll gain complete knowledge of it. When I started in real estate, I went through a lot of books. When I started working at NAMCO, I studied medical books, which I still do. Have that mindset.”\n\n\n“And be happy. Success is nothing but happiness. Don’t complain. Do whatever you want but be happy.”"
  },
  {
    "objectID": "posts/first-project-using-fastai/index.html",
    "href": "posts/first-project-using-fastai/index.html",
    "title": "Building a Digit Classifier From Scratch",
    "section": "",
    "text": "This is my first time building a deep learning model from scratch. Before this, I had not tried it, and I wasn’t sure where to start. But thanks to Jeremy Howard’s Practical Deep Learning for Coders course, I gave it a shot and built my first deep learning model- a digit classifier. His course also encouraged me to share what I learn with others.\nIn this blog post, I’ll share how I built a simple neural network using FastAI and PyTorch. I’ll walk through how I prepared the data, built the model, and trained it. I hope my experience helps others who are also trying to build their first model.\n\nLoading the Training Dataset\nAlthough FastAI comes with the MNIST dataset, it needs to be loaded and prepared for training.\nThe data is in the URLs module in fastai library, and it has the following directory structure:\npath/\n├── training/\n│   ├── 0/\n│   │   ├── img1\n│   │   └── img2\n│   ├── 1/\n│   │   ├── img2\n│   │   └── img1\n├── testing/\n│   ├── 0/\n│   │   ├── img1\n│   │   └── img2\n│   ├── 1/\n│   │   ├── img1\n│   │   └── img2\nWe can write a few lines of code to load these images as tensors:\n\npath = untar_data(URLs.MNIST)\nPath.BASE_PATH = path\n\nx = [ ]\ny = [ ]\nfor i in range(10):\n    img_paths = (path/'training'/str(i)).ls()  # Get the image paths of a digit\n\n    # Load the images and convert to tensors\n    x.extend([tensor(Image.open(o)) for o in img_paths])\n\n    # Store the corresponding digit label for all images in this folder\n    y.extend([tensor(i)] * len(img_paths))\n\n\nData Preprocessing\nI now had a \\(28 \\times 28\\) matrix for each image. To pass this as input to the model, I needed to flatten it into a single tensor, and standardize the pixel values for better results.\n# Convert the python list into PyTorch tensor, and standardize it\nx_tensor = torch.stack(x).float()/255\ny_tensor = torch.tensor(y)\n\n# Each image is 28 * 28. So we flatten each image into a single flat tensor of size 784.\nflattened_x = x_tensor.view(-1, 28*28)\nflattened_y = y_tensor.unsqueeze(1) # y_tensor has shape [60000], we unsqueeze it to make it [60000, 1]\nIt’s always a good idea to split the dataset into training and validation sets:\nfrom fastai.data.transforms import RandomSplitter\n\nsplitter = RandomSplitter(valid_pct=0.2, seed=42)  # 80% training, 20% validation\n\ntrain_idxs, val_idxs = splitter(range(len(flattened_x))) # Splitter returns indices for the two sets\n\n# Create the training and validation data from those indices\nX_train = flattened_x[train_idxs]\ny_train = flattened_y[train_idxs]\n\nX_val = flattened_x[val_idxs]\ny_val = flattened_y[val_idxs]\nAs Jeremy Howard says, getting the data into your model is the trickiest and the most time-consuming part of building a deep learning model. Boy, it was tricky!\nNow that I had the dataset ready, I trained the model.\n\n\nTraining the Model\nI used a simple two-layer neural network to classify the digits. This architecture, while basic, was a good starting point for understanding how deep learning models work.\n\nLinear Layer\nReLU activation Layer\nLinear Layer\nSoftmax Output\n\nSince the task is a classification task with multiple classes, I used cross entropy loss as the loss function to guide training. By using plain softmax as output function, I got NaN values, so I used log softmax for numerical stability.\nFor this model, I had two sets of parameters:\n\nWeights and biases for layer 1, and\nWeights and biases for layer 2\n\nIt’s not a terrible idea to randomly initialize these weights. I defined the functions to implement the functionality for the model’s architecture:\n\nInitializing random weights\nComputing cross entropy loss\nComputing log softmax\nMatrix multiplication for the linear layers\n\ndef init_params(size, std=1.0):\n    \"\"\"Randomly initializes parameters of given size\"\"\"\n    return (torch.randn(size)*std).requires_grad_()\n\ndef linear(xb, weights, bias):\n    \"\"\"Does matrix multiplication with inputs and weights: y = mx + c\"\"\"\n    return xb @ weights + bias\n\ndef log_softmax(logits):\n    max_logits = logits.max(dim=1, keepdim=True).values\n    stable_logits = logits - max_logits  # For numerical stability\n\n    # Compute log-softmax\n    log_probs = stable_logits - torch.log(torch.exp(stable_logits).sum(dim=1, keepdim=True))\n\n    return log_probs\n\ndef cross_entropy_loss(log_probs, yb):\n    yb = yb.squeeze(1)\n    log_probs = log_probs.squeeze(1)\n\n    true_class_log_probs = log_probs[range(len(yb)), yb]\n\n    loss = -true_class_log_probs.mean()\n    return loss\nThen, I used the DataLoaders class in FastAI, which passes the input tensors to the models in batches. I also initialized the model parameters.\n\n# Randomly initialize weights and biases for both the layers\nw1 = init_params((28*28,128))\nb1 = init_params(128)\nw2 = init_params((128,10))\nb2 = init_params(10)\n\ntrain_dataloader = DataLoader(train_dataset, batch_size=256, shuffle=True)\nvalidation_dataloader = DataLoader(validation_dataset, batch_size=256, shuffle=True)\nFinally, the training phase:\n\nepochs = 25 # Train for 25 Epochs\nlearning_rate = 0.001\n\nfor i in range(epochs):\n    for xb, yb in train_dataloader:\n        # Reset gradients that have acccumulated in the last batch\n        if w1.grad is not None:\n            w1.grad.zero_()\n        if b1.grad is not None:\n            b1.grad.zero_()\n        if w2.grad is not None:\n            w2.grad.zero_()\n        if b2.grad is not None:\n            b2.grad.zero_()\n\n        # Forward pass \n        hidden = torch.relu(linear(xb, w1, b1)) # 1st linear + ReLU\n        probabilities = log_softmax(linear(hidden, w2, b2)) # 2nd Linear + softmax\n\n        # Compute loss for the current training batch\n        loss = cross_entropy_loss(probabilities, yb)\n\n        # Backpropagation: use PyTorch functionality to do backpropagation\n        loss.backward()\n\n        # Update weights and biases\n\n        # Update weights and biases\n        with torch.no_grad():\n            w1 -= learning_rate * w1.grad\n            b1 -= learning_rate * b1.grad\n            w2 -= learning_rate * w2.grad\n            b2 -= learning_rate * b2.grad\n\n    # Compute loss on the validation dataset with the same model\n    epoch_loss = 0\n    for xb, yb in validation_dataloader:\n        hidden = torch.relu(linear(xb, w1, b1))\n        probabilities = log_softmax(linear(hidden, w2, b2))\n        loss = cross_entropy_loss(probabilities, yb)\n        epoch_loss += loss.item()\n\n    average_loss = epoch_loss / len(validation_dataloader)\n\n    # Print the loss after each epoch\n    print(f'Epoch [{i+1}/{epochs}], Loss: {average_loss:.4f}')\n\n\nEvaluating the Model\nAfter training, it was time to test the predictions on the test dataset, the moment of truth!\nI performed the same preprocessing steps on the test dataset, as on the training dataset. First, we load the data, then we convert it into a flattened tensor, which we then standardize.\ntesting_path = (path/'testing').ls()\n\nx_test = [ ]\ny_test = [ ]\nfor i in range(10):\n    img_paths = (path/'testing'/str(i)).ls()  # Get the image paths in folder 'i'\n\n    # Load the images and convert to tensors\n\n    x_test.extend([tensor(Image.open(o)) for o in img_paths])\n\n    # Store the corresponding label `i` for all images in this folder\n    y_test.extend([tensor(i)] * len(img_paths))\n\n\nx_test_tensor = torch.stack(x_test).float()/255\ny_test_tensor = torch.tensor(y_test)\n\n# Each image is 28 * 28. So we flatten each image into a single flat tensor of size 784.\nflattened_x_test = x_test_tensor.view(-1, 28*28)\nflattened_y_test = y_test_tensor.unsqueeze(1)\nI used the trained model to compute the predictions, and get the fraction of accurate predictions.\n# Forward pass through the network\nhidden = torch.relu(linear(flattened_x_test, w1, b1))\nprobabilities = log_softmax(linear(hidden, w2, b2))\n\npredicted_classes = torch.argmax(probabilities, dim=1)\n\ncorrect_predictions = (predicted_classes == y_test_tensor).sum().item()\n\n# Calculate the number of incorrect predictions\nincorrect_predictions = len(y_test_tensor) - correct_predictions\n\naccuracy = correct_predictions / len(y_test_tensor) \nprint(f'Accuracy on test dataset: {accuracy * 100:.2f}%')\nThe model achieves about 87% accuracy! For my first model, not bad at all!\n\n\n\nFinal Thoughts\nBuilding this model was much more helpful than simply watching tutorials. There’s a great room for improvement on this model, like increasing the complexity of the model, exploring errors, or trying a different architecture. The possibilities to experiment are endless, and I hope to continue experimenting!\nIf you’re reading this and thinking about building your own first model, it’s worth it! Happy coding! ✌️\nP.S. Take a look at FastAI’s course: Practical Deep Learning for Coders. It’s truly one of a kind!"
  },
  {
    "objectID": "posts/mastering-life-like-a-grandmaster/index.html",
    "href": "posts/mastering-life-like-a-grandmaster/index.html",
    "title": "Mastering Life Like a Grandmaster",
    "section": "",
    "text": "Recently, I came across Vishy Anand’s book- “Mind Master”. For anyone who admires Vishy, and anyone who wants to succeed in life, the book is a delight. Vishy shares his experiences and the lessons he learned from playing chess. In this post, I share the top three lessons from Vishy’s book.\nThose who want to read the book can buy it here.\n1. Don’t Obssess About Your Progress\nIt is important to keep track of your progress, but it’s not at all helpful to obsess over how far you’ve come. Sometimes, it feels like you’re getting nowhere, and then, out of nowhere, situations may change and you may achieve your goals within a week.\nFor Vishy, it took seemingly forever to get his grandmaster norms. He missed out on the norms by the smallest margins- as small as half a point. He got frustrated and impatient. He was so close to achieving a goal he had worked so hard for. Fortunately, he had mentors and friends to support him through the journey. This slump was definitely difficult, but when he did get the norms, he earned all the three within a span of just a year!\nIf you’re feeling like you’re getting nowhere, that’s totally fine! If you’re not finding a job, that’s okay! If you’re finding it hard to master deep learning, that’s also alright! The key is to not obsess over your progress but to be tenacious. Have someone to support you. Who knows, the tides may turn within a week!\n2. What Should You Do After You Achieve Your Goals?\nOnce Vishy realized that he wanted to become a grandmaster, he spent all his energy into the pursuit of achieving that goal. Becoming a grandmaster is what gave his life meaning. But what happened after he became grandmaster?\nVishy says, his life was empty. There was no meaning left once he’d achieved his goal. You may be surprised, but Vishy wasn’t the exception. Most grandmasters feel this way once they become GMs.\nSome of us may be fortunate enough to achieve our goals, but some of us may not be- we may have to quit. Then, it’s all too easy to fall into the trap of despising ourselves for wasting efforts and time. It’s all too easy to not find the purpose of life.\nBut we need to put our trust in time. For Vishy, it took him six months to get back to being excited about life. With time, we will get over this void and move on. But during this time, perhaps we take up a hobby, travel, or do something that we always wanted to do.\n3. Will AI Take My Job?\nFor so long, brilliant chess was solely human feat. Grandmasters in the olden days relied on nothing but their effort and intellect. With time, computers started beating chess players. Now, no chess grandmaster prepares without using a chess engine.\nChess witnessed the rise of AI. Vishy is perhaps the only person to have played in all three eras of chess. He saw what AI can do and how AI can impact us. Of course, Vishy has some advice for all of us.\nWe cannot deny the rise of AI. It’s definitely going to change things. As professionals, it’s up to us to adapt, learn, and unlearn. The way Vishy sees it, his work begins where AI’s work ends. The job of an engine is to study the positions and come up with analyses and conclusions. Once the conclusions are ready, it’s when Vishy’s job starts. He needs to understand why the conclusions make sense and then use those conclusions to enhance his understanding of his game.\nThere’s an open interpretation here- if we want, we can apply the same reasoning to any other field, and not just Chess. Is AI going to take over software developer jobs? It’s definitely going to change them. Those who can adapt can brilliantly make use of AI’s power to do their jobs better.\nRegardless of whether AI takes over or not, it’s certainly our duty to be adaptable. Always be asking ourselves the questions: What do I need to learn? What do I need to unlearn?\n\n\n\nMind Master By Vishy"
  },
  {
    "objectID": "posts/why-we-sleep/index.html",
    "href": "posts/why-we-sleep/index.html",
    "title": "How Good Is Sleep!",
    "section": "",
    "text": "What if someone told you that there exists a pill that is for free and it will make you live long, and be healthy and smart? I would jump right at it! But that pill is always with us and it is for free. It’s called sleep.\nIn this post, I have summarized the book and the key learnings from the book. You can also listen to the audio summary on the Booklet app. Be sure to check out sleep tips."
  },
  {
    "objectID": "posts/why-we-sleep/index.html#part-1",
    "href": "posts/why-we-sleep/index.html#part-1",
    "title": "How Good Is Sleep!",
    "section": "Part 1",
    "text": "Part 1\n\nWhy Do We Sleep?\nHow do we know that it’s time to sleep? There are two reasons: Circadian Rhythm and Sleep Pressure.\nYour body has its own clock. It tells you when to do what. It will tell you when to sleep, when to eat, when to drink. This is called the circadian rhythm, which is different for everyone. That’s why there are people who like staying up late at night and wake up late, and also those who go to bed early and get up early. None of the two is wrong, they’re just different.\nThe other half of the answer is something called Sleep Pressure. With each wakeful moment, a chemical called ‘ Adenosine’ gets accumulated in your brain. When enough Adenosine gets accumulated, you feel sleepy. This is called ‘ Sleep Pressure.’ When you are awake for the whole day( 12 to 16 hours), there is enough Adenosine to make you sleepy. And a sleep of eight hours is good enough to remove this Adenosine from the brain.\nWhen the circadian rhythm and sleep pressure coordinate, you feel a strong urge to sleep. That’s why we go to bed every night.\n\n\nHow Do We Sleep?\nResearchers carefully observed sleeping babies ( cute, right?). What they found was that their eyeballs don’t remain still all the time. There are periods when the eyeballs move around rapidly, and there are periods when the eyeballs remain still. This happens with adults too. The researchers named these two periods as REM sleep ( Rapid Eye Movement) which is when you dream, and NREM ( Non Rapid Eye Movement) which is when you are in deep sleep.\nThe brain waves in REM are no different from your brain waves right now. It is when your body is paralysed, but your brain waves show very high activity. And because your body is paralysed, you don’t act on your dreams.\n\n\nWho Sleeps?\nEvery organism on the planet that has a lifespan of more than a few days, enjoys sleep or sleep-like activity, right from unicellular bacteria to giants like whales. There are fascinating stories in the animal kingdom about sleep. Let’s take dolphins as an example. They need to float in water, and at the same time, they need to keep an eye out for predators. How would they sleep? Their brain takes turns in sleeping. First, one half of the brain falls into deep NREM sleep. After it has had a healthy sleep, the other half of the brain sleeps, which means they can function good enough with just one brain. And, when they are awake, both halves of their brain work in perfect coordination. Imagine having that as a superpower!"
  },
  {
    "objectID": "posts/why-we-sleep/index.html#part-2",
    "href": "posts/why-we-sleep/index.html#part-2",
    "title": "How Good Is Sleep!",
    "section": "Part 2",
    "text": "Part 2\nSleep offers so many benefits, from health to memory, from immunity to performance, that the question to ask is not ‘ Why do we sleep?’ But rather ‘ Why did we ever wake up?’ What are those benefits of sleep? Can lack of sleep kill?\n\nSleep To Learn and Perform\nIn a study, participants were asked to learn some facts. One group was allowed to take a nap afterwards, while the other group wasn’t. Later, both groups were again given some new facts to learn. The group which was allowed to take a nap performed 20 percent better at learning new info than the group which didn’t get to sleep.\nOur short term info is stored in a brain region called the Hippocampus, whose storage capacity is small. Sleep frees up space in your brain to learn new information by transferring this info to a long term storage site which is the cortex, which can store huge amounts of information. At the same time, we remember better, since the information is safe in the cortex. Sleep transfers the files and hits the save button. It doesn’t matter whether you’re studying for a history test or trying to perfect a tennis backhand: Sleep will aid your learning. But we don’t need to remember yesterday’s menu or what clothes you wore yesterday, right? Sleep helps you forget such unimportant things. It clears the clutter from your brain. That means, sleep helps you to learn and to forget too.\nOne fun fact: If you tell your brain to remember a particular thing, and then go to sleep, your sleeping brain will selectively choose that thing to transfer and save. How cool is that!\n\n\nLack of Sleep and You\nIn a study, researchers checked the concentration levels of people with 8, 6 ,4 and no hours of sleep for a few days. The first group slept for 8 hours and was the best performer. The second group slept for 6 hours, and it was the second best. The group with 4 hours of sleep was the third. And as we can guess, the group with no sleep performed the worst.\nFor the people who slept less than eight hours, the performance gradually worsened. And this worsening didn’t stop, it never stops. You keep on performing worse and worse each day.\nThe main thing to worry about is not the lack of concentration but rather, it is that we fail to realise that our concentration has dropped. Not a single person in the above experiment accepted the fact that his concentration has dropped. The low levels of concentration become the norm, and we start underperforming.\nLack of sleep has ties with diseases, from heart attacks to diabetes, from cancer to mental disorders. In fact, there is not a single psychiatric disorder where sleep disturbance is not a symptom.\nHere, we’re not talking about extreme cases of sleep deprivation, but routinely getting just 5-6 hours of sleep. Can such sleep deprivation kill you? Yes! Combine sleep deprivation with a setback, and you have a recipe for suicidal thoughts or addictions. Combine sleep deprivation with driving, and you have a recipe for a car accident. The rule of thumb is : If you want to live longer and healthier, do not mess with sleep."
  },
  {
    "objectID": "posts/why-we-sleep/index.html#part-3",
    "href": "posts/why-we-sleep/index.html#part-3",
    "title": "How Good Is Sleep!",
    "section": "Part 3",
    "text": "Part 3\nWe haven’t yet talked about dreams. So what are dreams? How do we dream? Do dreams have a meaning?\n\nHow Do We Dream?\nREM sleep is when you dream. When you enter REM sleep, which is about 5 times every night ( you enter NREM sleep 5 times also), there is a great increase in the activity of some brain areas, while there is a sharp decrease in activity of some other areas.\nThe areas of the brain that show great increase in activity are the ones which are associated with movement, emotions, memory, and visual areas. This is why, when we dream, we dream of things with past experiences or things with strong emotions or we see dreams in great detail.\nAnd the ones that show a great decrease are the ones which control rational thinking. This is why dreams don’t have any connection to reality, as the logical brain is turned off during this period.\n\n\nDo Dreams Have a Meaning?\nWe have myths around saying that dreams have meaning or dreams predict the future. In reality, the dreams do not have any meaning. They have functions but they don’t have meaning.\n\n\nWhy Do We Dream?\nAlthough dreams don’t have meaning, they have functions. Not just one, but multiple ones! To know the first function, the researchers looked at patients with depression. They were depressed due divorces, or break ups. The researchers collected their dream reports for a whole year. The people who reported having dreams which were related to their cause of depression ( due to divorces, etc.), were free of all symptoms. They didn’t have depression anymore. But the people whose dreams weren’t related to their cause, showed a very small change in symptoms. The first function of dreams is that they reduce the intensity of experiences. Have you ever had a scary experience? If you think of it now, you probably won’t feel it intensely. That’s probably because of dreams!\nDue to REM sleep, we are also more accurate in reading facial expressions and emotions in other people. Our Emotional Quotient is at its best when we get our REM sleep.\nWe all have studied the periodic table in school. Dmitri Mendeleev was the person who organised the elements in the periodic table. But he had to fail before he could succeed in organising the elements. He felt that there was some logic, some order behind all the elements in the world. He was so obsessed over the problem that he tried to solve it for years. And every time he tried, he failed. He would have quit, if it was not for a dream. He saw very clearly in his dream, all the elements arranged in a perfect logical order. He woke up immediately and wrote it down. He had solved the mystery of organising elements. We still use the same order even today.\nThat’s what dreams do. In the REM sleep, the brain takes all the information it has acquired, and arranges it in proper shelves. So we can connect, rearrange and understand the information better. All this reflects in creativity; we are more creative if we have healthy REM sleep.\nThis function of REM sleep really blew my mind away: Researchers gave a group of people a few anagrams ( a word where letters are jumbled. Eg: Ltbtoe for Bottle ). First, the group was asked to solve anagrams before they went to sleep. Then the researchers woke them up twice in their NREM sleep and twice in their REM sleep for a very short period, and gave them some other anagrams to solve. when the participants were woken up from REM sleep, they performed up to 30% better than NREM sleep as well as when they were awake. Problem solving is a fascinating function that REM sleep, and dreams perform. The answers will just come naturally to you.\n\n\nCan You Control Your Dreams?\nThere may be some of you who can control your dreams. Most of us cannot control dreams but some of us can. But even the scientists are confused about whether you should or should not control your dreams."
  },
  {
    "objectID": "posts/why-we-sleep/index.html#sleep-tips",
    "href": "posts/why-we-sleep/index.html#sleep-tips",
    "title": "How Good Is Sleep!",
    "section": "Sleep Tips",
    "text": "Sleep Tips\nThis book is an eye- opener that convinces us to close our eyes. Here are a few tips for you to help you close your eyes better:\n\nMake a sleep schedule. Do the same activities before you go to sleep everyday.\nGo out in the sunlight. Your body clock will run on schedule.\nAvoid caffeine and alcohol, at least seven hours before sleep.\nDon’t drink too many fluids and don’t eat a heavy dinner.\nDon’t take a nap after 3 pm.\nExercise but not right before sleep.\nDon’t use your screens at least an hour before sleep.\nTake a hot bath before bed.\nHave a dark bedroom.\nDon’t lie in bed awake. If you can’t sleep, get out of bed and do something that relaxes you (like reading).\n\nI have fallen in love with sleep because of this book. For the first time, I will sleep for a long time without having regrets later!"
  },
  {
    "objectID": "projects/http-server-from-scratch/index.html",
    "href": "projects/http-server-from-scratch/index.html",
    "title": "HTTP Server From Scratch",
    "section": "",
    "text": "Project Overview\nI was always confused about what a “protocol” is and how HTTP actually works. In our application development courses, we used Flask to make web apps, and starting a server was super easy—just a couple of commands. Same with sessions- it was very easy to do, but I never understood it. This confused me to no end: what the hell was really happening behind those commands!? So I decided to build an HTTP server from scratch to satisfy this curiosity.\nThis project is a simple HTTP server built using Python from the ground up without relying on existing frameworks, except the low-level networking libraries. It’s built to explore what servers do, how HTTP works, and how do sessions work.\n\n\nFeatures\n\nAn extensible router that lets you add routes and route-handlers\nSessions and Token management\nMultithreading for handling concurrent requests\nRequest parser and response formatter\nLogging for debugging and maintenance perspective\nAn OOP based design for the server\n\n\n\nTech Stack\n\nLanguage: Python\nModules: socket (for low-level networking), and other built-in libraries like hashlib, logging, and threading\n\n\n\nHow to Run This Project Locally?\nTo run this server locally:\n\nClone the Repository\ngit clone https://github.com/vikrantmehta123/http-server\ncd http-server\nRun the Server\nExecute the main server script:\npython app.py\n\nGitHub Repository\nFor more details, the full source code can be found on GitHub: Source Code"
  },
  {
    "objectID": "projects/screener-scraper/index.html",
    "href": "projects/screener-scraper/index.html",
    "title": "Screener Scraper",
    "section": "",
    "text": "Project Overview\nA few years ago, I came across a book Warren Buffett’s Ground Rules by Jeremy Miller. In the book, we find discussions on how Warren used to invest in his early years. But for me, the real treasure was the Appendix section. There you got a worked out example of how Warren valued a business when he was running his partnership.\nThe computation was simple, really, and might apply to most use cases, but not all. Since then, I used to go on Screener, and meticulously try to value each and every company from a screen (a custom filter for the companies) of mine. The screen itself was inspired from the advice of Benjamin Graham from the book The Intelligent Investor.\nThen I figured, I could use the Python and Selenium to automate this process. Instead of manually going over each company, I’ll let me script shortlist a few companies for me and then I’ll evaluate the shortlisted companies. That’s why I built Screener Scraper.\nScreener Scraper takes as input a screen on Screener, and filters out the free puffs based on the book. This is by no means a definitive valuation, but it saves me a ton of time!\n\n\nTech Stack Used\n\nPython\nLibraries like Selenium and BeautifulSoup\n\n\n\nHow to Use?\n\nEnsure you have provided your cookies and CSRF tokens from Screener in a file named secrets.env.\nWhen prompted, input the URL of your custom screen from Screener.\nThe scraper will go through each of the companies in your screen, annd computes the liquidation valuation for each company.\nA .csv file will be generated containing all the crucial data you need for your analysis, along with the liquidation valuation.\n\nHappy analyzing!\nGitHub Repository\nFor more details, the full source code can be found on GitHub: Source Code"
  },
  {
    "objectID": "posts/peak/index.html",
    "href": "posts/peak/index.html",
    "title": "Mastering Anything With Deliberate Practice",
    "section": "",
    "text": "When we see Virat Kohli score a century, we are tempted to say, “He’s so talented.” But we all know it’s not because of talent but instead, because he practiced. A lot. Not just regular practice but deliberate practice.\nWe are quick to tell someone that he is talented or that she is smart. But it only gives us an excuse to not be good. In their best selling book “Peak: How all of us can achieve extraordinary things”, Robert Pool and Anders Ericsson tell us why experts are experts and how all of us have the same ability to become experts.\nI have divided the summary into three parts. So let’s get started with the first part.\n\n\nThere was a time when even the best scientists in the world believed that adult brains don’t change. They believed that the nerve cells in our brains become rigid as we grow older and are unable to make new connections with other nerve cells. But a study on taxi drivers - not on scientists, nor chess players- but on taxi drivers, shattered that belief!\nResearchers looked at the brain scans of London taxi drivers. London roads, like Mumbai, are extremely complicated. Even the GPS fails to navigate London roads effectively. To become a taxi driver in London, you not only have to remember the tourist places but also all the hospitals, parks, each one of the buildings, shops, and even statues that are just about one feet tall. The job is so difficult that to become a taxi driver you have to take a series of tests that have been dubbed as the world’s most difficult tests. Even with years of rigorous training, about half the taxi drivers fail the tests. When researchers looked at the brain scans of the taxi drivers who passed the tests, they found something very interesting. In their brains, the area that is responsible for a sense of direction and a sense of space, the rear part of the hippocampus, was significantly larger than other people. The more experienced a driver, the larger his posterior hippocampus. On the other hand, the taxi drivers who were just starting the training didn’t show any increase in the size of the hippocampus. This meant that when they studied for the tests, their brain actually grew, which indicates that when we learn something, we are actually creating that ability in our brains!\nEven more interesting is the fact that the neurons in the brain can switch tasks. For example, in blind people, the visual areas of the brain don’t get input from the eyes. Thus, by common sense, they should remain idle for the lifetime. But instead, they start doing tasks that are usually done by other areas of the brain. Isn’t that awesome?\nWhen we start exercising our biceps, they grow. After we stop exercising, they go back to how they were before. The same goes with the brain. We grow our abilities in our brain by practice, but if we stop practicing, the abilities go away.\n\n\n\nA mental representation is the pre-existing knowledge of a skill. It is the mental image, mental feel of the activity. They allow you to do the activity without conscious thought. Everybody has mental representations. If I ask you to think about a cat, you can easily bring to mind the image of the cat. This is a mental representation. Experts have such mental representations in their field, and they are very well developed. When Virat Kohli is batting, he has very little time to analyze where the fielders are, what the length and line of the ball is, and what shot he should play. He can choose the right shot because he knows in his mind how each shot feels, how different shots to different deliveries are played, and he has an intuitive sense of the field placement. He doesn’t have to think to play the correct shot, he just plays it. In other words, he has complex and sophisticated mental representations. The more he plays, the better his representations get. The better his mental representations get, the better he plays. The virtuous cycle goes on! However, if we keep on doing the same thing in the same way, again and again, we are not building better representations. We are worsening them. The way we develop our mental representations is through deliberate practice.\nSo what is deliberate practice? What is motivation? To know the answers, see you in the next part. Till then, try learning a new skill to apply these principles of deliberate practice. And keep reading, bye- bye!"
  },
  {
    "objectID": "posts/peak/index.html#part-1",
    "href": "posts/peak/index.html#part-1",
    "title": "Mastering Anything With Deliberate Practice",
    "section": "",
    "text": "When we see Virat Kohli score a century, we are tempted to say, “He’s so talented.” But we all know it’s not because of talent but instead, because he practiced. A lot. Not just regular practice but deliberate practice.\nWe are quick to tell someone that he is talented or that she is smart. But it only gives us an excuse to not be good. In their best selling book “Peak: How all of us can achieve extraordinary things”, Robert Pool and Anders Ericsson tell us why experts are experts and how all of us have the same ability to become experts.\nI have divided the summary into three parts. So let’s get started with the first part.\n\n\nThere was a time when even the best scientists in the world believed that adult brains don’t change. They believed that the nerve cells in our brains become rigid as we grow older and are unable to make new connections with other nerve cells. But a study on taxi drivers - not on scientists, nor chess players- but on taxi drivers, shattered that belief!\nResearchers looked at the brain scans of London taxi drivers. London roads, like Mumbai, are extremely complicated. Even the GPS fails to navigate London roads effectively. To become a taxi driver in London, you not only have to remember the tourist places but also all the hospitals, parks, each one of the buildings, shops, and even statues that are just about one feet tall. The job is so difficult that to become a taxi driver you have to take a series of tests that have been dubbed as the world’s most difficult tests. Even with years of rigorous training, about half the taxi drivers fail the tests. When researchers looked at the brain scans of the taxi drivers who passed the tests, they found something very interesting. In their brains, the area that is responsible for a sense of direction and a sense of space, the rear part of the hippocampus, was significantly larger than other people. The more experienced a driver, the larger his posterior hippocampus. On the other hand, the taxi drivers who were just starting the training didn’t show any increase in the size of the hippocampus. This meant that when they studied for the tests, their brain actually grew, which indicates that when we learn something, we are actually creating that ability in our brains!\nEven more interesting is the fact that the neurons in the brain can switch tasks. For example, in blind people, the visual areas of the brain don’t get input from the eyes. Thus, by common sense, they should remain idle for the lifetime. But instead, they start doing tasks that are usually done by other areas of the brain. Isn’t that awesome?\nWhen we start exercising our biceps, they grow. After we stop exercising, they go back to how they were before. The same goes with the brain. We grow our abilities in our brain by practice, but if we stop practicing, the abilities go away.\n\n\n\nA mental representation is the pre-existing knowledge of a skill. It is the mental image, mental feel of the activity. They allow you to do the activity without conscious thought. Everybody has mental representations. If I ask you to think about a cat, you can easily bring to mind the image of the cat. This is a mental representation. Experts have such mental representations in their field, and they are very well developed. When Virat Kohli is batting, he has very little time to analyze where the fielders are, what the length and line of the ball is, and what shot he should play. He can choose the right shot because he knows in his mind how each shot feels, how different shots to different deliveries are played, and he has an intuitive sense of the field placement. He doesn’t have to think to play the correct shot, he just plays it. In other words, he has complex and sophisticated mental representations. The more he plays, the better his representations get. The better his mental representations get, the better he plays. The virtuous cycle goes on! However, if we keep on doing the same thing in the same way, again and again, we are not building better representations. We are worsening them. The way we develop our mental representations is through deliberate practice.\nSo what is deliberate practice? What is motivation? To know the answers, see you in the next part. Till then, try learning a new skill to apply these principles of deliberate practice. And keep reading, bye- bye!"
  },
  {
    "objectID": "posts/peak/index.html#part-2",
    "href": "posts/peak/index.html#part-2",
    "title": "Mastering Anything With Deliberate Practice",
    "section": "Part 2",
    "text": "Part 2\n\nDeliberate Practice\nDeliberate practice does not mean doing the same thing over and over. Deliberate practice has some typical features. Let’s again take the example of Virat Kohli. His practice sessions will usually involve these typical features of deliberate practice. He knows what he’s going to work on, so he has specific and well- defined goals. He has his coach by his side, so he is getting continuous feedback. He pays full attention to the practice, so he has a very high level of focus. The practice sessions usually challenge him, they make him do something different, which means they push him out of his comfort zone. He is modifying his previous knowledge of strokes, so he is building better mental representations.\nAs we can guess from the above characteristics, deliberate practice is not fun. Often, deliberate practice is not the performance, but solitary practice done for improvement. For example, playing chess matches won’t improve your chess skills, but analyzing positions or analyzing games played by the grandmasters will indeed improve your skill. To become a true expert in any field, deliberate practice needs to be sustained for years, if not decades. If you are not really motivated to do what you are doing, you are not going to be able to keep up with the deliberate practice.\n\n\nThe Puzzle of Motivation\nSince deliberate practice involves a lot of solitary effort, it is crucial that we know how to maintain our motivation. The most important motivation has to be a strong desire to improve itself. Parents, friends who believe that you can succeed play a huge role. Even a group of people who are in a similar position can help to keep your motivation. When we want to keep our motivation, we have to design our environment in a way that supports our goals. For example, as a reader, I need to keep my reading desk free from all the distractions. If a phone is buzzing every five minutes on my desk, I won’t be able to keep up with my reading. And lastly, our practice sessions need to be short in duration ( about an hour) because the longer the session, the more difficult it is to maintain motivation.\n\n\nDeliberate Practice in Everyday Life\nDeliberate practice isn’t just for those who want to be professional athletes or musicians, it’s for everybody. If you want to improve a skill as a hobby or for your professional work, deliberate practice will work just as well.\nFirst and foremost, there is a need for a good teacher who’ll teach you the basic mental representations. A good teacher has some basic knowledge of the skill, he keeps you motivated to pursue the skill, and he gives feedback for your improvement.\nHowever, when learning a skill, there comes a time when we feel stuck. We don’t improve as fast or we stop improving altogether. This is the OK plateau; where we reach an acceptable level of performance. The best way to get past this stage is to challenge yourself in a different way. Another way to cross the OK Plateau is to raise the difficulty level a little, but not a lot. In doing so, we can know what our weaknesses are and what we can do to improve them. For example, assume that you play tennis and you are stuck on the OK plateau. Then, try playing an opponent who is a little better than you the next time. He can take advantage of your weaknesses, which will let you know what you need to improve. So you can specifically work on that stroke. Often, improving that particular stroke will lead to an overall improvement in your tennis.\nWe haven’t discussed talent yet. So what is talent? Does talent have a role in success? How much can we improve with practice? To know the answers, see you in the next part. Till then, keep applying deliberate practice to your job or your hobby. And keep reading. Bye- bye!"
  },
  {
    "objectID": "posts/peak/index.html#part-3",
    "href": "posts/peak/index.html#part-3",
    "title": "Mastering Anything With Deliberate Practice",
    "section": "Part 3",
    "text": "Part 3\n\nHow Do Experts Become Experts?\nThe first step is, of course, interest. Every expert starts his journey by becoming interested in the skill. A future grandmaster might have been given chess pieces as a toy in his childhood or, as an adult, he might have a friend who talks a lot about chess.\nThe interest then becomes a little serious. This is the second stage. It is now that the future expert looks for a coach. In this stage, the expert is introduced to deliberate practice for the first time. In this stage, the future expert builds the skill necessary to be amongst the best.\nThen we move on to the final stage of commitment. By this stage, the future expert is committed to be the best he can be. He seeks out the best teachers and prioritizes the skill above everything else.\nBut this journey is not reserved for those who are talented. Any one of us can take this journey if we know what talent is and what role it has in this journey.\n\n\nWhat is Talent?\nTalent is defined as an innate ability to do something. The role of such innate ability is much smaller than people think. Usually, in schools, we see some kids who are better than others in some subject, say math. We assume that they are smart and this smartness will continue even in the later part of their life.\nBut in a very interesting study, researchers first tested the intelligence of elite chess players. Then, they asked the players to keep journals about their practice routines for the next six weeks. After these six weeks, their chess skills were tested. There was no relationship between intelligence and chess skills, even though chess is considered the supreme test of intelligence! The only factor that made the difference was the amount of deliberate practice. The more they practiced, the better their skills were. Talent simply didn’t matter at the elite stage! However, when researchers performed the same experiment with amateur chess players, there was indeed a relationship between intelligence and chess skills. The players with higher intelligence had better chess skills. But this relationship went on diminishing as their level of chess skill improved. More surprisingly, at the elite level, the players with higher intelligence scores seemed to perform worse. Perhaps, they felt they were too smart to be needing hard work.\nThis means, talent can help us learn the basics quickly. Thus, in schools, some kids do better than others; because they are beginners! Once they get to higher education, this advantage is easily lost.\nWhen it comes to expert performance, the only thing that matters is the amount of deliberate practice. It doesn’t matter how talented you are, but if you don’t practice deliberately, you are going to be just average.\n\n\nThe Greatest Gift\nIn the 21st century, jobs will keep changing rapidly. The young kids will need to keep learning new skills to survive. And the confidence that they can learn anything is the greatest gift we can give them. Deliberate practice is a way of knowing that we can learn anything, that there are no limits to our capacities; all you need to do is to put effort in it."
  },
  {
    "objectID": "dsa/index.html",
    "href": "dsa/index.html",
    "title": "Leet Code Grind",
    "section": "",
    "text": "HELLO Everyone!"
  }
]