[
  {
    "objectID": "projects/wavenet/index.html",
    "href": "projects/wavenet/index.html",
    "title": "Wavenet",
    "section": "",
    "text": "Project Overview\nI enjoy building things from scratch. In this project, I tried to build the Wavenet like architecture for a language modeling task from scratch. For the most part, I tried to follow Andrej Karpathy’s Tutorial on YouTube, along with certain additional notes that I took along the way to understand PyTorch’s broadcasting and batched matrix multiplication.\nIn this Jupyter notebook, I trained a character level language model that predicts the next character based on a context of eight characters. I implemented the neural network modules from scratch, without using PyTorch, except for tensor operations. In this architecture, the flatten layers hierarchically fuse character embeddings along the layers and achieve a decent loss.\nThe dataset used for the project is a names dataset, which was what was used in the YouTube tutorial as well.\n\n\nTech Stack Used\n\nPython Jupyter Notebooks\nPyTorch\n\nGitHub Repository\nFor more details, the full source code can be found on GitHub: Source Code"
  },
  {
    "objectID": "projects/late-chunking/index.html",
    "href": "projects/late-chunking/index.html",
    "title": "Implementing Late Chunking in PyTorch",
    "section": "",
    "text": "Project Overview\nIn this project, I implemented the research paper: Late Chunking:Contextual Chunk Embeddings Using Long-Context Embedding Models.1\nAs my understanding of the paper goes, the idea of it is as follows:\nWhen storing embeddings of chunks of textual data in a vector database (for use cases like RAG applications), it is often more efficient and useful to store smaller chunks. While they are efficient, the information in those chunks is totally isolated from other chunks. As a result, the information across chunks is lost due to this process.\nOn the other hand, we have long context embedding models which can take large textual documents and embed them as one chunk. As the entire document is being treated as a single chunk, there is not the issue of the information being lost across chunks. However, these long context embeddings have their own issues of inefficiency and loss of information, due to phenomena like lost in the middle.\nSo, late chunking offers the best of both worlds: embed using long context model, but chunk as if they are being embedded using small context models. It achieves this using the following steps:\n\nEmbed the entire long document using long context model.\nDefine a size that you want your chunk to have.\nPool only this subset of embedding vectors to get a representation of a much smaller chunk than what was initially embedded.\n\nUsing this, we hope to maintain the entire information across chunks as well, while keeping a manageable chunk size.\n\n\nTech Stack:\n\nPyTorch\nHuggingFace: I have used NovaSearch/stella_en_400M_v5 model as a long context model.\n\nYou can find the source code of my implementation here.\n\n\n\nReferences:\n\nLate Chunking: Contextual Chunk Embeddings Using Long-Context Embedding Models\nImage Reference: Late Chunking Article From JinaAI"
  },
  {
    "objectID": "projects/logstash-parser/index.html",
    "href": "projects/logstash-parser/index.html",
    "title": "Logstash Parser",
    "section": "",
    "text": "Project Overview\nIn this project, I wanted to peel away one layer of abstraction from the way we use programming languages. Instead of writing code in Python and not worrying about anything below that, I want to go one step lower and figure out what happens under-the-hood. In this project, I wrote a parser that uses Python to parse a Logstash pipeline into a neat Abstract Syntax Tree objects.\nLogstash is an open-source data processing pipeline that is commonly used to parse logs. Logstash pipelines have a specific structure where the users can define inputs, outputs, and the processing filters. The parser parses a logstash file and constructs an easily-traversable Abstract Syntax Tree for the pipeline. This tree can then be manipulated, analyzed, and improved as user desires.\nFor the purposes of this project, I focused only on the Filter plugins.\n\n\nFeatures\n\nLogstash syntax can be easily accessed and manipulated through Python objects such as Plugin, Expression, etc.\nEach object has a method to_logstash which reconstructs the corresponding logstash configuration based on the AST.\n\n\n\nTech Stack\n\nLanguage: Python\nModules: PyParsing\n\nGitHub Repository\nFor more details, the full source code can be found on GitHub: Source Code\n\n\nReferences\n\nTomasKoutek: I relied heavily on this existing parser to arrive at the Context Free Grammar definitions."
  },
  {
    "objectID": "projects/http-server-from-scratch/index.html",
    "href": "projects/http-server-from-scratch/index.html",
    "title": "HTTP Server From Scratch",
    "section": "",
    "text": "Project Overview\nI was always confused about what a “protocol” is and how HTTP actually works. In our application development courses, we used Flask to make web apps, and starting a server was super easy—just a couple of commands. Same with sessions- it was very easy to do, but I never understood it. This confused me to no end: what the hell was really happening behind those commands!? So I decided to build an HTTP server from scratch to satisfy this curiosity.\nThis project is a simple HTTP server built using Python from the ground up without relying on existing frameworks, except the low-level networking libraries. It’s built to explore what servers do, how HTTP works, and how do sessions work.\n\n\nFeatures\n\nAn extensible router that lets you add routes and route-handlers\nSessions and Token management\nMultithreading for handling concurrent requests\nRequest parser and response formatter\nLogging for debugging and maintenance perspective\nAn OOP based design for the server\n\n\n\nTech Stack\n\nLanguage: Python\nModules: socket (for low-level networking), and other built-in libraries like hashlib, logging, and threading\n\n\n\nHow to Run This Project Locally?\nTo run this server locally:\n\nClone the Repository\ngit clone https://github.com/vikrantmehta123/http-server\ncd http-server\nRun the Server\nExecute the main server script:\npython app.py\n\nGitHub Repository\nFor more details, the full source code can be found on GitHub: Source Code"
  },
  {
    "objectID": "posts/rajendra-bagwe/index.html",
    "href": "posts/rajendra-bagwe/index.html",
    "title": "Daring to Execute",
    "section": "",
    "text": "‘My childhood was very simple. I grew up in an environment where a government job, like my Dad’s, was thought of as prestigious. As a child, I too wanted to be like my father.’\nRajendra was born and raised in Mumbai, where he completed his matriculation and his college degree.\n\n‘After my matriculation, I got into Jai Hind college, an esteemed junior college at the time. There, I met a lot of rich but humble kids, and that stirred something. I started thinking, “Rich doesn’t necessarily mean spoiled, as was the common belief. I, too, can be rich and like them.” So there! There I started deviating from the conventional mould, you know, get good grades, then a job, then get married, and your life is all set. The Jai Hind College made me think differently.’\n\nThis different thinking led him to dabble in business in his engineering years.\n\n‘Me and my two friends, Devendra Bapat and Amol Chitnis, started thinking that we should get some business experience.’\n\nEach of them had a relative who ran a business. They all asked for jobs and worked in those businesses for a while. Soon enough, they realised that business means manufacturing, and manufacturing requires space. (In those days, there weren’t any software companies. So there wasn’t the concept of ‘offices’. There were only workshops.)\nAfter their graduation, all three landed jobs easily. Rajendra took up a job in Mahindra. But the trio wanted to do something different. Something out of the mould.\n\n‘We used to meet after our jobs in a park and discuss our ideas. But we didn’t know what exactly we wanted to do. We just knew we wanted to do business, and doing business meant we’d need space. So we just sent an application to MIDC (Maharashtra Industrial Development Corporation) stating that we required a piece of land to start our business.’\n\nA year later, a letter came from the MIDC. MIDC was allocating them a plot of land. They were surprised to see the letter – the trio had forgotten about their application!\nMIDC had offered them a choice – either a plot at Ambernath or a plot in Nashik.\n\n‘The plot in Ambernath was out of our pocket’s reach, so we came to Nashik. Till then, we didn’t even know where Nashik was.’\n\nThey came, but did they conquer?\nNot so fast!\nThe MIDC officer in Nashik said that they didn’t have any plots to offer! They showed him the letter but to no avail. Luckily again, the trio had a friend who knew how to ‘manage’ such officers, which he did. The officer, then, showed them four plots.\n\n‘We were inexperienced enough to know nothing about property. So we just pointed to a plot and said, “We want that one.” He said okay but asked us to pay 18,000₹ immediately.’\n\nThey had saved enough stipend from their jobs to buy the plot. They bought it. Still, they had no idea what to do in that plot!\n\n‘We went back to Mumbai, got busy with our jobs, and conveniently forgot about our plot.’\n\nA year later, MIDC reminded them again.\n\n‘We received a notice, saying that if we didn’t construct anything on the plot, it’ll be sealed.’\n\nBy then, the three of them had collectively saved a decent sum of 1 lakh Rupees.\n\n‘We had 1 lakh and we took a loan of 2 lakh rupees to construct a tiny little building of a thousand sq.ft.’\n\nSurely now they knew what they were doing, right? Nope, they still didn’t know why they’d constructed the building! Still, they didn’t know what business they were going to do. The only thing they knew was that they’d do something related to engineering. So they named the company ‘Reliable Engineers.’\nMeanwhile, Rajendra was transferred to Nashik. Now, he would be close to their ‘company.’\n\n‘I told my boss at Mahindra that I wanted to quit and start my own business. I asked him to give us business. He agreed. He talked to a company called Spicer India about giving us business.’\n\n\n‘Spicer gave us a job of dismantling rejected clutch plates and asked us if we’d do it.’\n\nBasically, the job was to sort out reusable waste from non-reusable waste of the automotive industry. But they never said no.\n\n‘We said we’d do it, which we did. After that, they asked if we’d make washers. We said we’d do that too, which we did. Then, a relationship started.’\n\nOne such enquiry from Spicer India was to make a spring, which, again the trio said yes to. Little did they know how tough a challenge it was going to be.\n\n‘We struggled for six hard months. In these six months, we learned many elements of engineering – real engineering – something very different from our college education. Finally, we made it. In fact, before us, Spicer India was taking that very same spring from Germany at a cost of 8 Rupees a piece. We did it in 1.8 Rupees, and the quality was just as good as the Germans.’\n\nThen the reliability of the Reliable Engineers grew, and a lot of business started coming from Spicer.\n\n‘We did any work we were offered and then somewhere along the road, we decided a direction that we are going to do sheet metal pressing.’\n\nTheir direction was set, and this time, even fortune favored them.\nTill then, Mahindra & Mahindra was doing all the sheet metal pressing, but it now decided that they wanted to offload it to suppliers, which meant that the field was open. He who grabbed the chance had tremendous opportunity for growth. Speed was what mattered, and speed was what they had.\n\n‘We knew that if we wanted to grow our business, we’d need bigger and better machinery. To buy it, I went abroad for the first time and landed in Germany.’\n\nThe Germans were honest in their deal. They showed him the machines in and out.\n\n‘I knew nothing about machines either. The Germans said, “We have three machines to offer. Which one do you want?” I simply pointed my finger to one and said, “I want that one.”’\n\nIt was a ridiculously big gamble. The total cost of the machine, and that too, of a 50-year-old machine, was more than their annual turnover.\n\n‘It seems madness if we think about it now.’\n\nHad the machine not worked, they were doomed. Luckily, it worked, but not without a twist.\n\n‘The machine was HUGE. It was supposed to come in nine containers. Eight came, one didn’t. It got stuck somewhere in the Western Ghats. We somehow got it back, assembled the machine, and it worked. It worked! I’ll never forget the relief when the machine first made some noise, any noise!’\n\nFrom then on, Reliable Autotech has slowly but surely conquered the market of sheet metal pressing.\nToday, they are amongst the top five manufacturers in the country with more than a thousand employees at seven locations and a turnover of more than 600 crore Rupees per year.\nRajendra’s story appears lucky. But he was not lucky – he was brave. Brave enough to stay the course, to execute, and to allow luck to present itself. We too can be as lucky as Rajendra, but we have to be brave like him. We have to dare to take the risk of execution. And life rewards not those who dare to plan but those who dare to execute, even if they’re without a plan. And Rajendra did dare to execute!\n\nAdvice for the youth:\n\n‘We grew because we took risks. I mean, risk was the main theme for us. So, take risks.’ He chuckles. ‘You know, even risk-taking has a formula. Knowledge/ignorance = Risk. The closer you get the ratio to 1:1, the smaller the risk. Minimize the risks, but take them.’\n\n\n‘Do what you like, yaar. And try to get better each day. Success means nothing but a step towards your goal. Set goals and try to inch your way closer each day. That’s it.’"
  },
  {
    "objectID": "posts/why-we-sleep/index.html",
    "href": "posts/why-we-sleep/index.html",
    "title": "How Good Is Sleep!",
    "section": "",
    "text": "What if someone told you that there exists a pill that is for free and it will make you live long, and be healthy and smart? I would jump right at it! But that pill is always with us and it is for free. It’s called sleep.\nIn this post, I have summarized the book and the key learnings from the book. You can also listen to the audio summary on the Booklet app. Be sure to check out sleep tips."
  },
  {
    "objectID": "posts/why-we-sleep/index.html#part-1",
    "href": "posts/why-we-sleep/index.html#part-1",
    "title": "How Good Is Sleep!",
    "section": "Part 1",
    "text": "Part 1\n\nWhy Do We Sleep?\nHow do we know that it’s time to sleep? There are two reasons: Circadian Rhythm and Sleep Pressure.\nYour body has its own clock. It tells you when to do what. It will tell you when to sleep, when to eat, when to drink. This is called the circadian rhythm, which is different for everyone. That’s why there are people who like staying up late at night and wake up late, and also those who go to bed early and get up early. None of the two is wrong, they’re just different.\nThe other half of the answer is something called Sleep Pressure. With each wakeful moment, a chemical called ‘ Adenosine’ gets accumulated in your brain. When enough Adenosine gets accumulated, you feel sleepy. This is called ‘ Sleep Pressure.’ When you are awake for the whole day( 12 to 16 hours), there is enough Adenosine to make you sleepy. And a sleep of eight hours is good enough to remove this Adenosine from the brain.\nWhen the circadian rhythm and sleep pressure coordinate, you feel a strong urge to sleep. That’s why we go to bed every night.\n\n\nHow Do We Sleep?\nResearchers carefully observed sleeping babies ( cute, right?). What they found was that their eyeballs don’t remain still all the time. There are periods when the eyeballs move around rapidly, and there are periods when the eyeballs remain still. This happens with adults too. The researchers named these two periods as REM sleep ( Rapid Eye Movement) which is when you dream, and NREM ( Non Rapid Eye Movement) which is when you are in deep sleep.\nThe brain waves in REM are no different from your brain waves right now. It is when your body is paralysed, but your brain waves show very high activity. And because your body is paralysed, you don’t act on your dreams.\n\n\nWho Sleeps?\nEvery organism on the planet that has a lifespan of more than a few days, enjoys sleep or sleep-like activity, right from unicellular bacteria to giants like whales. There are fascinating stories in the animal kingdom about sleep. Let’s take dolphins as an example. They need to float in water, and at the same time, they need to keep an eye out for predators. How would they sleep? Their brain takes turns in sleeping. First, one half of the brain falls into deep NREM sleep. After it has had a healthy sleep, the other half of the brain sleeps, which means they can function good enough with just one brain. And, when they are awake, both halves of their brain work in perfect coordination. Imagine having that as a superpower!"
  },
  {
    "objectID": "posts/why-we-sleep/index.html#part-2",
    "href": "posts/why-we-sleep/index.html#part-2",
    "title": "How Good Is Sleep!",
    "section": "Part 2",
    "text": "Part 2\nSleep offers so many benefits, from health to memory, from immunity to performance, that the question to ask is not ‘ Why do we sleep?’ But rather ‘ Why did we ever wake up?’ What are those benefits of sleep? Can lack of sleep kill?\n\nSleep To Learn and Perform\nIn a study, participants were asked to learn some facts. One group was allowed to take a nap afterwards, while the other group wasn’t. Later, both groups were again given some new facts to learn. The group which was allowed to take a nap performed 20 percent better at learning new info than the group which didn’t get to sleep.\nOur short term info is stored in a brain region called the Hippocampus, whose storage capacity is small. Sleep frees up space in your brain to learn new information by transferring this info to a long term storage site which is the cortex, which can store huge amounts of information. At the same time, we remember better, since the information is safe in the cortex. Sleep transfers the files and hits the save button. It doesn’t matter whether you’re studying for a history test or trying to perfect a tennis backhand: Sleep will aid your learning. But we don’t need to remember yesterday’s menu or what clothes you wore yesterday, right? Sleep helps you forget such unimportant things. It clears the clutter from your brain. That means, sleep helps you to learn and to forget too.\nOne fun fact: If you tell your brain to remember a particular thing, and then go to sleep, your sleeping brain will selectively choose that thing to transfer and save. How cool is that!\n\n\nLack of Sleep and You\nIn a study, researchers checked the concentration levels of people with 8, 6 ,4 and no hours of sleep for a few days. The first group slept for 8 hours and was the best performer. The second group slept for 6 hours, and it was the second best. The group with 4 hours of sleep was the third. And as we can guess, the group with no sleep performed the worst.\nFor the people who slept less than eight hours, the performance gradually worsened. And this worsening didn’t stop, it never stops. You keep on performing worse and worse each day.\nThe main thing to worry about is not the lack of concentration but rather, it is that we fail to realise that our concentration has dropped. Not a single person in the above experiment accepted the fact that his concentration has dropped. The low levels of concentration become the norm, and we start underperforming.\nLack of sleep has ties with diseases, from heart attacks to diabetes, from cancer to mental disorders. In fact, there is not a single psychiatric disorder where sleep disturbance is not a symptom.\nHere, we’re not talking about extreme cases of sleep deprivation, but routinely getting just 5-6 hours of sleep. Can such sleep deprivation kill you? Yes! Combine sleep deprivation with a setback, and you have a recipe for suicidal thoughts or addictions. Combine sleep deprivation with driving, and you have a recipe for a car accident. The rule of thumb is : If you want to live longer and healthier, do not mess with sleep."
  },
  {
    "objectID": "posts/why-we-sleep/index.html#part-3",
    "href": "posts/why-we-sleep/index.html#part-3",
    "title": "How Good Is Sleep!",
    "section": "Part 3",
    "text": "Part 3\nWe haven’t yet talked about dreams. So what are dreams? How do we dream? Do dreams have a meaning?\n\nHow Do We Dream?\nREM sleep is when you dream. When you enter REM sleep, which is about 5 times every night ( you enter NREM sleep 5 times also), there is a great increase in the activity of some brain areas, while there is a sharp decrease in activity of some other areas.\nThe areas of the brain that show great increase in activity are the ones which are associated with movement, emotions, memory, and visual areas. This is why, when we dream, we dream of things with past experiences or things with strong emotions or we see dreams in great detail.\nAnd the ones that show a great decrease are the ones which control rational thinking. This is why dreams don’t have any connection to reality, as the logical brain is turned off during this period.\n\n\nDo Dreams Have a Meaning?\nWe have myths around saying that dreams have meaning or dreams predict the future. In reality, the dreams do not have any meaning. They have functions but they don’t have meaning.\n\n\nWhy Do We Dream?\nAlthough dreams don’t have meaning, they have functions. Not just one, but multiple ones! To know the first function, the researchers looked at patients with depression. They were depressed due divorces, or break ups. The researchers collected their dream reports for a whole year. The people who reported having dreams which were related to their cause of depression ( due to divorces, etc.), were free of all symptoms. They didn’t have depression anymore. But the people whose dreams weren’t related to their cause, showed a very small change in symptoms. The first function of dreams is that they reduce the intensity of experiences. Have you ever had a scary experience? If you think of it now, you probably won’t feel it intensely. That’s probably because of dreams!\nDue to REM sleep, we are also more accurate in reading facial expressions and emotions in other people. Our Emotional Quotient is at its best when we get our REM sleep.\nWe all have studied the periodic table in school. Dmitri Mendeleev was the person who organised the elements in the periodic table. But he had to fail before he could succeed in organising the elements. He felt that there was some logic, some order behind all the elements in the world. He was so obsessed over the problem that he tried to solve it for years. And every time he tried, he failed. He would have quit, if it was not for a dream. He saw very clearly in his dream, all the elements arranged in a perfect logical order. He woke up immediately and wrote it down. He had solved the mystery of organising elements. We still use the same order even today.\nThat’s what dreams do. In the REM sleep, the brain takes all the information it has acquired, and arranges it in proper shelves. So we can connect, rearrange and understand the information better. All this reflects in creativity; we are more creative if we have healthy REM sleep.\nThis function of REM sleep really blew my mind away: Researchers gave a group of people a few anagrams ( a word where letters are jumbled. Eg: Ltbtoe for Bottle ). First, the group was asked to solve anagrams before they went to sleep. Then the researchers woke them up twice in their NREM sleep and twice in their REM sleep for a very short period, and gave them some other anagrams to solve. when the participants were woken up from REM sleep, they performed up to 30% better than NREM sleep as well as when they were awake. Problem solving is a fascinating function that REM sleep, and dreams perform. The answers will just come naturally to you.\n\n\nCan You Control Your Dreams?\nThere may be some of you who can control your dreams. Most of us cannot control dreams but some of us can. But even the scientists are confused about whether you should or should not control your dreams."
  },
  {
    "objectID": "posts/why-we-sleep/index.html#sleep-tips",
    "href": "posts/why-we-sleep/index.html#sleep-tips",
    "title": "How Good Is Sleep!",
    "section": "Sleep Tips",
    "text": "Sleep Tips\nThis book is an eye- opener that convinces us to close our eyes. Here are a few tips for you to help you close your eyes better:\n\nMake a sleep schedule. Do the same activities before you go to sleep everyday.\nGo out in the sunlight. Your body clock will run on schedule.\nAvoid caffeine and alcohol, at least seven hours before sleep.\nDon’t drink too many fluids and don’t eat a heavy dinner.\nDon’t take a nap after 3 pm.\nExercise but not right before sleep.\nDon’t use your screens at least an hour before sleep.\nTake a hot bath before bed.\nHave a dark bedroom.\nDon’t lie in bed awake. If you can’t sleep, get out of bed and do something that relaxes you (like reading).\n\nI have fallen in love with sleep because of this book. For the first time, I will sleep for a long time without having regrets later!"
  },
  {
    "objectID": "posts/first-project-using-fastai/index.html",
    "href": "posts/first-project-using-fastai/index.html",
    "title": "Building a Digit Classifier From Scratch",
    "section": "",
    "text": "This is my first time building a deep learning model from scratch. Before this, I had not tried it, and I wasn’t sure where to start. But thanks to Jeremy Howard’s Practical Deep Learning for Coders course, I gave it a shot and built my first deep learning model- a digit classifier. His course also encouraged me to share what I learn with others.\nIn this blog post, I’ll share how I built a simple neural network using FastAI and PyTorch. I’ll walk through how I prepared the data, built the model, and trained it. I hope my experience helps others who are also trying to build their first model."
  },
  {
    "objectID": "posts/first-project-using-fastai/index.html#the-model-achieves-about-87-accuracy-for-my-first-model-not-bad-at-all",
    "href": "posts/first-project-using-fastai/index.html#the-model-achieves-about-87-accuracy-for-my-first-model-not-bad-at-all",
    "title": "Building a Digit Classifier From Scratch",
    "section": "The model achieves about 87% accuracy! For my first model, not bad at all!",
    "text": "The model achieves about 87% accuracy! For my first model, not bad at all!\n\nFinal Thoughts\nBuilding this model was much more helpful than simply watching tutorials. There’s a great room for improvement on this model, like increasing the complexity of the model, exploring errors, or trying a different architecture. The possibilities to experiment are endless, and I hope to continue experimenting!\nIf you’re reading this and thinking about building your own first model, it’s worth it! Happy coding! ✌️\nP.S. Take a look at FastAI’s course: Practical Deep Learning for Coders. It’s truly one of a kind!"
  },
  {
    "objectID": "posts/peak/index.html",
    "href": "posts/peak/index.html",
    "title": "Master Anything With Deliberate Practice",
    "section": "",
    "text": "When we see Virat Kohli score a century, we are tempted to say, “He’s so talented.” But we all know it’s not because of talent but instead, because he practiced. A lot. Not just regular practice but deliberate practice.\nWe are quick to tell someone that he is talented or that she is smart. But it only gives us an excuse to not be good. In their best selling book “Peak: How all of us can achieve extraordinary things”, Robert Pool and Anders Ericsson tell us why experts are experts and how all of us have the same ability to become experts.\nI have divided the summary into three parts. So let’s get started with the first part.\n\n\nThere was a time when even the best scientists in the world believed that adult brains don’t change. They believed that the nerve cells in our brains become rigid as we grow older and are unable to make new connections with other nerve cells. But a study on taxi drivers - not on scientists, nor chess players- but on taxi drivers, shattered that belief!\nResearchers looked at the brain scans of London taxi drivers. London roads, like Mumbai, are extremely complicated. Even the GPS fails to navigate London roads effectively. To become a taxi driver in London, you not only have to remember the tourist places but also all the hospitals, parks, each one of the buildings, shops, and even statues that are just about one feet tall. The job is so difficult that to become a taxi driver you have to take a series of tests that have been dubbed as the world’s most difficult tests. Even with years of rigorous training, about half the taxi drivers fail the tests. When researchers looked at the brain scans of the taxi drivers who passed the tests, they found something very interesting. In their brains, the area that is responsible for a sense of direction and a sense of space, the rear part of the hippocampus, was significantly larger than other people. The more experienced a driver, the larger his posterior hippocampus. On the other hand, the taxi drivers who were just starting the training didn’t show any increase in the size of the hippocampus. This meant that when they studied for the tests, their brain actually grew, which indicates that when we learn something, we are actually creating that ability in our brains!\nEven more interesting is the fact that the neurons in the brain can switch tasks. For example, in blind people, the visual areas of the brain don’t get input from the eyes. Thus, by common sense, they should remain idle for the lifetime. But instead, they start doing tasks that are usually done by other areas of the brain. Isn’t that awesome?\nWhen we start exercising our biceps, they grow. After we stop exercising, they go back to how they were before. The same goes with the brain. We grow our abilities in our brain by practice, but if we stop practicing, the abilities go away.\n\n\n\nA mental representation is the pre-existing knowledge of a skill. It is the mental image, mental feel of the activity. They allow you to do the activity without conscious thought. Everybody has mental representations. If I ask you to think about a cat, you can easily bring to mind the image of the cat. This is a mental representation. Experts have such mental representations in their field, and they are very well developed. When Virat Kohli is batting, he has very little time to analyze where the fielders are, what the length and line of the ball is, and what shot he should play. He can choose the right shot because he knows in his mind how each shot feels, how different shots to different deliveries are played, and he has an intuitive sense of the field placement. He doesn’t have to think to play the correct shot, he just plays it. In other words, he has complex and sophisticated mental representations. The more he plays, the better his representations get. The better his mental representations get, the better he plays. The virtuous cycle goes on! However, if we keep on doing the same thing in the same way, again and again, we are not building better representations. We are worsening them. The way we develop our mental representations is through deliberate practice.\nSo what is deliberate practice? What is motivation? To know the answers, see you in the next part. Till then, try learning a new skill to apply these principles of deliberate practice. And keep reading, bye- bye!"
  },
  {
    "objectID": "posts/peak/index.html#part-1",
    "href": "posts/peak/index.html#part-1",
    "title": "Master Anything With Deliberate Practice",
    "section": "",
    "text": "When we see Virat Kohli score a century, we are tempted to say, “He’s so talented.” But we all know it’s not because of talent but instead, because he practiced. A lot. Not just regular practice but deliberate practice.\nWe are quick to tell someone that he is talented or that she is smart. But it only gives us an excuse to not be good. In their best selling book “Peak: How all of us can achieve extraordinary things”, Robert Pool and Anders Ericsson tell us why experts are experts and how all of us have the same ability to become experts.\nI have divided the summary into three parts. So let’s get started with the first part.\n\n\nThere was a time when even the best scientists in the world believed that adult brains don’t change. They believed that the nerve cells in our brains become rigid as we grow older and are unable to make new connections with other nerve cells. But a study on taxi drivers - not on scientists, nor chess players- but on taxi drivers, shattered that belief!\nResearchers looked at the brain scans of London taxi drivers. London roads, like Mumbai, are extremely complicated. Even the GPS fails to navigate London roads effectively. To become a taxi driver in London, you not only have to remember the tourist places but also all the hospitals, parks, each one of the buildings, shops, and even statues that are just about one feet tall. The job is so difficult that to become a taxi driver you have to take a series of tests that have been dubbed as the world’s most difficult tests. Even with years of rigorous training, about half the taxi drivers fail the tests. When researchers looked at the brain scans of the taxi drivers who passed the tests, they found something very interesting. In their brains, the area that is responsible for a sense of direction and a sense of space, the rear part of the hippocampus, was significantly larger than other people. The more experienced a driver, the larger his posterior hippocampus. On the other hand, the taxi drivers who were just starting the training didn’t show any increase in the size of the hippocampus. This meant that when they studied for the tests, their brain actually grew, which indicates that when we learn something, we are actually creating that ability in our brains!\nEven more interesting is the fact that the neurons in the brain can switch tasks. For example, in blind people, the visual areas of the brain don’t get input from the eyes. Thus, by common sense, they should remain idle for the lifetime. But instead, they start doing tasks that are usually done by other areas of the brain. Isn’t that awesome?\nWhen we start exercising our biceps, they grow. After we stop exercising, they go back to how they were before. The same goes with the brain. We grow our abilities in our brain by practice, but if we stop practicing, the abilities go away.\n\n\n\nA mental representation is the pre-existing knowledge of a skill. It is the mental image, mental feel of the activity. They allow you to do the activity without conscious thought. Everybody has mental representations. If I ask you to think about a cat, you can easily bring to mind the image of the cat. This is a mental representation. Experts have such mental representations in their field, and they are very well developed. When Virat Kohli is batting, he has very little time to analyze where the fielders are, what the length and line of the ball is, and what shot he should play. He can choose the right shot because he knows in his mind how each shot feels, how different shots to different deliveries are played, and he has an intuitive sense of the field placement. He doesn’t have to think to play the correct shot, he just plays it. In other words, he has complex and sophisticated mental representations. The more he plays, the better his representations get. The better his mental representations get, the better he plays. The virtuous cycle goes on! However, if we keep on doing the same thing in the same way, again and again, we are not building better representations. We are worsening them. The way we develop our mental representations is through deliberate practice.\nSo what is deliberate practice? What is motivation? To know the answers, see you in the next part. Till then, try learning a new skill to apply these principles of deliberate practice. And keep reading, bye- bye!"
  },
  {
    "objectID": "posts/peak/index.html#part-2",
    "href": "posts/peak/index.html#part-2",
    "title": "Master Anything With Deliberate Practice",
    "section": "Part 2",
    "text": "Part 2\n\nDeliberate Practice\nDeliberate practice does not mean doing the same thing over and over. Deliberate practice has some typical features. Let’s again take the example of Virat Kohli. His practice sessions will usually involve these typical features of deliberate practice. He knows what he’s going to work on, so he has specific and well- defined goals. He has his coach by his side, so he is getting continuous feedback. He pays full attention to the practice, so he has a very high level of focus. The practice sessions usually challenge him, they make him do something different, which means they push him out of his comfort zone. He is modifying his previous knowledge of strokes, so he is building better mental representations.\nAs we can guess from the above characteristics, deliberate practice is not fun. Often, deliberate practice is not the performance, but solitary practice done for improvement. For example, playing chess matches won’t improve your chess skills, but analyzing positions or analyzing games played by the grandmasters will indeed improve your skill. To become a true expert in any field, deliberate practice needs to be sustained for years, if not decades. If you are not really motivated to do what you are doing, you are not going to be able to keep up with the deliberate practice.\n\n\nThe Puzzle of Motivation\nSince deliberate practice involves a lot of solitary effort, it is crucial that we know how to maintain our motivation. The most important motivation has to be a strong desire to improve itself. Parents, friends who believe that you can succeed play a huge role. Even a group of people who are in a similar position can help to keep your motivation. When we want to keep our motivation, we have to design our environment in a way that supports our goals. For example, as a reader, I need to keep my reading desk free from all the distractions. If a phone is buzzing every five minutes on my desk, I won’t be able to keep up with my reading. And lastly, our practice sessions need to be short in duration ( about an hour) because the longer the session, the more difficult it is to maintain motivation.\n\n\nDeliberate Practice in Everyday Life\nDeliberate practice isn’t just for those who want to be professional athletes or musicians, it’s for everybody. If you want to improve a skill as a hobby or for your professional work, deliberate practice will work just as well.\nFirst and foremost, there is a need for a good teacher who’ll teach you the basic mental representations. A good teacher has some basic knowledge of the skill, he keeps you motivated to pursue the skill, and he gives feedback for your improvement.\nHowever, when learning a skill, there comes a time when we feel stuck. We don’t improve as fast or we stop improving altogether. This is the OK plateau; where we reach an acceptable level of performance. The best way to get past this stage is to challenge yourself in a different way. Another way to cross the OK Plateau is to raise the difficulty level a little, but not a lot. In doing so, we can know what our weaknesses are and what we can do to improve them. For example, assume that you play tennis and you are stuck on the OK plateau. Then, try playing an opponent who is a little better than you the next time. He can take advantage of your weaknesses, which will let you know what you need to improve. So you can specifically work on that stroke. Often, improving that particular stroke will lead to an overall improvement in your tennis.\nWe haven’t discussed talent yet. So what is talent? Does talent have a role in success? How much can we improve with practice? To know the answers, see you in the next part. Till then, keep applying deliberate practice to your job or your hobby. And keep reading. Bye- bye!"
  },
  {
    "objectID": "posts/peak/index.html#part-3",
    "href": "posts/peak/index.html#part-3",
    "title": "Master Anything With Deliberate Practice",
    "section": "Part 3",
    "text": "Part 3\n\nHow Do Experts Become Experts?\nThe first step is, of course, interest. Every expert starts his journey by becoming interested in the skill. A future grandmaster might have been given chess pieces as a toy in his childhood or, as an adult, he might have a friend who talks a lot about chess.\nThe interest then becomes a little serious. This is the second stage. It is now that the future expert looks for a coach. In this stage, the expert is introduced to deliberate practice for the first time. In this stage, the future expert builds the skill necessary to be amongst the best.\nThen we move on to the final stage of commitment. By this stage, the future expert is committed to be the best he can be. He seeks out the best teachers and prioritizes the skill above everything else.\nBut this journey is not reserved for those who are talented. Any one of us can take this journey if we know what talent is and what role it has in this journey.\n\n\nWhat is Talent?\nTalent is defined as an innate ability to do something. The role of such innate ability is much smaller than people think. Usually, in schools, we see some kids who are better than others in some subject, say math. We assume that they are smart and this smartness will continue even in the later part of their life.\nBut in a very interesting study, researchers first tested the intelligence of elite chess players. Then, they asked the players to keep journals about their practice routines for the next six weeks. After these six weeks, their chess skills were tested. There was no relationship between intelligence and chess skills, even though chess is considered the supreme test of intelligence! The only factor that made the difference was the amount of deliberate practice. The more they practiced, the better their skills were. Talent simply didn’t matter at the elite stage! However, when researchers performed the same experiment with amateur chess players, there was indeed a relationship between intelligence and chess skills. The players with higher intelligence had better chess skills. But this relationship went on diminishing as their level of chess skill improved. More surprisingly, at the elite level, the players with higher intelligence scores seemed to perform worse. Perhaps, they felt they were too smart to be needing hard work.\nThis means, talent can help us learn the basics quickly. Thus, in schools, some kids do better than others; because they are beginners! Once they get to higher education, this advantage is easily lost.\nWhen it comes to expert performance, the only thing that matters is the amount of deliberate practice. It doesn’t matter how talented you are, but if you don’t practice deliberately, you are going to be just average.\n\n\nThe Greatest Gift\nIn the 21st century, jobs will keep changing rapidly. The young kids will need to keep learning new skills to survive. And the confidence that they can learn anything is the greatest gift we can give them. Deliberate practice is a way of knowing that we can learn anything, that there are no limits to our capacities; all you need to do is to put effort in it."
  },
  {
    "objectID": "posts/what-next/index.html",
    "href": "posts/what-next/index.html",
    "title": "What Next?",
    "section": "",
    "text": "Mahesh M. Bhagwat, read the sign on the door. Behind that wooden door sat a man who was hailed as a Hero by the US State Department for his work in human trafficking, the Commissioner of Police, Rachakonda Commissionerate, Telangana. He sat buried in his files, behind a polished white desk with the national flag of India and a flag of Telangana Police by his side. He glanced up for a moment, smiled pleasantly, and went back to his files. He asked us to sit in Marathi, his janmabhoomi’s tongue. Immediately after, his phone rang and he started speaking in fluent Telugu, his karmabhoomi’s tongue. The call ended in a few minutes. Just then, a lady officer entered and he advised her in his articulate English. Boy, was he busy!\nWhilst he was busy, I had enough time to look around his office. Spacious and stylish. Brilliant blues and polished whites. Behind him, accolades shone proudly. A replica of a rocket, a signed cricket bat, and his khaki cap added to the beauty.\nI was lucky. Although I needed to be quick, I got 18 minutes of precious, uninterrupted time.\n Photo with Mahesh Bhagwat\nHe is remarkably soft spoken and a bit shy. His gaze always finds something curious to look at. His words, too, are few and measured.\nWe were seeing a gentler soul behind the stony khaki uniform.\n‘Shall we come later?’ We asked.\n‘पोलीसांच्या कामात हे सगळं चालतेंच रे!’ (Police work is always busy like this!)\n‘I grew up in the small town of Pathardi, near Ahmednagar. Both my father and my mother were primary school teachers. My contact with the police station was limited to just the singing of the national anthem there on Independence Day. Other than that, I kept away from it. I never thought I would be a police officer. In fact, I became an IPS officer first, then I decided to join the service.’\nMahesh Bhagwat, a civil engineer by degree, wanted to become an IAS officer, but he couldn’t qualify. Instead, he qualified to be an IPS officer, and has been working as an IPS officer since. But does he regret not being an IAS?\n‘Not really. You know, people tell me that I’m doing an IAS’s work from an IPS’s chair, so it’s not a big deal.’\nAfter his engineering, he took up a job in Tata Motors. There, he handled the CSR activities of the firm. Alongside it, he was involved in other social movements as well.\n‘I was very interested in rural development and social work. I was associated with Anna Hazare’s watershed development project. If I hadn’t been an IPS officer, I would’ve continued being a public servant, doing social work.’\nAfter he became an IPS officer, his first posting was in Manipur. The year was 1997. Manipur was raging with extremist activities. A number of police officers were attacked; many of them had lost their lives. It was a scary place to be a police officer in during those times.\n‘The early days were tough. I was a stranger, an outsider amidst a crisis. I didn’t know their language, I didn’t know their culture. How, then, were the people supposed to trust me? So, I learned their language, Manipuri. I learned their traditions. I learned what Manipur meant to the Manipurians. Slowly but surely, things worked out.’\nFirst challenge surpassed, next up was Hyderabad, which has been his karmabhoomi since. His immense work in sex trafficking, women safety, and against Naxals has won him the hearts of the Hyderabadis.\nI was lucky again. I got to hear a few stories.\n‘When we were working against Naxals in Adilabad, some used to surrender. These Naxals aren’t inherently bad people. The situation has made them bad. They deserve to improve their situation. They deserve a chance to rebuild their life—a good life.’\n’One such Naxal had to quit his engineering studies in 1988. He surrendered in 2001. He said he wanted to study again. We approached universities, but they weren’t ready to accept a Naxal. I wrote a guarantee letter to the universities. He finished his B Tech, then M Tech, and now he’s working as a professor at the university. I met him recently. I was going home after taking a seminar in a college, and someone started shouting my name from a corner. He came forward, introduced himself, and thanked me profusely. असं, भारी वाटलं! (It felt wonderful to see that I’d changed a life.)\nThis isn’t a single story. Mahesh starts his work as a human being from where his work as an officer ends. Mahesh hasn’t changed ‘a’ life; he has changed many. Most notably, the lives of the victims of sex trafficking—there are hundreds of them. Under his tenure, trafficking has been the top priority of Telangana police. In just one year, they’ve closed 25 brothels, for which he was awarded the Hero award by the US State Department in 2017.\nMahesh has achieved a lot. But a lot more remains.\n‘I don’t think a lot about my future. I still have years more of service. I just think “what’s next?” Each day comes with new challenges and new responsibilities. I just focus on them.’\nNearing 25 years of service, Mahesh stands tall—but with humility—as one of the best IPS officers in the country right now. But that means nothing to him. To him, more important is the question ‘what next?’ More important is his service.\nA service he will keep on doing for years to come.\nAn honest and devoted service.\n\n\nAdvice to the Youth:\n‘My definition of success is very simple. Go to sleep feeling satisfied and without worries, and bring a smile on someone’s face each day. That’s it.’\n‘Today’s era has become the era of the fast. People are always looking for fast, short ways to succeed. They lack patience. My advice will be the same. Develop patience. Don’t give up easily. Be persistent in your efforts because there’s no alternative to hard work.’\n‘And don’t compromise on your core values. Be it integrity, honesty, or empathy. Always live a life aligned with them. That’s what I’ll give to you.’"
  },
  {
    "objectID": "posts/from-ashes-to-an-empire/index.html",
    "href": "posts/from-ashes-to-an-empire/index.html",
    "title": "From Ashes to an Empire!",
    "section": "",
    "text": "We went to Sinnar to meet a man about whom I knew virtually nothing. But very soon I realised what the name Amol Kasar meant. A man in his mid-thirties, Amol Kasar was a brand in himself, an owner of grand furniture stores chain in Sinnar.\nThough Amol didn’t have a typical schooling background, he had what is needed to be successful—he had the courage to try.\nThe lunch at a five-star hotel, by a 17-year-old, was surely going to be the talk of the town.\nBut the God’s test wasn’t over yet.\nBut the drama doesn’t end here. The opening ceremony went as planned but it rained, and rained, and rained after that. Not a single customer came. He had to wait a long while to earn his first income.\nAt 17, he knew he was supposed to do business. Business runs in Amol’s blood.\nAfter the first income of 5,100 Rs, slowly he paid off the 50,000 loan, only to take another loan. This time, of 1 lakh Rs. With that money, he expanded his business. Then again, he paid off that loan and took another loan of 2.5 lakhs. He paid off that loan and took out yet another loan of 5 lakhs to expand. He now owned a couple of furniture stores.\nBut when he started, Sinnar was already home to multiple well-established furniture businesses. Wasn’t he threatened by the competition?\nSlowly, as the name Amol Furniture spread, the competition went out of competition. But the ups of business don’t come without the downs.\nAmol Kasar is a man who holds the capacity to turn a rock into gold.\nNot only did he bounce back, he’s aiming for more stars in the future. Amol Furnitures is far from done yet. The sense of responsibility keeps the man going.\nBut over the course of years, he’s learned his lessons.\nBefore we finished our interview, I couldn’t help but ask him, “Did you ever finish your college degree?”\nAmol Kasar has built his empire from scratch—an empire built upon honesty and uncompromising quality.\nAn empire built with courage and confidence in one’s abilities."
  },
  {
    "objectID": "posts/from-ashes-to-an-empire/index.html#advice-to-the-youth",
    "href": "posts/from-ashes-to-an-empire/index.html#advice-to-the-youth",
    "title": "From Ashes to an Empire!",
    "section": "Advice to the Youth:",
    "text": "Advice to the Youth:\n\n“Make decisions. I’ve seen a lot of people who keep asking for advice but never make their own decision. Others have your best interests at heart but they don’t know your story; they only know their own story. They give advice according to their story, which may or may not be useful to you. Don’t rely too much on advice. Make your own decisions, and make them quickly. Even if the decision is wrong, you’ll get to learn something. But make a decision.”\n\n\n“There are certain things in life that are more important than thrill. These things need to be done first. The youth, nowadays, prioritises enjoyment over these things. Do what is best for your life first, then enjoy life.”\n\n\n“Success needs to be balanced. It needs to be in all areas of life like personal, financial, social. You cannot be successful if you’re a success in one area of life but a failure in another. You have to be successful in all areas even if it means less success in one area.”"
  },
  {
    "objectID": "posts/poor-charlies-almanack/index.html",
    "href": "posts/poor-charlies-almanack/index.html",
    "title": "A Wise Man’s Counsel",
    "section": "",
    "text": "Poor Charlie’s Almanack isn’t exactly a bestseller, but those who’ve read it absolutely swear by it—and for good reason. The book captures the wit and wisdom of Charlie Munger, Warren Buffett’s longterm partner. Charlie’s perspective on life is practical, clear, and refreshingly no-nonsense. Here are my top three learnings from the book."
  },
  {
    "objectID": "posts/poor-charlies-almanack/index.html#poor-chalies-almanack",
    "href": "posts/poor-charlies-almanack/index.html#poor-chalies-almanack",
    "title": "A Wise Man’s Counsel",
    "section": "",
    "text": "Bonus: Charlie One-Liners\nHow can we skip the legendary Charlie Munger one-liners? Here are some of my favourites:\n\n“It’s the work on your desk…. It’s the work on your desk. Do well with what you already have and more will come in.”\n“Do the job right the first time.”\n“Invert! Always invert!”\n“The best a young man can hope for is to get old before he dies!”\n“… consistently try to be not stupid, instead of trying to be very intelligent!”"
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Vikrant",
    "section": "",
    "text": "Order By\n      Default\n      \n        Title\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nLogstash Parser\n\n2 min\n\n\nSoftware Engineering\n\n\n\nIn this project, I wrote a parser for Logstash pipelines using PyParsing.\n\n\n\nAug 23, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nImplementing Late Chunking in PyTorch\n\n2 min\n\n\nData Science\n\n\n\nIn this project, I implemented a research paper from arXiv using PyTorch.\n\n\n\nFeb 15, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nGPT-2\n\n1 min\n\n\nData Science\n\n\n\nIn this project, I implemented GPT-2 architecture from scratch.\n\n\n\nJan 17, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Shakespeare In Me\n\n1 min\n\n\nData Science\n\n\n\nIn this project, I implemented transformers architecture from scratch to create a decoder only GPT that sounds like Shakespeare.\n\n\n\nDec 14, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\nWavenet\n\n1 min\n\n\nData Science\n\n\n\nMy implementation of a hierarchicaly neural network for language modeling, inspired from Andrej Karpathy’s YouTube Series.\n\n\n\nDec 4, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\nScreener Scraper\n\n2 min\n\n\nSoftware Engineering\n\n\n\nManually getting data from websites like Screener can be tedious, especially if you want to run a simple computational model. I built a tool to automate the time-consuming…\n\n\n\nOct 29, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\nHTTP Server From Scratch\n\n2 min\n\n\nSoftware Engineering\n\n\n\nI always wondered how HTTP and servers worked under the hood. So I decided to build an HTTP web server from scratch, without relying on existing frameworks!\n\n\n\nOct 25, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\nMoney Map\n\n1 min\n\n\nSoftware Engineering\n\n\n\nMoney Map is a financial tool that lets you run simulations with different inputs and get an approximation of your financial plans.\n\n\n\nOct 18, 2024\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "dsa/linked-lists-stacks-and-queues/index.html",
    "href": "dsa/linked-lists-stacks-and-queues/index.html",
    "title": "Stacks, Queues, Linked Lists, and Arrays",
    "section": "",
    "text": "1. Valid Parentheses\n\n1.1 Using Stacks\n🎯 Understanding the Test Cases:\nTest Case 1:\nInput: s = \"[()]\"\nExplanation: The string \"([])\" is valid because each open bracket has a matching closing bracket, and they close in the correct order. Since all brackets are properly paired, the string evaluates to True.\nTest Case 2:\nExplanation: The string \"(]\" is invalid because the open bracket ( is not closed by the correct type of bracket. The closing bracket ] doesn’t match the opening (, so the string evaluates to False.\n🔍 Problem Understanding:\nWe only have three types of brackets: [], (), {}. And we need to close the last opened bracket first. What do you do when you need to close the last opened bracket first? You need a system where the last thing you add is the first thing you take out, right? This is the Last In, First Out (LIFO) system. So, what data structure works best for LIFO? A stack! A stack can help us keep track of the brackets. Whenever we find an opening bracket, we push it onto the stack. When we encounter a closing bracket, we pop the stack to see if it matches the last opened bracket.\n\n\n\n\n\n\nTip🤔Think about this:\n\n\n\nLet’s say you’ve read the first two characters of a string and added them to the stack. Your stack might look like this:\nstack = ['(', '{'].\nNow, what if the next character is }? How do you know if this closing bracket matches the last opened one? To figure this out, we can use a simple mapping: each closing bracket corresponds to its opening bracket, like this: closing bracket : Corresponding opening bracket. This way, we can check if every closing bracket matches the correct opening one.\n\n\n⚠️ Edge Cases:\nWhat happens if you have opening brackets left in the stack, but the string ends? Or what if there are closing brackets, but the stack is empty? How would you handle these situations?\nTime Complexity: \\(O(n)\\)\nSpace Complexity: \\(O(n)\\)\n\n\nNeed help with implementation?\n\n\nclass Solution:\n    def isValid(self, s: str) -&gt; bool:\n        # Keep the mapping as 'closing bracket' : 'Correspoding opening bracket'\n        mapping = { \n            ')' : '(', \n            ']' : '[', \n            '}' : '{'\n        }\n\n        stack = [ ]\n\n        # O(n)\n        for char in s:\n            if char not in mapping: # This means that the bracket is an open bracket\n                stack.append(char)  # Simply add the open bracket to the stack     \n            else:\n                # Corner case- stack has no elements but the string has closing bracket\n                if len(stack) == 0:\n                    return False\n\n                # Check if opening bracket in the stack matches with the closing bracket in the string\n                if mapping[char] != stack.pop():\n                    return False\n\n        # if stack is empty after checking every char of string\n        # that means that we found the closing bracket for every opening bracket. Thus, return True\n        # And vice versa. Return False\n\n        return not stack # Returns True if stack is empty, False otherwise\n\n\n\n\n\n\n2. Longest Consecutive Sequence\n🎯 Understanding the Test Cases:\nTest Case 1:\nnums=[100, 4, 200, 1, 3, 2]\nExplanation:\nThe longest consecutive sequence in the array is [1, 2, 3, 4], which has a length of 4. Note that it is okay if the numbers do not appear contiguously or as a subsequence in the array. For example, in this the number 4 occurs before the the other numbers in the sequence. All that we are asked is to return the length of the longest sequence whose elements are consecutive integers.\n\n2.1 Brute Force\nCan you think of a brute force way to solve this problem? You would look at each number and then search the entire array to see if the next number exists. You would do this for each element in the array, and keep track of the longest one.\nBut what’s the problem with this approach? It takes a lot of time—specifically, the time complexity is \\(O(n^2)\\). But we’re asked to find a solution that’s faster, with a time complexity of \\(O(n)\\).\n\n\n2.2 Improved Approach Using Sets\nWhen using brute force, we had to search the entire array to check if the next number existed. Do you think there’s a way to speed up this check? What if we had a data structure that allows us to check if a number exists in constant time?\n\n\n\n\n\n\nTipHint:\n\n\n\nThink of a data structure that has constant-time lookups.\n\n\nWe can use a set here!\nSo, how can we solve this using sets?\n\nFor each number, while the next consecutive number exists, we keep counting.\nBut wait! If we use this method directly, some numbers might get checked more than once, which still gives us \\(O(n^2)\\) time. How can we improve this?\n\nWhich numbers can start a consecutive sequence?\n\nOnly those numbers n where n-1 is not in the set. Only these numbers can be the starting points of the longest consecutive sequence. Do you see why?\nBy finding these starting points, we can run our loop efficiently on only these elements.\n\nTime Complexity: \\(O(n)\\) Space Complexity: \\(O(n)\\)\n\n\nNeed help with implementation?\n\n\nclass Solution:\n    def longestConsecutive(self, nums: List[int]) -&gt; int:    \n\n        # Convert nums to a set\n        num_set = set(nums)\n\n        starting_points = set()\n        \n        # Only those elements can be starting points where n - 1 is not in num_set\n        # O(n)\n        for num in nums:\n            if num - 1 not in num_set: \n                starting_points.add(num)\n\n        max_length = 0\n        # Overall O(n), because the inner while loop is just going to run once for other elements\n        for current_num in starting_points:\n                current_length = 1\n                \n                while current_num + 1 in num_set:\n                    current_num += 1\n                    current_length += 1\n                \n                max_length = max(max_length, current_length)\n        \n        return max_length\n\n\n\n\n\n\n\n\n\n\nTipTips for Linked List Problems:\n\n\n\nBefore you jump into these problems, here are some tips on solving linked list problems:\n\nDebugging linked lists can be a nightmare! So, it’s always better to get the code right the first time.\nWhen solving Linked List problems, it ALWAYS helps to draw the diagrams.\nWhenever you see a Linked List problem, the first thing that you should do is: handle the base / edge cases like an empty linked list or a list with just one node. It’ll save you a lot of time and stress, especially during the OPPE!\n\n\n\n\n\n\n\n3. Rotate List\n\n3.1 Rotation Logic:\n\nIf \\(k \\gt n\\), then the number of effective rotations is: \\(k = k \\% n\\).\nThink about this as a three step problem:\n\nFirst, traverse \\(k\\) nodes. This n - kth node becomes the newhead of the rotated list.\nNext, connect the original list’s tail to its headto create a cycle in the linked list.\nFinally, walk from the newhead for n nodes to find the newtail, which will become the tail of the rotated list by marking its next pointer as None.\n\n\nNote: Readers are encouraged to look for cleaner and more efficient solution on the platform and take this approach as a starting point.\n\n\nNeed help with implementation?\n\n\nclass Solution:\n    # Gets the length of node: 'n'\n    def get_length(self, head):\n        current = head\n        count = 0\n        while current:\n            current = current.next\n            count += 1        \n        return count\n\n    def rotateRight(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:\n        n = self.get_length(head)\n        \n        # Corner case\n        if n &lt;= 1:\n            return head\n\n        k = k % n # Number of effective rotations\n\n        # In the original list, you need to walk these many steps to get to new head\n        walk_these_many_steps = n - k \n\n        if k == 0 or walk_these_many_steps == 0:\n            return head\n\n        # Get the new head of the list that you will get after you rotate\n        current = head\n        count = 0\n        newhead = None\n        while current:\n            if count == walk_these_many_steps:\n                newhead = current\n                break\n\n            current = current.next\n            count += 1\n\n        # Get to the end of the list so that you can link tail with the head. \n        # But now your linked list is a cycle\n        current = head\n        count = 0\n        while current:\n            if not current.next:\n                current.next = head\n                break\n            current = current.next\n\n        # Now you need to make the new tail point to None to break the cycle\n        current = newhead\n        count = 0\n        while current and count &lt; n:\n            current = current.next\n            count += 1\n            if count == n - 1:\n                current.next = None\n\n        return newhead\n\n\n\n\n\n\n4. Swap Nodes in Pairs\n\n4.1 Intuition\nLet’s break this problem down step by step with the help of an image. Imagine we have a linked list, and we want to swap every two nodes. To make this easier, we’ll look at an illustration. We’re going to use some colors and a little helper node.\n\nWe make a dummy node at the front of the list. This dummy points to the head and we’ll call it prev for “previous”. It’ll help us easily swap the first two nodes.\nIn each step, we’ll change certain links between nodes. These important links will be marked in pink.\nTo swap the nodes, we use pointers, shown in blue. These pointers help us know which nodes we’re swapping and how to connect them.\nNext to the diagram of each step, we’ll show simple code steps for changing the links.\n\n\n\n\nSwap Nodes\n\n\nNow let’s code this!\n\n\nNeed help with implementation?\n\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n         # Create a Dummy node that becomes \"prev\"\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy \n\n        # Since we are going to update using prev.next and prev.next.next\n        # they both should exist\n\n        while prev.next and prev.next.next:\n            # Find the \"curr\" and \"nxt\" nodes\n            curr = prev.next\n            nxt = prev.next.next\n            \n            # Pink links for swap\n            prev.next = nxt\n            curr.next = nxt.next\n            nxt.next = curr\n            \n            # Move the \"prev\" pointer to the next pair\n            prev = curr\n        \n        # The new head of the list is next to the dummy node\n        return dummy.next\n\n\n\n\n\n\n5. Reverse Nodes in K Groups\n\n5.1 Using Recursion\nIntuition:\nYou know how to reverse a linked list from the Graded Assignment question. Given a number k, can you reverse the first k nodes and return the head and tail after reversing? Now that we have reversed the first k nodes, can you repeat the same thing for the next k nodes? We have a way of reversing groups of k nodes. But here’s the important part: how do you connect these reversed groups?\n\n\n\n\n\n\nTip\n\n\n\n🤔 Can you think of a recursive way?\n\n\n\nRemember that the last reversed k nodes will be the first to return when called recursively!\nLet’s take an example list: 1 -&gt; 2 -&gt; 3 -&gt; 4, and k = 2.\n\nFirst, reverse 1 -&gt; 2 as 2 -&gt; 1, and return the head as 2 and tail as 1.\nThen, reverse 3 -&gt; 4 recursively as 4 -&gt; 3, and return the head as 4 and tail as 3.\nNow, you just need to connect the tail of the first reversed group (1) to the head of the second reversed group (4). Voilà! You’ve connected the reversed groups.\n\n\n\n\nNeed help with implementation?\n\n\nclass Solution:\n    # Helper function: returns the number of nodes in the linked list\n    def get_length(self, head):\n        count = 0\n        current = head\n        while current:\n            current = current.next\n            count += 1\n        return count\n\n    def reverse(self, head, k, n):\n        # Edge Case: The group is empty\n        if not head:\n            return head, None\n\n        # Edge case: If k &gt; n, then remaining nodes should remain as they are\n        if k &gt; n:\n            return head, None\n\n        # Reverse the K nodes in groups starting from \"head\"\n        current = head\n        prev = None\n        next_node = None\n        count = 0\n        while current and count &lt;= k:\n            # Counting because we want to mark the tail also\n            if count &lt; k:\n                next_node = current.next\n                current.next = prev       \n                prev = current            \n                current = next_node       \n\n            count += 1\n        \n        curr_head = prev # The head of the reversed k nodes\n        curr_tail = head # tail of the reversed k nodes\n\n        # Recursively call reverse on the next k nodes. Observe that the number of nodes in remaining list is: n - k\n        next_head, next_tail = self.reverse(next_node, k, n - k)\n        \n        # Connect the current group's tail with the head of the next group\n        curr_tail.next = next_head \n\n        return curr_head, curr_tail\n\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:\n        n = self.get_length(head)\n        head, tail = self.reverse(head, k, n)\n        return head\n\n\n\n\n\n\n6. Middle of The Linked List\n\n6.1 Using Iteration\nLet’s think about how we can find the middle element in a linked list, similar to how we do it in an array. We usually find the middle index by calculating mid = len(L) // 2 and then return L[mid]. This works because arrays let us access any element directly by its index.\nBut in a linked list, we don’t have direct access to an element by index. So, how could we find the middle element?\nHere’s how:\n\nFirst, we need to compute len(L). How can we do this? We could iterate through the entire list, counting each node as we go.\nOnce we know the length, we can compute the middle index just like we did with the array: mid = len(L) // 2\nFinally, we would traverse the list again, stopping when we reach the middle node.\n\nTime Complexity: \\(O(n)\\)\n\n\nNeed help with implementation?\n\n\nclass Solution:\n    def get_length(self, head):\n        \"\"\"\n        Helper function- iterates over the entire linked list and returns the length of the list\n        \"\"\"\n        counter = 0\n        while head:\n            counter += 1\n            head = head.next\n        return counter\n\n\n    def middleNode(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        # Handle the base case\n        if not head:\n            return \n\n        # Compute the middle index \n        n = self.get_length(head)\n        mid = n // 2\n\n        # Iterate mid number of steps\n        idx = 0\n        while idx &lt; mid: \n            head = head.next # note that we are updating the head. So after \"mid\" iterations, head = middle node\n            idx += 1\n        \n        # Since head = mid after iterating, we return head\n        return head\n\n\n\n\n\n\n7. Delete the Middle Node\n\n7.1 Using Iteration\nWe’ve already discussed how to find the middle node in a linked list. So, if we know how to reach the middle node, can we figure out how to delete it? 🤔\nTo delete a node in a linked list, here’s what we need to do:\n\nStop at the node before the one we want to delete.\nRedirect the pointer: Change the next pointer of the current node to skip the node we want to delete and point to the node after it. Essentially, current.next = current.next.next.\n\n⚠️ Edge Cases: What if the linked list has only one node? In this scenario, we need to handle cases where current.next.next doesn’t exist.\n\nTime Complexity: \\(O(n)\\)\n\n\n\nNeed help with implementation?\n\n\nclass Solution:\n    def get_length(self, head):\n        \"\"\"\n        Helper function- iterates over the entire linked list and returns the length of the list\n        \"\"\"\n        counter = 0\n        while head:\n            counter += 1\n            head = head.next\n        return counter\n\n    def deleteMiddle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        mid = self.get_length(head) // 2\n        \n        current = head # Iterate using current because we want to return the head\n\n        idx = 0\n        # Stopping one node before the middle node\n        while idx &lt; mid - 1:\n            current = current.next\n            idx += 1\n        \n        # Change links of the node before to the next to next node by handling corner case\n        if current.next and current.next.next:\n            current.next = current.next.next\n        else:\n            current.next = None\n        return head\n\n\n\n\n\n\n8. Delete nth Node From End\n\n8.1 Using Iteration\nWe now know how to delete the middle node. Can you try to solve this problem using the ideas from that question?\n\n\n\n\n\n\nTip\n\n\n\nHint: Deleting the nth node from the end is the same as deleting (length - n)th node from the front.\n\n\n\n\n\n9. Merge Two Sorted Lists\nRemember Merge Sort algorithm? Can you see how this question is similar to the merge(A, B) operation from the merge sort algorithm? Only instead of merging arrays, we’re merging linked lists! 🔗\n\n\nNeed help with implementation?\n\n\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:\n\n        # Dummy node to serve as a proxy for head of the list to return      \n        dummy = ListNode()\n        current = dummy\n\n        # Iterate as long as neither list is exhausted\n        while list1 and list2:\n            if list1.val &lt; list2.val:\n                current.next = list1\n                list1 = list1.next\n            else:\n                current.next = list2\n                list2 = list2.next\n            current = current.next\n\n        # Attach the remaining nodes of list1 or list2\n        if list1:\n            current.next = list1\n        elif list2:\n            current.next = list2\n\n        # The merged list is next to the dummy node\n        return dummy.next",
    "crumbs": [
      "DSA",
      "Leet Coding Using Python",
      "Stacks, Queues, Linked Lists, and Arrays"
    ]
  },
  {
    "objectID": "dsa/sorting-and-searching/index.html",
    "href": "dsa/sorting-and-searching/index.html",
    "title": "Sorting and Searching",
    "section": "",
    "text": "1. Longest Subsequence With Limited Sum\n🎯 Understanding the Test Cases:\nTest Case 1:\nnums = [4, 5, 2, 1], queries = [3, 10, 21]\nExplanation:\nFor queries[0] = 3: The longest subsequence we can take from nums is [2, 1] because \\(2 + 1 = 3\\), which has 2 elements. So, the answer is 2. If we add any other element, the sum becomes greater than 3. Note that in a subsequence, you can drop certain elements but the relative order stays same.\nFor queries[1] = 10: We can take [4, 2, 1], with a sum of \\(7\\), which has 3 elements. So, the answer is 3.\nFor queries[2] = 21: We can take the whole array [4, 5, 2, 1], with a sum of 12, which has 4 elements. So, the answer is 4.\n\n1.1: Brute Force\n\nTo find out the maximum number of elements less than or equal to some number, just add the smallest numbers.\nSort the list first.\nFor every query in queries, find out how many elements can be added by iterating over the array nums.\n\nTime Complexity: \\(O(m \\cdot n)\\)\n\n\nNeed help with implementation?\n\n\nclass Solution(object):\n    def answerQueries(self, nums: List[int], queries: List[int]) -&gt; List[int]:\n\n        answer = [ 0 for i in range(len(queries))]\n        nums.sort() # Sort so that adding smallest elements is easier\n\n        for i in range(len(queries)):\n            query = queries[i]\n            index, count, total = 0, 0, 0\n            \n            # For every query, keep adding the smallest element to get the maximum number of \n            # elements whose total is less than or equal to that query\n            while total &lt;= query and index &lt; len(nums):\n                if total + nums[index] &gt; query:\n                    answer[i] = count\n                    break\n                else:\n                    total += nums[index]\n                    index += 1\n                    count += 1\n            answer[i] = count\n        return answer\n\n\n\n\n\n1.2 Prefix Sum\nThere’s an even better approach here. That’s with prefix sum. You would pass the test cases with the brute force approach, but it’s good to know this approach since it’s a useful concept.\n\nSort the list first.\nKeep a prefix_sum array where ith element of it stores the sum of first i smallest elements. Notice that this array will be sorted.\nFor each queries[i], use binary search on prefix_sum to find out the largest element less than equal to queries[i]\n\nIt’s a good exercise to see why this approach would produce correct result.\nTime Complexity: \\(O(n \\cdot \\log(n))\\)\n\n\nNeed help with implementation?\n\n\nclass Solution:\n    def answerQueries(self, nums: List[int], queries: List[int]) -&gt; List[int]:\n        answer = [0 for i in range(len(queries))] # O(n)\n        nums.sort() # O(nlogn)\n        prefix_sum = [ ] \n\n        # O(n)\n        for i in range(len(nums)):\n            prefix_sum.append(nums[0]) if i == 0 else prefix_sum.append(prefix_sum[i - 1] + nums[i])\n\n        # O (m log n)\n        for i in range(len(queries)): # O(m)\n            query = queries[i]\n            count = self.binarysearch(query, prefix_sum) #O(log n)\n            answer[i] = count\n        return answer\n\n    def binarysearch( self,v, L):  #v = target element\n        low, high = 0, len(L) - 1\n        while low &lt;= high: \n            mid = (low + high) // 2\n            if L[mid ] &lt; v:\n                low = mid  + 1\n            elif L[mid ] &gt; v:\n                high = mid  - 1\n            else:\n                return mid + 1 # return the next index than where the element was found\n        return low # Returns index where the element should go if not found\n\n\n\n\n\n\n2. Top K Frequent Elements\n🎯 Understanding the Test Cases:\nTest Case 1:\nnums= [ 1, 1, 1, 2, 2, 3], k = 2\nExplanation:\nIn this test case, the number \\(1\\) occurs thrice, the number \\(2\\) occurs twice, and the number \\(3\\) occurs once. Since we have to return top \\(2\\) most frequent numbers, we return \\(1\\) and \\(2\\). Important to note here is that the question says nothing about whether the nums array is sorted or not. If it is not explicitly given in the question, we cannot assume it.\n\n2.1 Using Dictionaries and Sorting\n\nInitialize a dictionary. For every element in nums, you count occurrences of that element. We can do this in a single pass. Plus this has the added benefit of eliminating duplicates, which we will use later. A useful library class to explore here is: from collections import Counter\nFor every unique element from the nums array, create a new 2D array where each element is of the format: [element from nums, it's count]\nSort this array based on the counts in descending order.\nPick the first k elements.\n\nTime Complexity: \\(O(m \\cdot \\log(m))\\), where \\(m\\) is the number of unique elements in nums.\n\n\nNeed help with implementation?\n\n\n\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:\n        counts = { } # init counts dictionary\n\n        # count the number of occurrences for each element\n        for num in nums: # O(n)\n            if num in counts:\n                counts[num] += 1 \n            else:\n                counts[num] = 1\n        \n        # [ [elem1, it's count], [elem2, it's count], [elem3, it's count] ]\n        L = [[x, counts[x]] for x in counts.keys()] # O(m), where m = number of unique elems in nums\n\n        # Sort in descending order based on counts\n        L.sort(key=lambda x:x[1], reverse=True) # NOT O(n log n), it's O(m log m)!\n\n        output = [ ]\n\n        # O(k)\n        # Pick out the top k elements. Note that we don't need counts. So we return L[i][0]\n        for i in range(k):\n            output.append(L[i][0])\n\n        return output\n\n\n\n\n\n\n3. Sort Colors\nThis problem is similar to what is discussed in one the practice programming assignments for this week, and we need to solve this problem in \\(O(n)\\) complexity.\n\n3.1 Sort the nums in place\nWe can simply sort the array nums in place are return it. We can use nums.sort() for this. But the comlpexity for this will be: \\(O(n \\cdot \\log (n))\\). Can we do better?\n\n\n3.2 Take Count of Colors\nWe know that there are only three distinct elements in the list. So can we count the occurrences for each distinct color element, and then replace the original array using these counts. For example, consider an array nums = [ 2, 0, 2, 1, 1, 0, 1]. We can keep a dictionary for counts as follows:\ncounts[0] = 2\ncounts[1] = 3\ncounts[2] = 2\nThen for every color, we can replace nums[i] to nums[i + count] with the color.\nTime Complexity: \\(O(n)\\)\n\n\nNeed help with implementation?\n\n\nclass Solution:\n    def sortColors(self, nums: List[int]) -&gt; None:\n        counts = { \n            0 : 0, \n            1: 0, \n            2: 0\n        }\n\n        # O(n). Take counts for each color\n        for i in range(len(nums)):\n            counts[nums[i]] += 1\n\n        index = 0\n\n        # O(n). For each color, update the nums[i] to nums[i + count] to the color.\n        for i in range(3):\n            for count in range(counts[i]):\n                nums[index] = i\n                index += 1\n\n\n\n\n\n\n4. Merge Intervals\n🎯 Understanding the Test Cases:\nTest Case 1:\nintervals = [[1,3], [2,6], [8,10], [15,18]]\nExplanation:\nWe start with the first interval [1, 3]. The next interval [2, 6] overlaps with [1, 3], so we merge them into [1, 6]. The next interval [8, 10] doesn’t overlap with [1, 6], so we keep it as is. The last interval [15, 18] also doesn’t overlap with any previous intervals, so we keep it as is.\nTest Case 2:\nintervals = [[1, 4], [2, 3], [5, 10]]\nExplanation:\nWe start with the first interval [1, 4]. The next interval [2, 3] overlaps with [1, 4]. But note that the first interval subsumes this one. So the merged interval is: [1, 4]\nThe last interval [5, 10] doesn’t overlap with any previous intervals so we keep it as it is.\n\n4.1 Sorting intervals\n\nIf we want to merge intervals, it would be easier if overlapping intervals come adjacently in the input list, which means… Sorting!\nSort based on the start of the interval.\nFor every interval, check whether start of the interval falls within the end of the merged interval\nBut we will need to consider the below corner cases:\n\nOne interval subsumes another, then what? This means that the second interval’s end is smaller than the first. Such as: [1, 10] and [2, 5]\nHow do you handle last interval?\n\n\nWe also need to keep track of the start and the end of the merged intervals.\nTime Complexity: \\(O(n \\cdot \\log(n))\\)\n\n💻 Code Implementation:\nclass Solution:\n    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:\n        if not intervals:\n            return []\n        \n        # Sort intervals based on the start\n        intervals.sort(key=lambda x: x[0])\n        \n        merged_intervals = []\n        current_start, current_end = intervals[0]\n        \n        for interval in intervals[1:]:\n            # Overlapping intervals, merge them\n            if interval[0] &lt;= current_end:\n                current_end = max(current_end, interval[1]) # The max function is required to handle the 1st edge case\n            else:\n                # Non-overlapping interval found, add previous interval to result\n                merged_intervals.append([current_start, current_end])\n\n                # Update current interval\n                current_start, current_end = interval\n        \n        # Add the last interval\n        merged_intervals.append([current_start, current_end])\n        \n        return merged_intervals\n\n\n\n\n5. Search in Rotated Sorted Array\n🎯 Understanding the Test Cases:\nThis is a simple search problem, so the test cases are not discussed.\n\n5.1 Using Binary Search\n📚 Problem Overview:\nWe need to find the element in \\(\\log(n)\\) time. When you see \\(\\log(n)\\), what do you think of? Of course, Binary search! This question has been asked in PYQs, so better to understand it well.\n💡 The Solution:\n\nAt any mid index, there are two possibilities: either the left half of the array is sorted, or the right half is.\nIf the left side is sorted:\n\nCheck if the target within this range?\n\nIf yes, do a binary search on the left half.\nIf no, explore the right half.\n\n\nIf the right side is sorted:\n\nAgain, check if the target is in this range.\n\nIf yes, perform binary search on the right half.\nIf no, explore to the left side.\n\n\n\n\n\nNeed help with implementation?\n\n\n\nclass Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n\n        while left &lt;= right:\n            mid = (left + right) // 2\n            \n            # If the target is found\n            if nums[mid] == target:\n                return mid\n            \n            # Check if the left half is sorted\n            if nums[left] &lt;= nums[mid]:\n                # If the target lies within the sorted left half\n                if nums[left] &lt;= target &lt; nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            # Otherwise, the right half is sorted\n            else:\n                # If the target lies within the sorted right half\n                if nums[mid] &lt; target &lt;= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        \n        # If the target is not found\n        return -1\n\n\n\n\n\n\n6. Find First and Last Position of Element in Sorted Array\n🎯 Understanding the Test Cases:\nTest Case 1:\nnums = [5,7,7,8,8,8,10], target = 8\nExplanation:\nWe need to find the starting and ending indices of the target number 8. In this case, 8 appears three times, so we return the range [3, 5], where index 3 is the first occurrence and index 5 is the last.\n\n6.1 Using Binary Search\n📚 Problem Overview:\nAgain, we need a \\(\\log(n)\\) solution. So, we think Binary Search to come up with a solution.\n💡 The Solution:\n\n\n\n\n\n\nTipHint:\n\n\n\nWe know binary search is fast, but it stops when we find the target. What if we keep going to find both the first and last occurrences?\n\n\nHere’s how we can do it:\nLeftmost Occurrence:\n\nRun a binary search, but when you find 8, don’t stop! Keep searching the left half to find the first occurrence.\n\nRightmost Occurrence:\n\nSimilar idea, but now after finding 8, explore the right half to find the last occurrence.\n\nBy running two binary searches, we find both boundaries of the target range in \\(O(\\log n)\\) time.\n\n\nNeed help with implementation?\n\n\nclass Solution:\n    def searchRange(self, nums, target):\n        def findLeft(nums, target):\n            leftmost_occurrence = -1\n            # Finds the left most index of target number\n            left, right = 0, len(nums) - 1\n            while left &lt;= right:\n                mid = (left + right) // 2\n                if nums[mid] &lt; target:\n                    left = mid + 1\n                elif nums[mid] == target:\n                    leftmost_occurrence = mid\n                    right = mid - 1\n                else:\n                    right = mid - 1\n            return leftmost_occurrence\n        \n        def findRight(nums, target):\n            # Finds rightmost index of target\n            rightmost_occurrence = -1\n            left, right = 0, len(nums) - 1\n            while left &lt;= right:\n                mid = (left + right) // 2\n                if nums[mid] &lt; target:\n                    left = mid + 1\n                elif nums[mid] == target:\n                    rightmost_occurrence = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return rightmost_occurrence\n        \n        leftmost_occurrence = findLeft(nums, target)\n        rightmost_occurrence = findRight(nums, target)\n        \n        # Check if the target is not found\n        if leftmost_occurrence == -1:\n            return [-1, -1]\n        return [leftmost_occurrence, rightmost_occurrence]\n\n\n\n\n\n\n7. Find K Closest Elements\n\n💻 Code Implementation:\nclass Solution:\n    def binarysearch(self, nums, key):\n        left, right = 0, len(nums) - 1\n        while left &lt;= right:\n            mid = (left + right) // 2\n            if nums[mid] == key:\n                return mid\n            elif nums[mid] &gt; key:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left\n    \n    def findClosestElements(self, arr: List[int], k: int, x: int) -&gt; List[int]:\n        # Find the element\n        searchindex = self.binarysearch(arr, x)\n        left, right = searchindex- 1, searchindex\n\n        # Edge cases- number is the first number in array or the last\n        if searchindex &lt; 0:\n            return arr[:k]\n        if searchindex &gt; len(arr) - 1:\n            return arr[k:]\n        \n        L = [ ]\n        # Keep sliding the two pointers till you have \"k\" closest elems\n        while len(L) &lt; k:\n            if left &lt; 0 and right &lt; len(arr):\n                L.append(arr[right])\n                right += 1\n            elif right &gt; len(arr) - 1 and left &gt;= 0:\n                L.append(arr[left])\n                left -= 1\n            else:\n                dist1 = abs(arr[left] - x)\n                dist2 = abs(arr[right] - x)\n                if dist1 &lt;= dist2:\n                    L.append(arr[left])\n                    left -= 1\n                else:\n                    L.append(arr[right])\n                    right += 1\n        return sorted(L)# Return the sorted \"k\" nums\n\n\n\n8. Check If N and Its Double Exist\n🎯 Understanding the Test Cases:\nTest Case 1:\narr = [10,2,5,3]\nExplanation:\nIn this array, arr[2] = 5 is half of arr[0] = 10. Since they’re at different indices and one is double the other, we return True.\n\n8.1 Using Binary Search\n📚 Problem Overview:\nWe’re looking to see if any number in the array has a double or half that’s also in the array. Binary Search can make this faster! Let’s sort the array so we can search more efficiently.\n\n\n\n\n\n\nTipObserve:\n\n\n\nIf a number is odd, it can’t have an integer half, so we can skip it!\n\n\n\nPseudocode:\n\nSort the array.\nFor each number in the array:\n\nCheck if it’s odd or even.\nIf it’s odd, move to the next one.\nIf it’s even, binary search for its half.\nIf the half exists and indices are different, return True.\n\n\n\n\n\nQuestion:\nGiven this problem, can you think of a case where the indices of a number and it’s double will be the same?\n\n\n\nNeed help with implementation?\n\n\n\nclass Solution(object):\n    def checkIfExist(self, arr:List[int]) -&gt; bool:\n        arr.sort() # sort array first\n\n        for i, num in enumerate(arr):\n            # If value is odd, it's half can't exist\n            if num % 2 != 0:\n                continue\n\n            # Search for num / 2 in the array\n            idx = self.binarysearch(arr, num / 2)\n\n            # If num / 2 was found and indices are different return True\n            if i != idx and idx != -1: \n                return True\n        \n        # No pair was found\n        return False\n    \n    def binarysearch(self, L, value): \n        low = 0\n        high = len(L) - 1\n        while low &lt;= high: \n            mid = (low + high) // 2\n            if L[mid ] &lt; value:\n                low = mid  + 1\n            elif L[mid ] &gt; value:\n                high = mid  - 1\n            else:\n                return mid # Found the value, so return the index at which the value was found\n                \n        return -1 # Couldn't find value\n\n\n\n\n\n9. H-Index\n🎯 Understanding the Test Cases:\nPlease refer to the Leet Code discussion on test cases for an explanation of test cases.\n\n9.1 Using Sorting\n📚 Problem Overview:\n🎯 What’s the Goal?\nWe want to find the maximum H-index for a researcher, where H is the highest number such that at least H papers have been cited at least H times. Let’s look at the solution first, which we will unpack then.\nclass Solution:\n    def hIndex(self, citations: List[int]) -&gt; int:\n        citations.sort(reverse=True)\n        for i, citation in enumerate(citations):\n            if citation &lt;= i: \n                return i\n        return len(citations)\nLet’s unpack the code:\n\nWe sort the citations array in descending order.\nLoop Through Each Citation:\n\ni is the count of papers with at least that many citations.\nIf citation &lt;= i, we return i as our H-index, because there are exactly i papers with at least i citations.\n\n\n\n\n\n\n\n\nTip\n\n\n\nIf this feels confusing, do spend some time in think about the if condition.\n\n\n\n\n\n10. Capacity to Ship Packages Within D Days\n\n\n\n\n\n\nTipPattern Alert:\n\n\n\nThis is an important type of problem that you can solve using binary search plus sorting. In this pattern, you want to find the maximum of some minimum quantities, or the minimum of some maximum quantities. The general approach to solve these problems is:\n\nFind the range of the solution\nBinary search through the it\n\n\n\nclass Solution:\n    def shipWithinDays(self, weights: List[int], days: int) -&gt; int:\n        # Take minimum possible and maximum possible answers as left and right\n        left, right = max(weights), sum(weights)\n\n        ans = right\n        # Binary search like implementation\n        while left &lt;= right:\n            weight_capacity = ( left + right ) // 2\n            day_count = 0\n            curr_load = 0\n\n            # For a given weight_capacity, find it's answer\n            for i in range(len(weights)):\n                weight = weights[i]\n                if curr_load + weight &lt;= weight_capacity:\n\n                    curr_load += weight\n                    if i == len(weights) - 1:\n                        day_count += 1\n                else:\n                    curr_load = weight\n                    day_count += 1\n                    if i == len(weights) - 1:\n                        day_count += 1\n            # Binary search logic\n            if day_count &gt; days:\n                left = weight_capacity + 1\n            else:\n                ans = min(ans, weight_capacity)\n                right = weight_capacity - 1\n\n        return ans",
    "crumbs": [
      "DSA",
      "Leet Coding Using Python",
      "Sorting and Searching"
    ]
  },
  {
    "objectID": "dsa/shortest-paths-and-mcst/index.html",
    "href": "dsa/shortest-paths-and-mcst/index.html",
    "title": "Shortest Paths and Minimum Cost Spanning Trees",
    "section": "",
    "text": "1. Min Cost To Connect All Points\n🎯 Understanding the Test Cases:\nTest Case 1:\npoints = [[0,0],[2,2],[3,10],[5,2],[7,0]]\nThe first test case from the problem statement.\nExplanation:\nThere are many ways to connect all points. For example: - Path: [0,0] -&gt; [7,0] -&gt; [3,10] -&gt; [2,2] -&gt; [5,2] - Total Manhattan Distance: \\(7 + 14 + 9 + 3 = 33\\) (not optimal)\nBut the optimal way connects them with a total distance of 20, as shown in the problem description.\n\n\n\n\n\n\nTipKey Idea:\n\n\n\nFrom any point, you can connect to any other point, and the edge cost is the Manhattan distance. The goal is to minimize the total cost (sum of all edges).\n\n\n\n1.1 Minimum Cost Spanning Trees\n📚 Problem Overview:\nWe need to find the minimum cost to connect all points. This is a Minimum Cost Spanning Tree (MCST) problem!\n🛠️ How do we turn the points into a graph?\n\nEach point can be a node.\nThe edges are the Mahattan distances between every pair of points in the graph. That means it’s a complete graph—each node is connected to every other one.\n\nPseudocode for building this graph:\n\nRun a nested loop:\n\nFor each point\n\nFor every other point,\n\nCompute the distance and store the edge in an adjacency matrix or an adjacency list\n\n\n\n\n💡 The Solution:\n\nBuild the Graph\nFind the MCST:\n\nUse Prim’s or Kruskal’s algorithm to find the Minimum Cost Spanning Tree. 🌐\nThen, just sum up the edge weights of the Tree. That’s our minimum cost! 🏆\n\n\n\n\nNeed help with the implementation?\n\n\ndef kruskal(WList):\n    \"\"\"Kruskal's as per the PDSA book\"\"\"\n    (edges,component,TE) = ([],{},[])\n    for u in WList.keys():\n        edges.extend([(d,u,v) for (v,d) in WList[u]])\n        component[u] = u\n\n    edges.sort()\n\n    for (d,u,v) in edges:\n        if component[u] != component[v]:\n            TE.append((u,v, d))\n            c = component[u]\n            for w in WList.keys():\n                if component[w] == c:\n                    component[w] = component[v]\n    return TE\n\ndef compute_min_cost(TE) -&gt; int:\n    # Compute the Minimum Cost based on Tree Edges\n    min_cost = 0\n    for u, v, d in TE:\n        min_cost += d\n    return(min_cost)\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -&gt; int:\n        # Init Adjacency Matrix\n        AList = { i : [] for i in range(len(points))}\n\n        # Each point can be connected to every other point and their manhattan distance can be computed.\n        for i in range(len(points)):\n            x1, y1 = points[i][0], points[i][1]\n\n            for j in range(i + 1, len(points)):\n                x2, y2 = points[j][0], points[j][1]\n                dist = abs(x1 - x2) + abs(y1 - y2)\n\n                # Distance from point i to j is same as from j to i. So init both entries\n                AList[i].append((j, dist))\n                AList[j].append((i, dist))\n\n        tree_edges = kruskal(AList)\n        minimum_cost = compute_min_cost(tree_edges)\n        return minimum_cost\n\n\n\n\n\n\n2. Path with Maximum Probability\n\n2.1 Using Dijkstra\n📚 Problem Overview:\nWe need to find the maximum probability of getting from a start_node to an end_node in a graph. Each edge in the graph has a success probability, and we want to maximize the total probability along the path. For example, if there’s a path A -&gt; B -&gt; C with probabilities A -&gt; B = 0.5 and B -&gt; C = 0.5, the total probability for the path A -&gt; C is \\(0.5 \\times 0.5 = 0.25\\).\n💡 The Solution:\nIt’s similar to finding the shortest path, but here we are finding the path with the highest probability!\n\nWe create an adjacency list where each node is connected to its neighbors with the probability of success for each edge.\nMax-Heap: To keep track of the most promising path, we can use a max-heap. But since Python’s heapq is a min-heap, we store negative probabilities (because minimizing negatives is same as maximizing positives).\nWe can run Dijkstra’s algorithm, but instead of minimizing distance, we maximize probability. We stop as soon as we reach the end_node.\n\nIf we never reach the end node, we return 0.0 because there’s no valid path!\n\n\nNeed help with the implementation?\n\n\nclass Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start_node: int, end_node: int) -&gt; float:\n        # Create an adjacency list\n        WList = defaultdict(list)\n        for i, (start, end) in enumerate(edges):\n            probab = succProb[i]\n            WList[start].append((end, probab))\n            WList[end].append((start, probab))\n\n        # Max-heap (negative probabilities to simulate a max-heap)\n        heap = [(-1.0, start_node)]  # (negative probability, node)\n        dist = [-1.0] * n            # Store the maximum probability to reach each node\n        dist[start_node] = 1.0        # Start node has a probability of 1\n\n        while heap:\n            # Pop the node with the maximum probability\n            current_prob, node = heapq.heappop(heap)\n            current_prob = -current_prob  # Convert back to positive\n\n            # If we reached the end node, return the probability\n            if node == end_node:\n                return current_prob\n\n            # Explore neighbors\n            for neighbor, weight in WList[node]:\n                new_prob = current_prob * weight\n                # Only update if we found a higher probability path to neighbor\n                if new_prob &gt; dist[neighbor]:\n                    dist[neighbor] = new_prob\n                    heapq.heappush(heap, (-new_prob, neighbor))\n\n        # If we never reach the end node\n        return 0.0\n\n\n\n\n\n\n3. Cheapest Flight Within K Stops\n\n3.1 Using Dijkstra\n\n\nNeed help with the implementation?\n\n\nclass Solution:\n    def findCheapestPrice(self, n, flights, src, dst, k):\n        # Create the adjacency list\n        adj_list = {i: [] for i in range(n)}\n        for flight in flights:\n            from_city, to_city, price = flight\n            adj_list[from_city].append((to_city, price))\n        \n        # Priority queue -&gt; (current price, city, stops)\n        pq = [(0, src, 0)]  # (price, city, stops)\n        \n        ## BFS with Heap\n\n        # visited[city] stores min number of stops to reach the city\n        visited = {}\n        \n        while pq:\n            price, city, stops = heapq.heappop(pq)\n            \n            # If we reach the destination, return the price\n            if city == dst:\n                return price\n            \n            # If we have visited this city with fewer stops before, skip\n            if city in visited and visited[city] &lt; stops:\n                continue\n            \n            # Store the minimum number of stops to this city\n            visited[city] = stops\n            \n            # If we have more stops than k, continue to the next city\n            if stops &gt; k:\n                continue\n            \n            # Add neighbors to explore\n            for neighbor, cost in adj_list[city]:\n                new_price = price + cost\n                heapq.heappush(pq, (new_price, neighbor, stops + 1))\n        \n        # If no valid route found\n        return -1",
    "crumbs": [
      "DSA",
      "Leet Coding Using Python",
      "Shortest Paths and Minimum Cost Spanning Trees"
    ]
  },
  {
    "objectID": "dsa/index.html",
    "href": "dsa/index.html",
    "title": "Leet Coding Using Python",
    "section": "",
    "text": "Welcome to the supplementary GitHub repository for the course Programming, Data Structures, and Algorithms Using Python (BSCS2002) which is offered as part of the IITM BS in Data Science and Applications program. You can find more information about the course here. There is also an online textbook that you can use as reference throughout the course.\nI created this repository as a part of my work as a Teaching Assistant for this course. In this repository, you will find a solution explanations and code implementations for a list curated Leet Code problems that span the topics covered in the lectures. The problems are categorized such that they correspond to each week’s course content.\nThe solutions presented here are mostly based on the codes discussed in the course to keep it familiar, but readers are encouraged to look at better and more efficient solutions that are available online. I will continue to add some additional problems in this repo in the future as well.",
    "crumbs": [
      "DSA",
      "Leet Coding Using Python"
    ]
  },
  {
    "objectID": "dsa/index.html#overview-of-course-topics",
    "href": "dsa/index.html#overview-of-course-topics",
    "title": "Leet Coding Using Python",
    "section": "📝 Overview of Course Topics:",
    "text": "📝 Overview of Course Topics:\n\nWeek 1: Overview and recap of Python\nWeek 2: Sorting and Searching Algorithms- Binary Search, Quick Sort, Merge Sort, Insertion Sort, Selection Sort.\nWeek 3: Stacks, Heaps, Linked Lists, Arrays, and Hashing\nWeek 4: Graph Algorithms- BFS, DFS, Topological Sorting, DAG\nWeek 5: Graph Algorithms- Shortest Paths, Minimum Cost Spanning Trees\nWeek 6: Union Find, Priority Queues, Heaps, Binary Search Trees\nWeek 7: Balanced Search Trees, Greedy Algorithms- Huffman Coding, Interval Scheduling\nWeek 8: Divide and Conquer- Quick Select, Closest Pair of Points, Counting Inversions\nWeek 9: Dynamic Programming- Grid Paths, Edit Distance, Longest Common Subsequence\nWeek 10: String Matching- Boyer-Moore, Rabin-Karp, KMP, Tries, Regular Expressions\nWeek 11: Network Flows, Linear Programming, NP Hardness\nWeek 12: Summary",
    "crumbs": [
      "DSA",
      "Leet Coding Using Python"
    ]
  },
  {
    "objectID": "dsa/index.html#about-the-problems",
    "href": "dsa/index.html#about-the-problems",
    "title": "Leet Coding Using Python",
    "section": "🔎 About the Problems",
    "text": "🔎 About the Problems\nThe problems selected from LeetCode cover the range of difficulties, from easy to hard. Each problem is chosen to reinforce the concepts learned during the week, and provides both practice and an understanding of the topics. You are encouraged to attempt the problems before looking at the solution approach and code.",
    "crumbs": [
      "DSA",
      "Leet Coding Using Python"
    ]
  },
  {
    "objectID": "dsa/index.html#credits",
    "href": "dsa/index.html#credits",
    "title": "Leet Coding Using Python",
    "section": "🙌 Credits",
    "text": "🙌 Credits\nThis repository is a collaborative effort between the course instructors, teaching assistants, and the enthusiastic community of students. Special thanks to Professor Madhavan Mukund Sir, the instructors Atul Pratap Singh Sir, S Satyanarayana Sir for their continued support, and a shoutout to the creators of the LeetCode platform for providing a wealth of coding challenges.\nHappy coding! 🚀",
    "crumbs": [
      "DSA",
      "Leet Coding Using Python"
    ]
  },
  {
    "objectID": "dsa/dynamic-programming/index.html",
    "href": "dsa/dynamic-programming/index.html",
    "title": "Dynamic Programming",
    "section": "",
    "text": "1. Climbing Stairs\n📚 Problem Overview:\nWe need to find the number of ways to reach the top of a staircase with n steps. At each step, you can either:\n\nTake a single step, or\nTake a double step.\n\n🎯 Understanding the Test Cases:\nTest Case 1: n = 3\nThere are three ways to reach the third step:\n\n\\(0\\) \\(\\rightarrow\\) \\(1\\) \\(\\rightarrow\\) \\(2\\) \\(\\rightarrow\\) \\(3\\). In this way, we are taking one step every time.\n\\(0\\) \\(\\rightarrow\\) \\(1\\) \\(\\rightarrow\\) \\(3\\). Here, we jumped \\(2\\) places from the \\(1\\) st step.\n\\(0\\) \\(\\rightarrow\\) \\(2\\) \\(\\rightarrow\\) \\(3\\). Here, we jumped \\(2\\) places from the \\(0\\) th step, and then \\(1\\) step from the \\(2\\) nd step.\n\nSince there are three ways we return 3.\n🤔 Key Observations:\n\nBase Cases:\n\nTo reach step 0, you need to take \\(0\\) steps ( no need to take any step!).\nTo reach step 1, there is only \\(1\\) way.\nTo reach step \\(2\\), there are two ways: \\(0 \\rightarrow 1 \\rightarrow 2\\) and \\(0 \\rightarrow 2\\)\n\nRecursive Relationship:\n\nIf you’re on step n, you don’t require further steps.\nFrom step n-1, you have 1 way to reach the top.\nFrom step n-2, you have 2 ways (you can jump directly to n or take two steps).\nTo reach step i, you can either come from step i-1 or step i-2. So the relation is: \\[ \\text{ways}(i) = \\text{ways}(i-1) + \\text{ways}(i-2) \\]\n\n\n💡 The Solution: Dynamic Programming\nWe can solve this problem in linear time using dynamic programming by storing the number of ways to reach each step and using the above relation to build up from the base cases.\n\nUse an array to store the number of ways to reach each step.\nStart from step 0 and build up using the relation:\n\nways(i) = ways(i-1) + ways(i-2)\n\n\nTime Complexity: \\(O(n)\\)\n\n💻 Code Implementation:\nclass Solution:\n    def climbStairs(self, n: int) -&gt; int:\n        L = [0]*n # Initialize the dynamic programming array\n        \n        # Base Cases\n        if n == 1: return 1 \n        if n == 2: return 2\n        \n        L[0] = 1\n        L[1] = 2\n\n        # ways[i] = ways[i - 1] + ways[i - 2]\n        for i in range(2, n):\n            L[i] = L[i - 1] + L[i - 2]\n        \n        # Last element corresponds to the nth stair. So return that value.\n        return L[-1]\n\n\n\n2. House Robber\n\n2.1 Using Dynamic Programming\n📚 Problem Overview:\nYou need to rob houses along a street, but you can’t rob two adjacent houses. The goal is to figure out the maximum amount of money you can rob, without breaking the adjacency rule.\n🤔 Key Observations:\n\nIf you’re at the first house, you can only rob that house.\n\nSo, the maximum money you can rob up to house \\(1\\) is just nums[0].\n\nFor the second house, you either rob the first or the second, but not both.\n\nSo, the max money that you can steal up to house \\(2\\) is \\(max(nums[0], nums[1])\\).\n\nFor any house from the third house onwards, you have two choices:\n\nRob this house and add its money to the max amount from two houses back (since you can’t rob the adjacent house).\nSkip this house and keep the money robbed up to the previous house.\n\n\n💡 The Solution:\nWe use a dynamic programming array maximum_amount where each maximum_amount[i] holds the maximum money you can rob up to house i:\n\nBase cases:\n\nmaximum_amount[0] = nums[0]\nmaximum_amount[1] = max(nums[0], nums[1])\n\nRecursive relation:\n\n\\(maximum\\_amount[i] = max(maximum\\_amount[i-1], maximum\\_amount[i-2] + nums[i])\\)\n\n\nThis ensures that for each house, you decide whether to rob it (and add the money from two houses ago) or skip it (and take the max up to the last house). The result will be the value in maximum_amount[n-1], where n is the total number of houses.\nTime complexity: \\(O(n)\\)\n\n💻 Code Implementation:\nclass Solution:\n    def rob(self, nums: List[int]) -&gt; int:\n        if len(nums) == 1:\n            return nums[0]\n\n        maximum_amount = [0] * len(nums)\n        \n        # Base cases\n        maximum_amount[0] = nums[0]\n        maximum_amount[1] = max(nums[0], nums[1])\n\n        for i in range(2, len(nums)):\n            maximum_amount[i] = max(maximum_amount[i-1], maximum_amount[i-2] + nums[i])\n        \n        return maximum_amount[-1]\n\n\n\n\n3. Fibonacci Numbers\n\n3.1 Using Dynamic Programming\nThis problem is discussed in the lectures. The approach used here is exactly the same.\n\n💻 Code Implementation:\nclass Solution:\n    def fib(self, n: int) -&gt; int:\n        # Initialize the fibtable array to be all zeros\n        fibtable = [0] * (n + 1)\n\n        # Base Case 1: Where n == 0\n        if n == 0: return fibtable[0]\n\n        # Base Case 2: Where n == 1\n        fibtable[1] = 1\n\n        for i in range(2, n + 1):\n            #F(n) = F(n - 1) + F(n - 2)\n            fibtable[i] = fibtable[i - 1] + fibtable[i - 2]\n        \n        # fibtable[i] is the ith fibonacci number. Thus, to get nth fibonacci number, return fibtable[n]\n        return fibtable[n]\n\n\n\n\n4. Triangle\n\n4.1 Using Dynamic Programming\n📚 Problem Overview:\nWe need to find the minimum path sum in a triangle from the top to the bottom. At each step, we can move to the element directly below or diagonally below-right. The task is to minimize the sum of the numbers along this path.\nIn other words, the question is asking for us to find the minimum path sum from the top to the bottom of the triangle, where each step can be to only the ith or i + 1 th cell in the row below.\nOne way we can do this is by listing down all the paths and then take the minimum sum path from that. But it won’t be efficient!\n🤔 Key Observations:\n\nTo get to a certain cell, you can only come from the cell directly above it or the one diagonally left above it.\nThe problem can be broken into smaller subproblems. The minimum path sum at any cell depends on the minimum of the two cells below it.\nFor a cell triangle[row][col], the relation is: \\[MPS(triangle[row][col]) = triangle[row][col] + \\min(MPS(triangle[row + 1][col]), MPS(triangle[row + 1][col + 1]))\\]\nThe base cases are the last row of the triangle. There are no children below, so the values in the last row stay the same.\n\nSince we are solving overlapping subproblems and then combining those subproblems to solve the original problem, we’ll use dynamic programming, starting from the bottom of the triangle and working our way up to the top.\n💡 The Solution Approach:\n\nAfter processing the last row, that is- the row of the base cases, we can move one level up in the triangle.\nAfter processing that level, we get a minimum path of length 2 for each of the cells in the second last row. More generally, after processing a row, each element in that row would hold the minimum path sum from that element to the bottom of the triangle.\nAfter processing the entire triangle, the top element of the triangle would hold the minimum path sum from the top to the bottom of the triangle, which is the answer to the problem.\n\n\n💻 Code Implementation:\nclass Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -&gt; int:\n        # Start from the second-to-last row of the triangle\n        for row in range(len(triangle) - 2, -1, -1):\n            for col in range(len(triangle[row])):\n                # Update the current element with the sum of the element itself\n                # and the minimum of the two adjacent elements in the row below\n                triangle[row][col] = triangle[row][col] +  min(triangle[row + 1][col], triangle[row + 1][col + 1])\n\n        # The top element now contains the minimum path sum\n        return triangle[0][0]\n\n\n\n\n5. Coin Change\n\n5.1 Using Dynamic Programming\n📚 Problem Overview:\nWe need to find the minimum number of coins required to make a given amount. We can use coins from the given list. If it’s impossible to make the amount, return \\(-1\\).\nThe first thought here can be that we need to use the greedy strategy. But as we can see from the test cases, the greedy strategy won’t always give us the optimal solution.\n🤔 Key Observations:\n\nFor any amount, the minimum number of coins to make that amount can be thought of as: \\[ \\text{mincoins}(amount) = \\text{mincoins}(amount - coin) + 1 \\]\nThis means for any amount, we can take a coin and reduce the problem to finding the minimum coins needed for the remaining amount.\nCan you figure out why the subproblems are overlapping?\n\n💡 The Solution Approach:\nSince we have overlapping subproblems, we use dynamic programming:\n\nCreate a dp array of size amount + 1, where dp[i] stores the minimum number of coins to make amount i. Initially, set all values to infinity (inf), except dp[0] = 0, because we need 0 coins to make amount 0.\nFor each coin, update the dp array:\n\nFor every amount from 0 to the given amount, update the minimum coins:\n\\(\\text{dp[i]} = \\min(\\text{dp[i]}, \\text{dp[i - coin]} + 1)\\)\n\nAfter processing all amounts, if dp[amount] is still inf, return \\(-1\\) (because it’s impossible to make that amount). Otherwise, return dp[amount].\n\nTime Complexity: \\(O(amount * coins)\\)\n\n💻 Code Implementation:\nclass Solution:\n    def coinChange(self, coins, amount):\n        # Initialize a dp array where dp[i] will hold the minimum number of coins required for amount i\n        dp = [float('inf')] * (amount + 1)\n        \n        # Base case: No coins are needed to make amount 0\n        dp[0] = 0\n\n        for coin in coins:\n            dp[coin] = 1\n        \n        # Fill the dp array\n        for coin in coins:\n            for x in range(coin, amount + 1):\n                dp[x] = min(dp[x], dp[x - coin] + 1)\n        \n        # If dp[amount] is still inf, it means it's not possible to make that amount with given coins\n        return dp[amount] if dp[amount] != float('inf') else -1\n\n\n\n\n6. Best Time to Buy and Sell Stock III\n\n6.1 Using Dynamic Programming\n📚 Problem Overview:\nWe need to find the maximum profit we can earn by buying and selling a stock at most two times. We need to buy before we can sell the stock. Further, we are allowed to transact either once or twice but not more than twice.\n🤔 Key Observations:\nSince we’re allowed to make two transactions, for any given day, the total profit is the sum of:\n\nMaximum profit before that day.\nMaximum profit after that day.\n\nFor example, let’s take the prices list: [3, 3, 5, 0, 0, 3, 1, 4].\nOn day 3 (price = 0):\n\nMaximum Profit before day 3: The best time to buy and sell before day 3 is buying at 3 (day 0) and selling at 5 (day 2). So, 5-3 = 2.\nMaximum Profit after day 3: The best time to buy after day 3 is buying at 0 (day 3) and selling at 4 (day 7). So, 4 - 0 = 4.\n\nBy adding them together, the total profit on day 3 would be 2 + 4 = 6.\nWe repeat this process for each day to find the total maximum profit. The day with the highest total profit is where we should ideally transact to make the most money!\nThe key idea here is that we can compute the before and after arrays in linear time.\nFor the after array:\n\nWe start from the end of the prices list and keep track of the largest number we’ve seen so far. This largest number will be the selling price for any prices[i] we see along the way.\nSo, for each day, the profit is the difference between the largest number (sell price) and prices[i] (buy price).\n\nWe can do a similar thing for the before array, but instead of keeping track of the largest number, we will track smallest number.\n\n💻 Code Implementation:\nclass Solution:\n    def maxProfit(self, prices: List[int]) -&gt; int:\n        n = len(prices)\n        after = [ 0 ] * n\n        max_from_right = prices[-1]\n\n        # Find out the maximum profit we can earn in one transaction after an index 'i'\n        for i in range(n - 2, -1, -1):\n            max_from_right = max(max_from_right, prices[i + 1])\n            after[i] = max(max_from_right - prices[i], 0)\n            after[i] = max(after[i], after[i + 1])\n\n        # Find out the maximum profit we can earn in one transaction before an index 'i'\n        before = [ 0 ] * n\n        min_from_left = prices[0]\n        for i in range(1, n):\n            min_from_left = min(min_from_left, prices[i - 1])\n            before[i] = max(prices[i] - min_from_left, 0)\n            before[i] = max(before[i], before[i - 1])\n        \n        # Total Profit[i] = before[i] + after[i]\n        # Maximum total profit = max(Total Profit)\n        max_profit = 0 \n        for i in range(n):\n            max_profit = max(before[i] + after[i], max_profit)\n\n        return max_profit\n\n\n\n\n7. Unique Paths-II\n\n7.1 Using Dynamic Programming\nThis is the grid paths with barriers problem discussed in the lecture. We will use the same idea and the code to solve this problem.\n\n💻 Code Implementation:\nimport numpy as np\nclass Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int:\n        x, y = len(obstacleGrid), len(obstacleGrid[0])\n\n        M = np.zeros((x,y))\n\n        # Handle corner case where the starting cell has a barrier\n        if obstacleGrid[0][0] == 0: M[0, 0] = 1\n        else: M[0, 0] = 0\n\n        # Initialize the base cases\n        for i in range(x):\n            for j in range(y):\n                if i == 0 and j &gt; 0 and (obstacleGrid[i][j] == 0):\n                    M[i,j] = M[i, j - 1]\n                if j == 0 and i &gt; 0 and (obstacleGrid[i][j] == 0):\n                    M[i, j] = M[i - 1, j]\n                \n        # If there is obstacle, then there are 0 ways. Else we sum the left and bottom ways\n        for i in range(1,x):\n            for j in range(1,y):\n                if obstacleGrid[i][j] == 1:\n                    M[i,j] = 0\n                else:\n                    M[i,j] = M[i-1,j] + M[i,j-1]\n        return int(M[x-1,y-1])\n\n\n\n\n8. Word Break\n\n💻 Code Implementation:\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool:\n        # Length of the input string\n        n = len(s)\n        \n        # Convert word dictionary to a set for O(1) lookup\n        word_set = set(wordDict)\n        \n        # Initialize the dp array, where dp[i] represents the minimum number of extra chars needed from index i to the end\n        dp = [float('inf')] * (n + 1)\n        dp[n] = 0  # Base case: no extra characters are needed at the end of the string\n        \n        # Populate the dp array from right to left\n        for i in range(n - 1, -1, -1):\n            # Start by treating the character at s[i] as an extra character\n            dp[i] = dp[i + 1] + 1\n            \n            # Check substrings starting from index i to find words in the dictionary\n            for j in range(i + 1, n + 1):\n                substring = s[i:j]\n                \n                # If the substring is a valid word, minimize extra chars by checking dp[j]\n                if substring in word_set:\n                    dp[i] = min(dp[i], dp[j])\n\n                # Early break if dp[i] reaches 0 (no extra chars needed from i onward)\n                if dp[i] == 0:\n                    break\n        \n        # If dp[0] is 0, then the whole string can be segmented without extra chars\n        return dp[0] == 0\n\n\n\n9. Maximum Number of Moves in a Grid\n\n💻 Code Implementation:\ndef maxMoves(grid):\n    # Dimensions of the grid\n    rows, cols = len(grid), len(grid[0])\n\n    # dp[i][j] will store the maximum moves possible starting from cell (i, j)\n    dp = [[0] * cols for _ in range(rows)]\n    max_moves = 0  # This will store the overall maximum moves starting from any cell in the first column\n\n    # Fill the DP table column by column, from right to left\n    for col in range(cols - 2, -1, -1):\n        for row in range(rows - 1, -1, -1):\n\n            # Check the possible cells we can move to in the next column\n            next_cell_up = grid[row - 1][col + 1] if row &gt; 0 else 0\n            dp_next_up = dp[row - 1][col + 1] if row &gt; 0 else 0\n\n            next_cell_right = grid[row][col + 1]\n            dp_next_right = dp[row][col + 1]\n\n            next_cell_down = grid[row + 1][col + 1] if row &lt; rows - 1 else 0\n            dp_next_down = dp[row + 1][col + 1] if row &lt; rows - 1 else 0\n\n            current_cell = grid[row][col]\n\n            # Determine the maximum moves from this cell (row, col)\n            if current_cell &gt;= next_cell_up and current_cell &gt;= next_cell_right and current_cell &gt;= next_cell_down:\n                # No move possible since all adjacent cells have equal or smaller values\n                dp[row][col] = 0\n            else:\n                # Calculate the maximum moves by considering each possible valid move direction\n                max_next_moves = 0\n                if current_cell &lt; next_cell_up:\n                    max_next_moves = max(max_next_moves, dp_next_up)\n                if current_cell &lt; next_cell_right:\n                    max_next_moves = max(max_next_moves, dp_next_right)\n                if current_cell &lt; next_cell_down:\n                    max_next_moves = max(max_next_moves, dp_next_down)\n                \n                dp[row][col] = 1 + max_next_moves\n\n            # Update the maximum moves if we're in the first column\n            if col == 0:\n                max_moves = max(max_moves, dp[row][col])\n\n    return max_moves",
    "crumbs": [
      "DSA",
      "Leet Coding Using Python",
      "Dynamic Programming"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Vikrant",
    "section": "",
    "text": "Order By\n      Default\n      \n        Title\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nReinforcement Learning, Positive Psychology and Life\n\n\n\nData Science\n\nPsychology\n\n\n\n\n\n\n\n\n\nFeb 15, 2025\n\n4 min\n\n\n\n\n\n\n\n\n\n\n\nA Wise Man’s Counsel\n\n\n\nPsychology\n\nBooks\n\n\n\nI think Charlie Munger is one of the wisest men to have ever lived. He didn’t bother writing a book himself, but his wisdom is out there for us to soak up through his letters, speeches, and the incredible Poor Charlie’s Almanack.\n\n\n\n\n\nNov 4, 2024\n\n3 min\n\n\n\n\n\n\n\n\n\n\n\nBuilding an HTTP Server From Scratch\n\n\n\nSoftware Engineering\n\n\n\nServing a web application is as simple as running a single command. But this hides a lot of details. In this post, we create an HTTP server from scratch in Python to peek under the hood.\n\n\n\n\n\nOct 27, 2024\n\n14 min\n\n\n\n\n\n\n\n\n\n\n\nBuilding a Digit Classifier From Scratch\n\n\n\nData Science\n\n\n\nIn this post, I’ll share how I created my first deep learning model. I created a neural network from scratch using FastAI and PyTorch. While I didn’t write code for backpropagation (thankfully, PyTorch is there!), I did write the building blocks myself, which made this incredibly fun!\n\n\n\n\n\nOct 23, 2024\n\n8 min\n\n\n\n\n\n\n\n\n\n\n\nMastering Deep Learning as a Non-Techie\n\n\n\nData Science\n\nPsychology\n\nBooks\n\n\n\nHow do you master deep learning, especially if you’re not a ‘techie’? Radek Osmulski did just this. He went from having a boring job to an exciting career at NVidia. This post tells you how.\n\n\n\n\n\nOct 18, 2024\n\n3 min\n\n\n\n\n\n\n\n\n\n\n\nGrandmaster-ing Life\n\n\n\nChess\n\nBooks\n\n\n\nVishy Anand, the five-time world chess champion, inspires many. His advice, like his chess, is well thought out. Recently, he published his book: “Mind Master: Winning Lessons from a Champion’s life”. Read on to find out Vishy’s take on life.\n\n\n\n\n\nOct 13, 2024\n\n4 min\n\n\n\n\n\n\n\n\n\n\n\nChallenge Accepted!\n\n\n\nBusiness\n\nPeople\n\n\n\nThe incredible journey of Shashikant Parakh, the man who transformed NAMCO Hospital and built a legacy of success through relentless challenges. From business ventures to life lessons, his story is a testament to dreaming big and making a difference.\n\n\n\n\n\nJun 7, 2021\n\n5 min\n\n\n\n\n\n\n\n\n\n\n\nHow Good Is Sleep!\n\n\n\nBooks\n\nPsychology\n\n\n\nWhy do we sleep? How do we sleep? What are dreams? Until now, sleep was a mystery. But the developments in technology allow us to answer such questions. In his bestselling book “ Why We Sleep: The New Science of Sleep and Dreams”, neurologist and sleep researcher Matt Walker answers the same questions. He takes us on a journey from ‘Sleep is good’ to ‘How good is sleep?’\n\n\n\n\n\nMay 16, 2021\n\n10 min\n\n\n\n\n\n\n\n\n\n\n\nUnstoppable!\n\n\n\nBusiness\n\nPeople\n\n\n\nBhavesh Bhatia’s story is nothing short of inspirational. He started with a rented handcart as a store, and built a business employing more than 10,000 people. But there’s something more. Read on to know why Bhavesh is so special.\n\n\n\n\n\nOct 31, 2020\n\n7 min\n\n\n\n\n\n\n\n\n\n\n\nDaring to Execute\n\n\n\nBusiness\n\nPeople\n\n\n\nThree friends, a risky gamble, and a relentless spirit made Reliable Engineers India’s top engineering companies. Rajendra’s business journey is one that only a few will dare to try.\n\n\n\n\n\nOct 31, 2020\n\n7 min\n\n\n\n\n\n\n\n\n\n\n\nMaster Anything With Deliberate Practice\n\n\n\nPsychology\n\nBooks\n\n\n\n\n\n\n\n\n\nAug 28, 2020\n\n10 min\n\n\n\n\n\n\n\n\n\n\n\nWhat Next?\n\n\n\nBusiness\n\nPeople\n\n\n\nMeeting someone in the civil services is a special experience. Getting to interview them is even more special. Read on to know an IPS officer’s journey.\n\n\n\n\n\nJun 29, 2020\n\n6 min\n\n\n\n\n\n\n\n\n\n\n\nNavigating Gold\n\n\n\nBusiness\n\nPeople\n\n\n\nThe man behind the best retail store of India tells his story. Read on to know more.\n\n\n\n\n\nJun 7, 2020\n\n5 min\n\n\n\n\n\n\n\n\n\n\n\nFrom Ashes to an Empire!\n\n\n\nBusiness\n\nPeople\n\n\n\n\n\n\n\n\n\nMay 7, 2020\n\n7 min\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Vikrant",
    "section": "",
    "text": "Hi, I’m Vikrant👋.\nI studied Psychology and completed my B.S. in Data Science from IIT Madras. I currently work in the Big Data team at VuNet Systems, Bangalore.\nOutside of work, I enjoy reading, playing tennis, and theatre. And I strongly believe books are closest things to magic in the world of muggles.\nHere, I share what I’m reading, projects I’m building, and lessons I’m learning along the way.\n\n\nExperience\nVuNet Systems, Bangalore\nData Engineer | Oct 2024 - Present\nWorking with Big Data tech like Kafka & Clickhouse\nIIT Madras, Chennai\nTeaching Assistant | June 2024 - Dec 2024\nHelped students with Data Structures and Algorithms"
  },
  {
    "objectID": "dsa/string-matching/index.html",
    "href": "dsa/string-matching/index.html",
    "title": "String Matching and Tries",
    "section": "",
    "text": "1. Implement a Trie\n📚 Problem Overview:\nWe need to implement the Trie data structure. You can read more about it here.\n💡 The Solution:\n\nFor each node in the Trie, we need to keep track of its children and whether the node is the end of a word. At maximum, each node can have 26 children- one for each letter in the alphabet. We can use a dictionary to represent children (we could also use lists, but not every node is going to have 26 children, which makes it inefficient and complicated when searching ).\nThen we implement the operations, which are similar to Tree operations.\n\n\n💻 Code Implementation:\n\n# Define a helper class for each node in the Trie\nclass TrieNode:\n    def __init__(self):\n        self.children = { }\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word:str) -&gt; None:\n        curr = self.root\n        \n        # Insert each character at new level if it doesn't exist\n        for char in word:\n            if char not in curr.children:\n                curr.children[char] = TrieNode()\n            curr = curr.children[char]\n        curr.is_end_of_word = True\n    \n    def search(self, word:str) -&gt; bool:\n        curr = self.root\n        \n        # As long as you find characters, keep traversing.\n        for char in word:\n            if char not in curr.children:\n                return False\n            curr = curr.children[char]\n        \n        # You may find a character sequence which is not a word- but a prefix. Check for it. \n        if curr.is_end_of_word: return True\n        return False\n\n    def startsWith(self, word:str) -&gt; bool:\n        # Same as above, except no prefix check. Even if you find prefix, return True\n        curr = self.root\n        for char in word:\n            if char not in curr.children:\n                return False\n            curr = curr.children[char]\n        return True",
    "crumbs": [
      "DSA",
      "Leet Coding Using Python",
      "String Matching and Tries"
    ]
  },
  {
    "objectID": "dsa/divide-and-conquer/index.html",
    "href": "dsa/divide-and-conquer/index.html",
    "title": "Divide and Conquer",
    "section": "",
    "text": "1. Merge K Sorted Lists\n📚 Problem Overview:\nWe need to merge several lists into one sorted list. We can use divide and conquer to do this faster!\n💡 The Solution:\n\nIf there are only two lists in the input, merge them.\nOtherwise, split the input list into two halves.\n\nRecursively call merge on the left half\nRecursively call merge on the right half.\nMerge the output from the two halves.\n\n\n\n💻 Code Implementation:\nclass Solution:\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"Code to merge two linked lists\"\"\"\n        if not list1: return list2\n        if not list2: return list1\n        dummy = ListNode()\n        current = dummy\n\n        # Iterate as long as neither list is exhausted\n        while list1 and list2:\n            if list1.val &lt; list2.val:\n                current.next = list1\n                list1 = list1.next\n            else:\n                current.next = list2\n                list2 = list2.next\n            current = current.next\n\n        # Attach the remaining nodes of list1 or list2\n        if list1:\n            current.next = list1\n        elif list2:\n            current.next = list2\n\n        # The merged list is next to the dummy node\n        return dummy.next\n\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n        # Base Cases\n        if not lists:\n            return \n        if len(lists) == 1:\n            return lists[0]\n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n\n        # Split lists into two halves and recursively call merge on them\n        mid = len(lists) // 2\n        left_half = self.mergeKLists(lists[:mid])\n        right_half = self.mergeKLists(lists[mid:])\n\n        return self.mergeTwoLists(left_half, right_half)",
    "crumbs": [
      "DSA",
      "Leet Coding Using Python",
      "Divide and Conquer"
    ]
  },
  {
    "objectID": "dsa/greedy/index.html",
    "href": "dsa/greedy/index.html",
    "title": "Greedy",
    "section": "",
    "text": "1. N Meetings in One Room\n\n1.1 Using Greedy Approach\n📚 Problem Overview:\nWe need to schedule the maximum number of meetings without any conflicts, given two arrays: start and end.\n🤔 Can you find out what type of problem this is?\nIt is a classic interval scheduling problem.\nFrom the lectures, we know we can solve such problems by sorting the schedules based on end times, and selecting the meetings that don’t conflict.\nHere’s how we can solve this:\n\nCombine the start and end arrays into a single array of the form: \\([(start_i, end_i)]\\)\nSort the list based on the end times- earliest end times come first.\nTrack of the end time of the last meeting.\nFor each new meeting:\n\nIf it overlaps with the previous one (starts before the previous one ends), then skip it.\nElse, we increment the meeting count, and update the end time.\n\n\n\n💻 Code Implementation:\nclass Solution:\n    def maximumMeetings(self,n,start,end):\n        # Combine two lists into one\n        times = [ [start[i], end[i]] for i in range(n)]\n        \n        # Sort based on end times\n        times.sort(key=lambda x:x[1])\n        \n        count = 0\n        prev_endtime = None\n        for start_time, end_time in times:\n            # First meeting\n            if not prev_endtime:\n                prev_endtime = end_time\n                count += 1\n            else:\n                # Check if the previous meet's endtime clashes with the start time of the current meet\n                if prev_endtime &lt; start_time:\n                    prev_endtime = end_time\n                    count += 1\n        return count    \n\n\n\n\n2. Activity Selection\n\n2.1 Greedy Approach\nSame approach as the above question.\n\n💻 Code Implementation:\nclass Solution:\n    def activitySelection(self,n,start,end):\n        # Rearrange the start and end arrays into a single array\n        arr = [ [start[i], end[i]] for i in range(n) ]\n\n        # Sort based on end times\n        arr.sort(key=lambda x:x[1])\n\n        count = 0\n        prev_endtime = None\n        for start_time, end_time in arr:\n            # First activity\n            if not prev_endtime:\n                prev_endtime = end_time\n                count += 1\n            else:\n                # Check if the previous activity's endtime clashes with the start time of the current activity\n                if prev_endtime &lt; start_time:\n                    count += 1\n                    prev_endtime = end_time\n        return count\n\n\n\n\n3. Minimum Number of Coins\n🎯 Understanding the Test Cases:\nTest Case 1:\nN = 43\nExplanation:\nThis is the first test case given in the question.\nWe need to find the minimum number of coins/notes to make ₹43. The best combination is:\n\n2 notes of ₹20\n1 coin of ₹2\n1 coin of ₹1\n\nSo, we return [20, 20, 2, 1].\nOther combinations, like [10, 10, 10, 10, 2, 1], are valid but require more coins/notes, so they aren’t optimal.\n\n3.1 Using Greedy\nNote: In general, we cannot say that greedy algorithm will produce correct output for such problems ( we need to use dynamic programming to solve these ). But in this problem, larger denominations can represent multiple smaller ones. For example, 3 coins of value 2 can be replaced by 1 coin of value 5 and 1 coin of value 1. So, we can use fewer large coins to replace many smaller ones.\nThus, we can use Greedy Approach:\n\nStart with the largest denomination.\nSubtract it from the amount until you can’t anymore.\nMove to the next largest and repeat.\nAdd each coin/note used to the result.\n\n\n💻 Code Implementation:\nclass Solution:\n    def minPartition(self, N):\n        denominations = [2000, 500, 200, 100, 50, 20, 10, 5, 2, 1]  # List of denominations in descending order\n        result = []  # List to store the coins/notes used\n        \n        for coin in denominations:\n            while N &gt;= coin:  # Check how many times the coin/note can fit into the remaining amount\n                N -= coin  # Subtract the coin/note value from target\n                result.append(coin)  # Add the coin/note to the result list\n        \n        return result\n\n\n\n\n4. Jump Game\n🎯 Understanding the Test Cases:\nTest Case 1:\nnums = [2,3,1,1,4]\nExplanation:\nFirst, let’s understand the input. \\(nums[0] = 2\\) means that from the \\(0\\) th index we can jump at most 2 steps. That is, we can jump to index 1 or 2. \\(nums[1] = 3\\) means that from \\(1\\) st index we can jump at most 3 steps. That is, we can jump to indices 2, 3, or 4 from the 1st index. We need to find out whether we can reach the last index- index 4- by making the jumps.\n\nFrom index 0, you can jump up to 2 steps (to indices 1 or 2).\nFrom index 1, you can jump up to 3 steps (to indices 2, 3, or 4).\n\nBy jumping 1 step from index 0 to 1, and then 3 steps from index 1 to 4, you reach the last index. So, return True.\nTest Case 2:\nnums = [3,2,1,0,4]\nExplanation:\nFrom index 0, you can jump up to 3 steps (to index 3). But at index 3, you can’t jump any further. No matter how you jump, you can’t reach index 4.\nBut we can also take a jump of 2 steps ( or 1 steps ). Even then the maximum index that we can reach is the index 3. We cannot reach the last index- index 4.\nSo, we return False.\n\n4.1 Using Greedy Approach\n📚 Problem Overview:\nWe need to check if we can reach the last index of the nums array. Each element in nums[i] tells us the maximum jump we can take from index i.\nWe can solve this problem using the Greedy Approach.\n🤔 Greedy Approach:\n\nUse a max_jump variable to keep track of the furthest index we can reach so far.\nIterate Over nums:\n\nAt each step, update max_jump using: max_jump = max(max_jump, nums[idx] + idx).\nIf max_jump reaches or exceeds the last index, return True (we can reach the end!).\n\nIf idx &gt; max_jump, it means we are stuck and can’t move forward, so return False.\n\n\n💻 Code Implementation:\nclass Solution:\n    def canJump(self, nums: List[int]) -&gt; bool:\n        max_jump = 0\n        for idx in range(len(nums)):\n            # idx &lt;= max_jump -&gt; case to check [1, 0, 2] like condition\n            # nums[idx] + idx &gt; max_jump to update the jump\n\n            if idx &lt;= max_jump and nums[idx] + idx &gt; max_jump :\n                max_jump = nums[idx] + idx\n        \n        # Check whether you can reach the last index or not.\n        return max_jump &gt;= len(nums) - 1\n\n\n\n\n5 Jump Game-II\n\nUsing Greedy Approach\nWe can use similar approach as the above question.\n\n💻 Code Implementation:\nclass Solution:\n    def jump(self, nums: List[int]) -&gt; bool:\n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        jump_count = 0\n        current_end = 0\n        max_jump = 0\n        \n        for i in range(n - 1):\n            max_jump = max(max_jump, i + nums[i])\n\n            # When we reach the end of the current jump. For example, [3, 5, 1, 1, 1, 1]\n            if i == current_end:\n                jump_count += 1\n                current_end = max_jump\n                \n                # If we can reach the end, break early\n                if current_end &gt;= n - 1:\n                    break\n        \n        return jump_count",
    "crumbs": [
      "DSA",
      "Leet Coding Using Python",
      "Greedy"
    ]
  },
  {
    "objectID": "dsa/heaps-and-trees/index.html",
    "href": "dsa/heaps-and-trees/index.html",
    "title": "Heaps and Trees",
    "section": "",
    "text": "1. Validate Binary Search Tree\n\n1.1 Using Inorder Traversal\n🎯 Understanding the Test Cases:\nTest Case 1:\nroot = [ 2, 1, 3]\nExplanation:\nThis is the first test case from the problem description. A valid binary search tree is a one where every node’s left child has value less than the node, and the right child has a value greater than the node. That is: \\(left &lt; current &lt; right\\). We can see from the tree that this is indeed the case. So, it is a valid binary search tree.\nTest Case 2:\nroot = [ 5, 1, 4, None, None, 3, 6]\nExplanation:\nThis is the second test case from the problem description. The node with value \\(4\\) is the right child of the node with value \\(5\\). This violates the conditions of a binary search tree. So, we return False. Note that this violation can occur in any internal node- not just the root node.\n📚 Problem Overview:\nIn a binary search tree (BST), the inorder traversal gives a sorted list of elements. If the BST is valid, then it’s inorder traversal will produce a sorted list. If it is not valid, the inorder traversal will not produce a sorted list.\n💡 Approach:\n\nDo inorder traversal on the tree.\nCheck if the result is sorted by comparing each element with the previous one.\n\nIf the list is sorted, the tree is a valid BST. If not, it’s invalid.\n⏳ Time Complexity: \\(O(n)\\)\n\n\nNeed help with implementation?\n\n\nclass Solution:\n    def isValidBST(self, root):\n\n        tree = self.inorder_traversal(root) # Do inorder traversal\n\n        # Base Case: if tree has just one element, then it is a valid BST\n        if len(tree) &lt;= 1:\n            return True\n\n        # If the list is sorted, then the L[i - 1] will always be smaller than L[i]\n        for i in range(1, len(tree)):\n            if tree[i - 1] &gt;= tree[i]:\n                return False\n        return True\n\n    def inorder_traversal(self, root):\n        if not root:\n            return []\n        return self.inorder_traversal(root.left) + [root.val] + self.inorder_traversal(root.right)     \n\n\n\n\n\n\n2. Network Delay Time\n\n2.1 Using Dijkstra\n🎯 Understanding the Test Cases:\nTest Case 1:\ntimes = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2\nExplanation:\nThis is the first test case from the problem description. Starting node is given as \\(k=2\\). From \\(2\\), it will take 1 unit of time to reach both nodes 1 and 3. The signal can travel along both edges in parallel. So reaching both nodes only takes 1 unit of time. But we still have one more node left. After reaching node 3, it will take another 1 unit of time to reach node 4. Once the last node is reached, we return the time taken. In this case, it was 2. Can you relate this to the analogy discussed in one of the lectures?\n📚 Problem Overview:\nWe have an array times where each element times[i] = [u, v, w] represents a directed edge from node u to node v with weight w. The edges are directed and weighted.\nCan you convert the times array into a graph?\nWe can represent the times array as an adjacency list:\nWList = { i:[] for i in range(1, n+1) }\nfor u, v, w in times:\n    WList[u].append((v, w))\nWe need to find out the minimum time it will take for the signal to reach all nodes if started from the node k. Can you identify what type of a problem this is? 🤔\nThis is a shortest path problem. Since the weights are non-negative, we can solve it using Dijkstra’s algorithm. The minimum time for the signal to reach all nodes is the maximum shortest path found after running Dijkstra. In other words, it’s the time when the last node receives the signal.\n\n\nNeed help with implementation?\n\n\nimport heapq\n\nclass Solution:\n    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -&gt; int:\n        # Convert the \"times\" array into an adjacency list\n        WList = { i:[] for i in range(1, n+1) }\n        visited = {i : False for i in range(1, n+1)}\n        for u, v, w in times:\n            WList[u].append((v, w))\n\n\n        # Run Dijkstra on it\n        dist = {node: float('inf') for node in range(1, n+1)}\n        dist[k] = 0\n\n        # Priority queue\n        heap = [(0, k)]  # (distance, node)\n\n        while heap:\n            # By default, heapq.heappop(heap) returns the minimum element from heap\n            current_dist, node = heapq.heappop(heap) \n            visited[node] = True\n\n            if current_dist &gt; dist[node]:\n                continue\n\n            for neighbor, weight in WList[node]:\n                if visited[neighbor]:\n                    continue\n                distance = current_dist + weight\n                if distance &lt; dist[neighbor]:\n                    dist[neighbor] = distance\n                    heapq.heappush(heap, (distance, neighbor))\n\n        # The minimum time taken for the signal to reach all the vertices, is the same as the last vertex to \n        # get \"burnt\" in Dijkstra's algorithm, which is the same as maximum of shortest distance values\n        max_dist = max(dist.values())\n        return max_dist if max_dist != float('inf') else -1 # Check if all nodes can be reached or not.\n\n\n\n\n\n\n3 Maximum Spending After Buying Items\n🎯 Understanding the Test Cases:\nThe test cases given in the problem statement are detailed. So we have not discussed them here. One thing to note in the given test cases: The order in which possible values are getting removed from the matrix is from smallest to largest. Can you think of the reason why?\n\n3.1 Brute Force\nWe are given an \\(m \\times n\\) matrix, and we can take out values only from the right end of each row. Further, the amount spent on a day is defined as day number * value of the product.\nTo maximize spending over m * n days, can you think of which element do we need to remove first? It should be the smallest element that we can remove, because the spending can be maximized if larger values are taken near the end of m * nth day. So, from each rows’ last column, we need to pop the one that is the smallest.\nPseudocode:\n\nKeep a variable for max spending.\nIterate day counter \\(m \\times n\\) times\n\nKeep a minimum value variable.\nFind out the minimum last element for every row- since we can only take elements from the rightmost end.\nPop and multiply the minimum with the day counter and add this to the max spending.\n\n\nTime Complexity: \\(O(m^2n)\\)\n\n\nNeed help with implementation?\n\n\nclass Solution:\n    def maxSpending(self, values: List[List[int]]) -&gt; int:\n        m, n = len(values), len(values[0])  \n        \n        max_spending = 0\n\n        # Iterate over all days\n        for day in range(1, m*n + 1):\n            # Find out the minimum val of the product that can be bought\n            min_val, min_index = float('inf'), None\n            for j in range(m):\n                # Check if the row is not empty\n                # And since only rightmost product can be bought, only compare L[j][-1]th element\n                if values[j] and values[j][-1] &lt; min_val: \n                    min_val = values[j][-1]\n                    min_index = j\n\n            # Pop the minimum value product and add the value to answer\n            product_val = values[min_index].pop()\n            max_spending += day * product_val\n        return max_spending\n\n\n\n\n\n3.2 Using Minheaps\nWe still need to find the minimum of the rightmost elements and add it to the counter. Can you think of a data structure that lets us efficiently remove the minimum element? Minheaps can be used.\nLet’s see how: Let’s assume we have the values array as follows: \\[\n\\begin{bmatrix}\n4 & 3 \\\\\n7 & 5\n\\end{bmatrix}\n\\]\nThe heap will consist of all the rightmost elements: \\(heap = [ 3, 5]\\). From this minheap, we can remove the minimum easily. After delete_min operation, heap looks like: $ heap = [ 5]$ and the matrix values looks like this:\n\\[\n\\begin{bmatrix}\n4 \\\\\n7 & 5\n\\end{bmatrix}\n\\]\nNow, for the first row, the rightmost element is \\(4\\). We need to add it to the minheap for the next iteration for this approach to work well as this: \\(heap = [4, 5]\\). To do this well, we’ll keep track of the row_index to note from which row was this minimum popped.\nHere’s the pseudocode:\n\nKeep the max spending variable\nCreate the minheap for the rightmost elements.\nIterate day counter over \\(m \\times n\\) times\nRemove the minimum from the Minheap.\nFrom the row from which the minimum was popped, insert the new last element in the heap.\n\nTime Complexity: \\(O(mn \\cdot log(m))\\)\n\n💻 Code Implementation:\nclass Minheap:\n    def __init__(self):\n        self.A = []\n\n    def min_heapify(self,k):\n        l = 2 * k + 1\n        r = 2 * k + 2\n        smallest = k\n        if l &lt; len(self.A) and self.A[l][0] &lt; self.A[smallest][0]:\n            smallest = l\n        if r &lt; len(self.A) and self.A[r][0] &lt; self.A[smallest][0]:\n            smallest = r\n        if smallest != k:\n            self.A[k], self.A[smallest] = self.A[smallest], self.A[k]\n            self.min_heapify(smallest)\n        \n    def delete_min(self):\n        item = None\n        if self.A != []:\n            self.A[0],self.A[-1] = self.A[-1],self.A[0]\n            item = self.A.pop()\n            self.min_heapify(0)\n        return item\n\n    def insert_in_minheap(self,d):\n        self.A.append(d)\n        index = len(self.A)-1\n        while index &gt; 0:\n            parent = (index-1)//2\n            if self.A[index][0] &lt; self.A[parent][0]:\n                self.A[index],self.A[parent] = self.A[parent],self.A[index]\n                index = parent\n            else:\n                break\n            \nclass Solution:\n    def maxSpending(self, values: List[List[int]]) -&gt; int:\n        m, n = len(values), len(values[0])  \n\n        # Using Priority Queues- O(mn log(m))\n        heap, max_spending = Minheap(), 0\n\n        # Create a minimum heap from the last elements\n        for i in range(m):\n            heap.insert_in_minheap([values[i][-1], i]) # Every elem in heap is: [value, row_number]\n        \n        # Iterate over days\n        for day in range(1, m*n+1):\n            min_val, min_store_index = heap.delete_min() # Delete based on value\n            values[min_store_index].pop() # Pop from values array\n            max_spending += day * min_val\n            if values[min_store_index]:\n                heap.insert_in_minheap([values[min_store_index][-1], min_store_index])\n\n        return max_spending\n\n\n\n\n4. Average of Levels in Binary Tree\n🎯 Understanding the Test Cases:\nTest Case 1:\nroot = [3,9,20,null,null,15,7]\nExplanation:\nIn the given figure, the first level has only one node. So the average of 1st level is: \\(3\\). In the second level, there are two nodes: 9 and 20. So, the average of the second level is: \\(\\dfrac{(9 + 20 )}{2}\\). Similarly, the third level has two nodes: 15 and 7. So, the average of the third level is: \\(\\dfrac{(15 + 7)}{2}\\). In general, if there are \\(n\\) nodes in a level, we need to return average as: \\(\\dfrac{\\text{sum of the n nodes' values}}{n}\\)\n\nUsing BFS:\n📚 Problem Overview:\nTo find the average of values for each level of the tree, we need to process the tree level-by-level. Remember, a tree is just a graph with no cycles , so we can apply graph algorithms to trees too!\nWhen you hear “level-by-level,” which algorithm comes to mind? 🤔\nYep, good old BFS (Breadth-First Search)! BFS helps us traverse the tree one level at a time, which is exactly what we need here. For each level, we collect all the nodes, then simply compute the average of their values.😊\n\n\nNeed help with implementation?\n\n\nfrom collections import deque\n\nclass Solution:\n    def averageOfLevels(self, root: Optional[TreeNode]) -&gt; List[float]:\n        q = deque()\n        q.append(root)\n\n        answer = []\n        \n        while q:\n            level_sum = 0 # The sum of the values of a given level\n            level_nodes = len(q)  # Number of nodes at the current level\n\n            # Since we use FIFO, this loop ensures that all nodes belonging to one level are popped\n            for i in range(level_nodes):\n                node = q.popleft()\n                \n                level_sum += node.val\n\n                # Add left and right children to the queue if they exist. \n                # Nodes in binary tree have at most 2 neighbors only- the right and left child\n                if node.right: \n                    q.append(node.right)\n                if node.left: \n                    q.append(node.left)\n                    \n            # Calculate the average for the current level\n            answer.append(level_sum / level_nodes)\n\n        return answer\n\n\n\n\n\n\n5. Kth Largest Element in an Array\n📚 Problem Overview:\nThe problem is straightforward. The easiest way to solve this is by sorting the list in descending order and then selecting kth element in the list. But we’re told that we cannot use sorting.\n\nUsing Heaps:\n💡 The Solution:\n\nWe can maintain a min-heap of k elements.\nWhenever we find an element which is bigger than the minimum element in the heap, we need to insert that element in the heap. By doing this, at the end of the iteration, we will have the min-heap of k elements which are the k largest numbers in the array.\nAmong these k largest elements, kth largest element, is the smallest element (if you’re given a list of k elements and you want to find kth largest element, that’s the same as finding the minimum in the list). So at the end, we can pop the smallest element from the min-heap, and return it.\n\n\n\nNeed help with implementation?\n\n\nimport heapq\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -&gt; int:\n        heap = [ ]\n        i = 0\n        ### Initialize heap with the first `k` elements\n        while i &lt; k:\n            heapq.heappush(heap, nums[i])\n            i += 1\n        \n        # If you find greater element than the smallest, pop minimum from heap and insert nums[i].\n        for i in range(i, len(nums)):\n            if heap and heap[0] &lt; nums[i]:\n                heapq.heappop(heap)\n                heapq.heappush(heap, nums[i])\n\n        # minimum of top k largest number = kth largest in the list\n        return heapq.heappop(heap)\n\n\n\n\n\n\n6. Binary Tree Level Order Traversal\n\n\nNeed help with implementation?\n\n\nfrom collections import deque\nclass Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:\n        if not root:\n            return [ ]\n        \n        # Queue to run BFS with\n        q = deque()\n        q.append(root)\n        \n        levelorder = [ ]\n        while q:\n            level = [ ] # One level\n\n            for i in range(len(q)):\n                node = q.popleft()\n                level.append(node.val)\n\n                # Only two neighbors possible- right child or left child\n                if node.left: q.append(node.left)\n                if node.right: q.append(node.right)\n\n            levelorder.append(level)\n        return levelorder\n\n\n\n\n\n7. Maximum Level Sum of a Binary Tree\n\n💻 Code Implementation:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: Optional[TreeNode]) -&gt; int:\n        # Error Case\n        if not root:\n            return [ ]\n\n        # Queue for running BFS   \n        q = deque()\n        q.append(root)\n\n        # Compute Level Orders\n        levelorder = [ ]\n        while q:\n            row = [ ]\n            for i in range(len(q)):\n                node = q.popleft()\n                row.append(node.val)\n                if node.left: q.append(node.left)\n                if node.right: q.append(node.right)\n            levelorder.append(row)\n        \n        # Find maximum of the level orders\n        maximum = float('-inf')\n        maxlevel = -1\n        for i, level in enumerate(levelorder):\n            if sum(level) &gt; maximum:\n                maxlevel = i\n                maximum = sum(level)\n        return maxlevel + 1",
    "crumbs": [
      "DSA",
      "Leet Coding Using Python",
      "Heaps and Trees"
    ]
  },
  {
    "objectID": "dsa/graphs/index.html",
    "href": "dsa/graphs/index.html",
    "title": "Graphs: BFS & DFS",
    "section": "",
    "text": "1. Find the Town Judge\n🎯 Understanding the Test Cases:\nTest Case 1:\nn = 3, trust = [[1, 3], [2, 3]]\nExplanation:\nThere are 3 people in the town. Person 1 trusts Person 3, and Person 2 also trusts Person 3. Person 3 doesn’t trust anyone, and both other people trust Person 3. This means Person 3 meets the conditions of being the town judge: trusted by everyone but trusts nobody. Hence, he is the town judge.\nTest Case 2:\nn = 3, trust = [[1, 3], [2, 3], [3, 1]]\nExplanation:\nThere are 3 people in the town. Person 1 trusts Person 3, and Person 2 also trusts Person 3. Person 3 trusts Person 1, which means Person 3 is not trusted by everyone (because Person 1 and Person 2 trust Person 3, but Person 3 also trusts Person 1). The town judge must trust nobody and be trusted by everyone else. Since Person 3 doesn’t meet this condition (because they trust Person 1), there is no town judge. So we return -1.\n\n1.1 By Counting Indegrees\nWe have an array trusts, where each entry \\(trusts[i] = [a_i, b_i]\\) tells us that \\(a_i\\) trusts \\(b_i\\).\n\n\n\n\n\n\nTipQuestion:\n\n\n\nIf \\(a_i\\) trusts \\(b_i\\), how could we represent this in a graph?\n\n\nIf \\(a_i\\) trusts \\(b_i\\) then we can consider it an edge from \\(a_i\\) to \\(b_i\\).\nFinding the Town Judge:\nThe town judge is a person who:\n\nTrusts no one \\(\\implies\\) Outdegree = 0\nIs trusted by everyone except himself \\(\\implies\\) Indegree = n - 1\n\nTo solve this, we can use dictionaries:\n\nIndegree Dictionary : Tracks how many people trust each person.\nOutdegree Dictionary : Tracks how many people each person trusts.\n\n\nHow can we use these dictionaries to find the town judge?\nWe can check if someone has an outdegree of 0 and an indegree of n-1. Since the town judge is unique, whenever we find such person, we can return it.\n\nTime complexity: \\(O(|E| + n)\\), where \\(|E|\\) is the number of edges in the graph, and \\(n\\) is the number of nodes.\n\n\nNeed help with implementation?\n\n\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -&gt; int:        \n        if n &lt;= 1:\n            return 1\n\n        indegrees = { }\n        outdegrees = { }\n\n        # trust = [a_i, b_i]\n        # a_i -&gt; b_i\n        for a, b in trust:\n            if a not in indegrees: indegrees[a] = 0\n            if b not in indegrees: indegrees[b] = 0\n            if a not in outdegrees: outdegrees[a] = 0\n            if b not in outdegrees: outdegrees[b] = 0\n\n            outdegrees[a] += 1\n            indegrees[b] += 1\n        \n        # If indegree == n - 1 and outdegree == 0, then we have found the town judge.\n        townjudge = -1\n        for person in indegrees:\n            if outdegrees[person] == 0:\n                if indegrees[person] &gt;= n - 1:\n                    townjudge = person \n                    break\n        return townjudge        \n\n\n\n\n\n\n2. Course Schedule-I\n🎯 Understanding the Test Cases:\nTest Case 1:\nnumCourses = 3, prerequisites = [[1,0], [2, 1]]\nExplanation:\nThere are a total of 3 courses to take. To take course \\(1\\) you should have finished course \\(0\\). To take the course \\(2\\), you need to finish course \\(1\\). If a student decides to pursue courses as follows: \\(0, 1, 2\\), then all courses can be completed. So we return True.\nTest Case 2:\nnumCourses = 2, prerequisites = [[1,0], [0, 1]]\nExplanation:\nThere are a total of \\(2\\) courses to take. To take course \\(1\\) you should have finished course \\(0\\). To take the course \\(0\\), you need to finish course \\(1\\). It is not possible for a student to complete both courses. So we return False. In essence, there is a cycle in the prerequisites.\n\n2.1 Topological Sorting\n🔍 Problem Understanding:\nWe have a list of prerequisites where each pair \\(prerequisites[i] = [a_i, b_i]\\) means that you need to complete \\(b_i\\) before taking \\(a_i\\). In simpler terms, \\(a_i\\) depends on \\(b_i\\).\n\n\n\n\n\n\nTipQuestion🤔:\n\n\n\nHow can we convert this into a graph?\n\n\nIf \\(b_i\\) needs to be completed before \\(a_i\\), we add a directed edge from \\(b_i \\rightarrow a_i\\). Note the direction of the edge. For this problem, we are converting the prerequisites array into graph using adjacency matrix.\n\n\n\n\n\n\nTip\n\n\n\nHow do we find a sequence of courses that respects all the dependencies? Which algorithm should we use?\n\n\nOnce we have converted this problem into a graph problem, we can use the topological sorting to find the sequence that respects all the dependencies. You can also solve this problem using BFS or DFS by detecting cycles in the graph. Here, we’re using topological sort.\n\n\n\n\n\n\nTipQuestion:\n\n\n\nWhen would we say that we have successfully found the sequence of courses satisfying the dependencies?\n\n\nWhen we the sequence includes all the courses, and no course is left. If a course is left out, that means we can’t complete all the courses because there’s a cycle in the graph.\n\n\nNeed help with implementation?\n\n\nclass Solution:\n    def preprocessing(self, numCourses, prerequisites) -&gt; list[list[int]]:\n        adjacency_matrix = [ [0 for i in range(numCourses)] for i in range(numCourses) ]\n        for a, b in prerequisites:\n            adjacency_matrix[b][a] = 1\n        return adjacency_matrix\n\n    # Implementation of Topological sort for Adjacency matrix\n    def toposort(self, AMat):\n        #Initialization\n        (rows,cols) = len(AMat), len(AMat[0])\n        indegree = {}\n        toposortlist = []\n        \n        #Compute indegree for each vertex\n        for col in range(cols):\n            indegree[col] = 0\n            for row in range(rows):\n                if AMat[row][col] == 1:\n                    indegree[col] = indegree[col] + 1\n        \n        # Topological sort Computing process\n        for i in range(rows):\n            # Select the min level vertex for removing the graph which has indegree 0\n            zero_indegree = [k for k in range(cols) if indegree[k] == 0]\n            if not zero_indegree:return toposortlist #Handle the case where there are no more zero indegree vertices\n            \n            j = zero_indegree[0]\n            # Store the removed vertex j in toposortlist and reduce the indegree by one \n            toposortlist.append(j)\n            indegree[j] = indegree[j] - 1\n            \n            # Reduce the indegree of each adjacent of the removed vertex j by 1\n            for k in range(cols):\n                if AMat[j][k] == 1:\n                    indegree[k] = indegree[k] - 1\n                    \n        return(toposortlist)\n\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n        adjacency_matrix = self.preprocessing(numCourses, prerequisites)\n        toposortlist = self.toposort(adjacency_matrix)\n        if len(toposortlist) == numCourses: return True\n        return False\n\n\n\n\n\n2.2 Topological Sort: Better Implementation\nThe approach used is similar to the above approach. However, we are using better data structures to increase our performance. Instead of keeping an adjacency matrix, we are using doubly ended queues and adjacency lists.\nHere’s how:\n\nKeep a deque for vertices with zero degree queue such that the insert at end and delete from start operations are both constant time.\nKeep a dictionary of indegrees which counts the indegrees for each vertex\n\nTime Complexity: \\(O(|V| + |E|)\\)\n\n\nNeed help with implementation?\n\n\nfrom collections import deque, Counter\n\nclass Solution:\n    def canFinish(self, numCourse, prerequisites):\n        AList = { i: [] for i in range(numCourse)}\n        indegree = Counter()\n        visited = { i:False for i in range(numCourse)}\n\n        for course, prereq in prerequisites:\n            AList[prereq].append(course)\n            indegree[course] += 1\n    \n        # Initialization\n        toposortlist = []\n        zerodegreeq = deque()\n        \n        # Code from PDSA Book\n        for u in range(numCourse):\n            if indegree[u] == 0:\n                zerodegreeq.append(u)\n\n        while (zerodegreeq):\n            curr_vertex = zerodegreeq.popleft()        \n            toposortlist.append(curr_vertex)\n            indegree[curr_vertex] = indegree[curr_vertex]-1\n            \n            for adj_vertex in AList[curr_vertex]:\n                indegree[adj_vertex] = indegree[adj_vertex] - 1\n                if indegree[adj_vertex] == 0:\n                    zerodegreeq.append(adj_vertex)                \n        \n        return len(toposortlist) == numCourse\n\n\n\n\n\n\n3. Course Schedule-II\nThis problem is an exact replica of the above problem, except that we have to return a sequence that satisfies the dependencies, instead of returning a boolean of whether or not we can create such a sequence.\nWe can use the same approaches discussed in the above question.\n\n\n4. Snakes and Ladders\n🎯 Understanding the Test Cases:\nPlease refer to the Problem Overview where we have discussed the first test case.\n\n4.1 Using BFS\n📚 Problem Overview:\nWe have a board with \\(n^2\\) cells, and from any cell, we can make up to 6 possible moves. Can we turn this into a graph? Yes! Here’s how:\n\nStart at cell 1.\nWe can roll a dice and move to next six cells. In the first test cases, the next possible moves are: 15, 3, 4, 5, 6, 7 (because cell 2 has a ladder to 15). If a cell has \\(-1\\) value, then it’s an empty cell. But if it has a different value, then it is either a snake or a ladder.\nEach possible move from a cell is an edge in our graph.\nOnce we have the graph, We need to find the least number of moves required to go from cell 1 to cell \\(n^2\\). This is a shortest path problem where there are no weights on the edges- we can use Breadth-First Search (BFS).\n\nPseudocode:\n\nWe first need to convert the board into a graph.\n\nFor every cell, check the next six cells.\n\nIf the cell has a ladder or a snake, then we need to find out where the ladder ends which is given in cell: board[row][col]\nIf the cell does not have a ladder or a snake, then board[row][col] will have the vaue \\(-1\\).\nAdd the edge as: [cell] to board[row][cell] or the next moves.\n\n\nOnce we have the graph, we can run BFS on this graph, which will return the shortest path.\n\n\n\nNeed help with the implementation?\n\n\n\nfrom collections import deque\n\n# The BFS code from the PDSA book\ndef BFSListPathLevel(AList,v):\n    (level,parent) = ({},{})\n    for each_vertex in AList.keys():\n        level[each_vertex] = -1\n        parent[each_vertex] = -1\n    \n    q = deque()\n    \n    level[v] = 0\n    q.append(v)\n    \n    while q:\n        curr_vertex = q.popleft()\n        for adj_vertex in AList[curr_vertex]:\n            if (level[adj_vertex] == -1):\n                level[adj_vertex] = level[curr_vertex] + 1\n                parent[adj_vertex] = curr_vertex\n                q.append(adj_vertex)\n                \n    return(level,parent)\n\nclass Solution:\n    def get_indices(self, cell, n):\n        \"\"\"\n        A helper function to convert the Boustrophedon style sequence \n        into a cell's row and column index\n        \"\"\"\n        remainder = (n - 1) % 2\n        row = (n - 1) - ((cell - 1) // n)\n        if row % 2 == remainder:\n            col = (cell % n) - 1 if cell % n != 0 else n - 1\n        else:\n            col = (n) - (cell % n) if cell % n !=0 else 0\n        return row, col\n\n    def preprocessing(self, board:List[List[int]]) -&gt; list[list[int]]:\n        \"\"\"Converts the board into a graph\"\"\"\n        n = len(board)\n        AList = {i:set() for i in range(1, n*n + 1)}\n        for i in range(1, n*n + 1):\n            for j in range(i + 1, min(i + 7, n*n + 1)): \n                row, col = self.get_indices(j, n)\n                val = board[row][col]\n                if val == -1:\n                    AList[i].add(j)\n                else:\n                    if val == i:\n                        continue\n                    AList[i].add(val)\n        return AList            \n            \n    def snakesAndLadders(self, board: List[List[int]]) -&gt; int:\n        n = len(board)\n        AList = self.preprocessing(board)\n        level, parent = BFSListPathLevel(AList, 1)\n        return level[n*n] # The last cell holds shortest path from start to the last cell\n\n\n\n\n\n\n5. Sort Items By Groups Respecting Dependencies\n\n5.1 Using Topological Sort\n📚 Problem Overview:\nWe need to order a list of items so that all items in the same group are listed next to each other. Additionally, some items have dependencies, meaning one item must be completed before another. We can use topological sort to solve this problem.\n🤔 The Issue:\nIf we just run topological sort on the beforeItems array, it might work for some test cases, but not all.\n\n\n\n\n\n\nTipQuestion:\n\n\n\nCan you think of the test cases where this approach will fail?\n\n\nImagine this situation:\nGroup 0: Items [1, 2]\nGroup 1: Items [3, 4]\nHere’s the setup:\nItem 1 has no dependencies (indegree[1] = 0). Item 3 also has no dependencies (indegree[3] = 0). Item 2 and Item 4 each have one dependency (indegree[2] = 1 and indegree[4] = 1).\nNow, assume:\nItem 2 must come before Item 4. Item 1 must come before Item 2. This means the correct order should be: 1 → 2 → 4.\nThe problem arises when choosing between Item 1 and Item 3, as both have no dependencies. If we choose Item 3 first, we should list the other items from Group 1 next to it, leading to an order like this: 3, 4. This leaves us with Group 0 and the sequence 1, 2. The final order would be 3, 4, 1, 2, which breaks the dependency 1 → 2 → 4. (Draw these nodes and edges to get a clearer picture!)\n💡 The Solution:\nTo solve this, we need to track the dependencies of both individual items and groups. Here’s how we can do that:\n\nCreate Two Graphs:\n\nItem Graph: Use the beforeItems array to build a graph showing how items depend on each other.\nGroup Graph: Also use the beforeItems array to build a graph showing how groups depend on each other.\nWe can use either the adjacency list or the adjacency matrix representation. Here, we are using the adjacency list representation.\n\nRun Nested Topological Sort:\n\nOuter graph to perform topological sorting on the group graph.\nThen, within each group, sort the items using topological sorting.\n\n\n\n\nNeed help with the implementation?\n\n\nfrom collections import deque\n\nclass Solution:\n    def get_group_wise_elements(self, group, m):\n        \"\"\"Helper function to quickly access all items belonging to a group\"\"\"\n        group_wise_elements = { i:[] for i in range(m) }\n        for i in range(len(group)):\n            grp = group[i] if group[i] &gt;= 0 else -i-1\n            if grp not in group_wise_elements:\n                group_wise_elements[grp] = []\n            group_wise_elements[grp].append(i)\n        return group_wise_elements\n\n    def preprocessing(self, beforeItems, group, m, n, groupwise_items):\n        \"\"\"\n        Given the beforeItems array, this function converts it into two graphs- Groups and Items. \n        Along with it, we are also returning the indegrees of each of the graphs' nodes so that we \n        can smoothly run topological sort. \n        \"\"\"\n        group_indegree, items_indegree = {}, {i:0 for i in range(n)}\n        items_alist =  {i:[] for i in range(n)}\n        group_alist = {}\n\n        for key in groupwise_items:\n            group_alist[key] = set()\n            group_indegree[key] = 0\n \n        for i in range(len(beforeItems)):\n            before = beforeItems[i]\n            for num in before:\n                if num not in items_alist:\n                    items_alist[num] = [ ]\n                items_alist[num].append(i)\n                items_indegree[i] += 1\n\n                grp_num = group[num] if group[num] &gt;= 0 else -num-1\n                grp_i = group[i] if group[i] &gt;= 0 else -i-1  \n                if grp_num != grp_i:\n                    if grp_num not in group_alist:\n                        group_alist[grp_num] = set()\n                    group_alist[grp_num].add(grp_i)\n        \n        for key in group_alist.keys():\n            group_alist[key] = list(group_alist[key])\n\n        for start_node in group_alist.keys():\n            for end_node in group_alist[u]:\n                if end_node not in group_indegree:\n                    group_indegree[end_node] = 0\n                group_indegree[end_node] += 1\n\n        return items_alist, group_alist, items_indegree, group_indegree\n\n    \n    def lpath(self, items_alist, group_alist, items_indegree, group_indegree, groupwise_items, n, group):\n        \"\"\"The actual nested topological sorting algorithm\"\"\"\n        output = [ ]\n\n        grp_queue = deque()\n        items_queue = deque()\n\n        for grp in group_indegree:\n            if group_indegree[grp] == 0:\n                grp_queue.append(grp)\n\n        # Outer topological sort is for groups\n        while grp_queue:\n            curr_grp = grp_queue.popleft()\n            group_indegree[curr_grp] -= 1\n            for adj_grp in group_alist[curr_grp]:\n                # Reduce the indegree of each adjacent group of the removed vertex by 1\n                group_indegree[adj_grp] -= 1\n\n                # Add new zero degree groups to the group deque\n                if group_indegree[adj_grp] == 0 :\n                    grp_queue.append(adj_grp)\n\n            # For popped group, find out zero degree items\n            for i in groupwise_items[curr_grp]:\n                if items_indegree[i] == 0 :\n                    items_queue.append(i)\n\n            # Topological sort is for the items\n            while items_queue:\n\n                # Remove one vertex from items queue which have zero degree items and reduce the indegree\n                curr_vertex = items_queue.popleft()\n                output.append(curr_vertex)\n                items_indegree[curr_vertex] = items_indegree[curr_vertex] - 1\n                \n                # Repeat for each adjacent of the removed item \n                for adj_vertex in items_alist[curr_vertex]:\n                    # Reduce the indegree of each adjacent of the removed item by 1\n                    items_indegree[adj_vertex] = items_indegree[adj_vertex] - 1\n\n                    # Add items to items deque if their indegree becomes zero\n                    if items_indegree[adj_vertex] == 0 and group[adj_vertex] == curr_grp:\n                        items_queue.append(adj_vertex)\n\n        if len(output) != n: return []\n        return output\n\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -&gt; List[int]:\n        group_wise_items = self.get_group_wise_elements(group, m)\n\n        items_alist, group_alist, items_indegree, group_indegree = self.preprocessing(beforeItems,group, m, n, group_wise_items)\n        \n        return self.lpath(items_alist, group_alist, items_indegree, group_indegree, group_wise_items, n, group)\n\n\n\n\n\n\n6. Find If Path Exists\n\n6.1 Using BFS\n🎯 Understanding the Test Cases:\nWe have not discussed test cases as it is an easy problem.\n📚 Problem Overview:\nWe need to figure out if we can go from a source node to a destination node. This is a reachability problem in a graph. We know we can use BFS or DFS on an adjacency list or a matrix for reachability problem.\nCan you convert the given edges list into an adjacency list or an adjacency matrix representation? - We have a list of edges where each edges[i] = [u, v] shows an edge between nodes u and v. - To create an adjacency list, we can do:\nfor u, v in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n💻 Code Implementation:\nNote: For a better, more neat code, we have used the deque data structure from the collections module in Python. We can use it to implement a queue used in BFS. It’s a useful data structure to know.\n\n\nNeed help with the implementation?\n\n\nfrom collections import deque\n\nclass Solution:\n    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -&gt; bool:\n        adj_list = { i:[ ] for i in range(n) }\n        visited = set()\n\n        # Create the adjacency list representation from Graph\n        for u, v in edges:\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n\n        queue = deque([source])\n        visited.add(source)\n        while queue:\n            vertex = queue.popleft()\n            if vertex == destination:\n                return True\n            for neighbor in adj_list[vertex]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n                    visited.add(neighbor)\n        return False\n\n\n\n\n\n\n\n7. Number of Provinces\n🎯 Understanding the Test Cases:\nWe have not discussed test cases as it is an easy problem.\n📚 Problem Overview:\nWe are given a matrix isConnected where each entry [i][j] tells us if there is a connection (edge) between nodes i and j. We can think of this as an adjacency matrix for a graph.\nA province is a group of nodes that are all connected. The task is to count how many such provinces exist.\n\n\n\n\n\n\nTip\n\n\n\n🤔 Can you think of a similar problem that we saw in the lectures?\n\n\nThis is a connected components problem. We need to find how many separate groups of connected nodes exist in the graph.\n💡 The Solution:\nTo solve this, we can use either BFS or DFS. For this explanation, we’ll go with BFS to explore each connected component one by one.\n\n\nNeed help with the implementation?\n\n\nfrom collections import deque\n\nclass Solution:\n    def get_neighbors(self, AMat, vertex):\n        \"\"\"Helper function to find out all neighbors of a node given the adjacency matrix.\"\"\"\n        neighbors = []\n        for i in range(len(AMat)):\n            if AMat[vertex][i] == 1:\n                neighbors.append(i)\n        return neighbors\n\n    def BFS(self, AMat, source):\n        \"\"\"\n        Runs BFS from a given source vertex and returns the set of vertices visited in that run of BFS.\n        That is, each run of the BFS will give us one province, or one connected component.\n        \"\"\"\n        visited = set()\n        queue = deque([source])  # Initialize the queue with the source vertex\n        visited.add(source)\n        while queue:\n            vertex = queue.popleft()\n            neighbors = self.get_neighbors(AMat, vertex)  # Pass both AMat and vertex\n            for neighbor in neighbors:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n                    visited.add(neighbor)\n        return visited\n\n    def findCircleNum(self, isConnected):\n\n        # Initially, every vertex gets an invalid component number\n        components = {i: -1 for i in range(len(isConnected))}\n\n        # Keep track of the component number and the number of vertices already visited across BFS runs\n        component_number = 0\n        seen = 0\n        \n        while seen &lt; len(isConnected):\n            startvertex = min([i for i in range(len(isConnected)) if components[i] == -1])\n            visited = self.BFS(isConnected, startvertex)\n\n            # For every vertex that was visited in the current run of BFS, update its component number and update \n            # the number of vertices seen.\n            for vertex in visited:\n                components[vertex] = component_number\n                seen += 1\n\n            # Increment component number such that for the next run of BFS, \n            # a different component number will be assigned\n            component_number += 1\n            \n        return component_number",
    "crumbs": [
      "DSA",
      "Leet Coding Using Python",
      "Graphs: BFS & DFS"
    ]
  },
  {
    "objectID": "posts/mab-and-advice-on-life/index.html",
    "href": "posts/mab-and-advice-on-life/index.html",
    "title": "Reinforcement Learning, Positive Psychology and Life",
    "section": "",
    "text": "The Multi-Armed Bandit Problem\nThe Multi-Armed Bandit (MAB) problem is an important idea in reinforcement learning. But you don’t need to know anything about reinforcement learning to see how the idea can be applied to our lives. Simply read on.\nIn the MAB problem, you’re in a situation wherein you have several actions to choose from. Each time you choose an action, you might get a reward, but the reward is not the same every time. You can also not get a reward. The goal of the problem is to find which action gives the best average reward when you choose it many times.\nIn the perfect world, you could try each action infinite number of times and know exactly how good each one is. Unfortunately, the perfect world isn’t real-life. In real life, we would want to know which is the best action as quickly as possible. This is where regret comes in.\n\n\nWhat’s Regret?\nIn the context of MAB, regret has a similar meaning to how we would use it in day-to-day lives. Regret is simply the loss due to not doing the best thing. The difference between the best action’s reward and the current action’s reward is regret.\nNow, let’s see a visual representation of this.\n\n\nImage Credits: Professor B. Ravindran’s Slides on Reinforce Learning\n\nThe dotted line is the best reward. The solid line is the reward due to the actions that we take. The total regret is the area between the dotted line and the solid line!\nThe whole problem of solving MAB reduces to minimizing regret!\n\n\nHow Can Regret Minimization Help Us?\nThe observations and solutions of the MAB problem can give us incredible insights about how to go about life. Here are the ones that I like the most:\n\nRegret always grows over time! You can see this in the plot also. No matter how hard you try, you’re always going to regret something. Simply accepting this fact can be comforting, instead of obsessing over the regrets that you have.\nWhen you are not sure about doing something, project yourself forward to the age of 80, and ask yourself: When I am looking back on my life, will I regret not doing this?1 This makes the decision easier in many ways.\nLastly, knowing what not to do is often more useful than knowing what to do. If we know the most common regrets that people have, we can strive to avoid those regrets. I refer you to the wonderful, The Top 5 Regrets of Dying2 on this. But here’s a quick list of the things that people regret the most:\n\nI wish I’d had the courage to live a life true to myself, not the life others expected of me\nI wish I hadn’t worked so hard.\nI wish I’d had the courage to express my feelings.\nI wish I had stayed in touch with my friends.\nI wish that I had let myself be happier.\n\n\nMaximizing what we want in life may very well be minimizing what we don’t want in life. Regret minimization is a tool towards that.\nSo, as you stand at your own crossroads, ask yourself—what decision today will lead to the fewest regrets tomorrow?\n\nNote:\nThe MAB is more about trying to figure out how to tackle explore-exploit dilemma, which also has interesting applications to our lives and the decisions we make. But I find this connection between regret minimization and decisions about life to be fascinating. It’s worth exploring more about the explore-exploit dilemma. See references for the same.\n\n\n\n\nReferences\n\nAlgorithms To Live By, Tom Griffiths and Brian Christian. This is a wonderful exposition on how different computer science algorithms can be used in everyday lives. Has more details on the explore-exploit dilemma.\nRegrets of the Dying by Bronnie Ware. Her Bio: Bronnie Ware spent several years caring for dying people in their homes. Her full-length memoir, The Top Five Regrets of the Dying, shares further wisdom from dying people and how Bronnie’s own life was transformed through this learning. It is available in 32 languages. http://bronnieware.com/regrets-of-the-dying."
  },
  {
    "objectID": "posts/creating-http-server-from-scratch/index.html",
    "href": "posts/creating-http-server-from-scratch/index.html",
    "title": "Building an HTTP Server From Scratch",
    "section": "",
    "text": "Running a web server can seem like magic- you type a command fastapi dev main.py or node app.js, and boom, your app is live on a server. But have you ever wondered what’s happening behind the scenes? In this post, we’ll build our own HTTP server from scratch and know what really goes on under the hood!\n\nWhat’s HTTP?\nHTTP is one set of rules (called a protocol) that computers use to talk to each other over the internet. It’s ‘text-based,’ meaning it sends and receives plain text messages. Don’t worry if this doesn’t make sense just yet- by the end of this blog, you’ll know exactly how it works!\n\n\nWhat’s a Server?\nAt its core, a server responds to requests of clients. Think of it like this: a client (like your web browser) asks for something, and the server sends it back. But how do they “talk” to each other? How does the server know what to send?\nTo make this interaction happen, there are two things we need:\n\nThe server needs to listen for and accept connections from clients. Clients will send requests as bytes (just raw data).\nThe server should then figure out what the client wants (like a webpage) and respond with the right data- again, as bytes.\n\nThis is our wishlist for the server. Now, let’s see how we can make this happen:\nTo start, we need a TCP Server. A TCP server listens for requests and ensures that data is sent and received reliably. This will let us connect with clients, the first item in our wishlist. Let’s break this down step by step with code:\n\nImplementing a TCP Server:\nFirst, we need to import the socket library, which is needed to set up the server to accept connections. It’s for handling low-level networking interfaces, which we don’t need to worry ourselves with.\nimport socket\nNow, let’s define a class called TCPServer. This class will set up a server that listens for client connections.\nclass TCPServer:\n    def __init__(self, port=8080) -&gt; None:\n        self.host = \"127.0.0.1\"  # Localhost IP\n        self.port = port  # The port number the server will listen on\nHere, we are specifying that our server will run on localhost (127.0.0.1) on port 8080. The __init__ function initializes our server with these default values.\nTo make our server actually do something, we need to set it up to listen for client requests:\ndef start(self):\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.bind((self.host, self.port))  # Bind the server to the host and port\n    s.listen(5)  # The server can accept up to 5 connections at a time\nWe don’t need to know details of these methods right now. Just know that this code sets up a server that listens for up to 5 client requests at a time. That’s all we need for now!\nOnce the server is listening, we need to accept the connection request from the client and handle it. This is done using accept() and recv() methods. And we need the server to keep listening to incoming requests, so put this in an infinite loop:\nwhile True:\n    conn, addr = s.accept()  # Accept a new connection\n    print(f\"Connection established with {addr}\")\n    data = conn.recv(2048)  # Read data from the client (2KB max)\ns.accept() waits until a client connects. Once connected, it returns two things:\n\nconn: the connection object to communicate with the client.\naddr: the client’s address.\n\nrecv(2048) reads up to 2048 bytes (2 KB) of data sent from the client.\nAt this point, the server is simply waiting for a request from client and accepting the data sent in the request.\nAfter receiving the data, we need to process it and send a response back to the client:\n    response = self.handle_request(data)  # Process the client request\n    conn.sendall(response)  # Send the response back to the client\n    conn.close()  # Close the connection\nhandle_request(data) is a method that we’ll implement later to process the client’s request. This is where we meet the second requirement of the server- understanding what the client wants and sending the response back.\nsendall() sends the response back to the client, and conn.close() closes the connection.\nAnd that’s it! With this setup, our server can accept and respond to client requests.\nHere’s the full version of the code:\nimport socket\n\nclass TCPServer:\n    def __init__(self, port=8080) -&gt; None:\n        self.host = \"127.0.0.1\"\n        self.port = port\n\n    def start(self):\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.bind((self.host, self.port))\n        s.listen(5)\n\n        while True:\n            conn, addr = s.accept()  # Accept new connection\n            print(f\"Connection established with {addr}\")\n            data = conn.recv(2048)  # Receive data from client\n            response = self.handle_request(data)  # Process the request\n            conn.sendall(response)  # Send the response back to the client\n            conn.close()  # Close the connection\n\n    def handle_request(self, data):\n        pass  # To be implemented later\n\n\n\n\nBuilding the HTTP Server\nOkay, so we’ve got our TCP server ready, and it’s time to implement the most important part—the handle_request function. This is where our server takes the request, figures out what the client wants, and then sends back a proper response.\nBut how does the server know what the client wants?\nThe client’s request comes as a stream of bytes. But HTTP is a text-based protocol, meaning that the request can be converted to text and it follows specific rules and formats. So we convert those bytes into strings and parse that string to understand what the client is asking for.\nHTTP requests have a fixed format which we can use to extract information from the request, like:\n\nThe method (e.g., GET or POST)\nThe URI (what page or resource the client wants)\nThe headers (extra info about the request)\nThe body (optional data sent by the client)\n\nNote: Refer to this website to know the structure of HTTP request.\n\nclass HTTPServer(TCPServer):\n    def __init__(self, port=8080) -&gt; None:\n        super().__init__(port)\n\n    def handle_request(self, data):\n        data = data.decode() # convert bytes into string\n        request = self.parse(data)\n\n        self.create_response() # Implemented later\n\n    def parse(self, data:str):\n        \"\"\"\n        This function will parse the HTTP request and return the method, URI, headers, and body.\n        \"\"\"\n        request = {}\n        lines = data.split(\"\\r\\n\")  # Split the request by line\n\n        # First line contains method, URI, and HTTP version\n        request_line = lines[0]\n        words = request_line.split(\" \")\n        request['method'] = words[0]\n\n        if len(words) &gt; 1:\n            # For some requests, URI might be missing (e.g., homepage)\n            request['uri'] = words[1] \n\n        if len(words) &gt; 2:\n            request['http_version'] = words[2]\n\n        # Now let's extract headers and body\n        body = ''\n        in_headers = True\n        request['headers'] = {}\n\n        for line in lines[1:]:\n            if line == '':  # Blank line separates headers from body\n                in_headers = False\n            elif in_headers:\n                key, value = line.split(': ', 1)\n                request['headers'][key] = value\n            else:\n                body += line\n\n        request['body'] = body\n        return request\nWhat’s happening here?\nWe are converting the request into a string first, then we are parsing it using simple string manipulating in Python to extract information like the HTTP method, the URI that the client wants, along with the HTTP request headers and body.\nIf we didn’t know the structure of an HTTP request, we can’t do this string manipulation, and we won’t know what the client wants! But because HTTP has a fixed format (a “protocol”), we can parse the request accurately .\nOnce we know what the client wants, it’s time to respond. But remember, HTTP has format for responses too! We can’t just send plain text back. We have to structure our response according to the HTTP protocol:\n\nA response line (e.g., HTTP/1.1 200 OK)\nThe headers (e.g., server info)\nA blank line (separating headers from the body)\nThe body (the actual content)\n\nHere’s how we can do it:\n\ndef create_response(self, request) :\n    if request['method'] == 'GET' and request['uri'] == '/hi':\n        return hello()\n    elif request['method'] == 'GET' and request['uri'] == '/namaste':\n        return namaste()\n\ndef namaste():\n    response_line = \"HTTP/1.1 200 OK\\r\\n\" \n    response_headers = f\"Server: {socket.gethostname()}\"\n    blank_line = b\"\\r\\n\"\n    response_body = \"Namaste!\"\n\n    # Concatenate everything and return it as bytes\n    return b\"\".join([response_line, response_headers, blank_line, response_body])\n\ndef hello():\n    response_line = \"HTTP/1.1 200 OK\\r\\n\" \n    response_headers = f\"Server: {socket.gethostname()}\"\n    blank_line = b\"\\r\\n\"\n    response_body = \"Hello World!\"\n\n    # Concatenate everything and return it as bytes\n    return b\"\".join([response_line, response_headers, blank_line, response_body])\nHere’s the entire code for the HTTP Server:\n\nclass HTTPServer(TCPServer):\n    def __init__(self, port=8080) -&gt; None:\n        super().__init__(port)\n\n    def handle_request(self, data):\n        data = data.decode() \n        request = self.parse(data)\n\n        self.create_response() \n\n    def parse(self, data:str):\n        \"\"\"\n        This function will parse the HTTP request and return the method, URI, headers, and body.\n        \"\"\"\n        request = {}\n        lines = data.split(\"\\r\\n\") \n        request_line = lines[0]\n        words = request_line.split(\" \")\n        request['method'] = words[0]\n\n        if len(words) &gt; 1:\n            request['uri'] = words[1] \n\n        if len(words) &gt; 2:\n            request['http_version'] = words[2]\n\n        body = ''\n        in_headers = True\n        request['headers'] = {}\n\n        for line in lines[1:]:\n            if line == '':  \n                in_headers = False\n            elif in_headers:\n                key, value = line.split(': ', 1)\n                request['headers'][key] = value\n            else:\n                body += line\n\n        request['body'] = body\n        return request\n\n\n    def create_response(self, request) :\n        if request['method'] == 'GET' and request['uri'] == '/hi':\n            return hello()\n        elif request['method'] == 'GET' and request['uri'] == '/namaste':\n            return namaste()\n\n    def namaste():\n        response_line = \"HTTP/1.1 200 OK\\r\\n\" \n        response_headers = f\"Server: {socket.gethostname()}\"\n        blank_line = b\"\\r\\n\"\n        response_body = \"Namaste!\"\n\n        # Concatenate everything and return it as bytes\n        return b\"\".join([response_line, response_headers, blank_line, response_body])\n\n    def hello():\n        response_line = \"HTTP/1.1 200 OK\\r\\n\" \n        response_headers = f\"Server: {socket.gethostname()}\"\n        blank_line = b\"\\r\\n\"\n        response_body = \"Hello World!\"\n\n        # Concatenate everything and return it as bytes\n        return b\"\".join([response_line, response_headers, blank_line, response_body])\nThis is already a perfectly valid HTTP server! But imagine we had 100s of functions and URI combinations. The if-else conditions will very quickly get messy. But we can make this better! We’ll use a dictionary to map specific requests to their handler functions. This is how modern web frameworks cna handle routes!\n\nroutes = {\n    ('GET', '/hi'): hello,\n    ('GET', '/namaste'): namaste\n}\n\ndef create_response(self, request):\n    # Look up the appropriate function in the routes dictionary\n    handler = routes[(request['method'], request['uri'])]\n    return handler()\nThis is a great improvement. An even better one is if you use decorators. You can add more routes, handle different HTTP methods, or experiment with cookies and sessions. I’ll leave that for you to implement! Now, hopefully, commands like fastapi dev main.py are not magic blackboxes anymore.\nHappy coding!😄\n\n\n\nCredits and Resources:\nTo build this server, I’ve relied on the following resources:\n\nBharat Chauhan Blog\nNeso Academy Course on Networking\nMDN Documentation\nYou can check out this repository for an improved version of the HTTP server we built."
  },
  {
    "objectID": "posts/meeting-bhavesh-bhatia/index.html",
    "href": "posts/meeting-bhavesh-bhatia/index.html",
    "title": "Unstoppable!",
    "section": "",
    "text": "Background\nDad, a schizophrenic, with a minuscule salary of ₹700 per month; mom, a cancer patient; elder brother, deceased from a dog bite reaction; home at a place which was dominated by Naxalite activities, Gondia. With this as his background, came the light of the Bhatia family—Bhavesh.\n Photo With Bhavesh Bhatia\n\n\nHis Story\nBhavesh’s childhood was a continuous struggle. Yet, he had a hankering for adventures.\n\n“मुझे adventures पसंद है। (I love adventures.) In the 8th grade, I made a friend who had an amputated leg. After finishing our 10th grade, we made a trip from our hometown to Kathmandu, Nepal—a distance of 5,620 km—on a bicycle. I had to do the pedalling. He had to do the handling.”\n\nAnd together, they managed their ride. The trip was to make an identity of his own, to prove himself to the world. He did prove himself. He was welcomed like a hero in his hometown.\n\n“गाँवसे २०-३० km बाहर, ४००-५०० लोग welcome करने आए थे। (There were 400-500 people outside my town to welcome me.)”\n\nBut the euphoria of success didn’t last long.\nSoon after returning, his mother was taken seriously ill with stage IV blood cancer.\n\n“घर, ज़मीन, जो भी बचाया था, सब बेच दिया। दोस्तों, रिश्तेदारों से जितना हो सके उतना क़र्ज़ा लिया। (We sold everything we had and took out as much loan as we could for her treatment.) But fate operates on her own accord. We lost her, regardless of our efforts.”\n\nBereft of a great loving support, left alone with a relapsed dad, he was now an unemployed double graduate. This is how Bhavesh’s life stood in the early 1990s.\n\n“माँ चली गयी, पर मैं और daddy बिल्कुल footpath पर आ गए। (Mom left us, but me and dad were on the streets.)”\n\n“I had a master’s degree in Psychology and Economics, yet I was without a job. To be honest, I didn’t want to do a job; I wanted to do business. But what business could I do back then? There was none. I had to find a job. I worked as a telephone operator for a while, 18-20 hours a day for a handful of coins. Later, I got trained as a massage therapist. In fact, I was awarded ‘The Best Massage Therapist in Maharashtra’ award. I worked day and night; I worked till my hands were swollen and somehow managed to save ₹5,000.”\nThese hard-earned ₹5,000 were put to the best use possible.\nBhavesh learned a skill—candle making—a skill that would transform his life. With the ₹5,000, he bought 20 kg of wax and a simple candle die for raw material. Thus, he embarked on his dream of starting a business. His manufacturing unit? A single wooden table. His retail store? A rented handcart. The name registered—Sunrise Candles. The year was 1994 and the place, Mahabaleshwar.\n\n“Back in the day, candles worth thousands of crores were imported from countries like China. Even today, the scenario hasn’t changed much. It was obvious that there was a tremendous opportunity in the candle business, especially in the ‘fancy’ candle business. And Mahabaleshwar, being a tourist destination, played to my advantage.”\n\nBhavesh’s mornings became reserved for manufacturing candles and his evenings, for selling them. He started with plain candles but soon, he was designing fancy candles. Within the first few years, he had created thousands of beautiful designs.\n\n“People used to come to my handcart and fall in love with what I was doing. They would buy a few candles, and then send more people to my handcart. On my handcart came tourists who were specialists in business. They helped me with marketing, packaging, sales, and whatnot. The business grew in this way.”\n\nYet, there was the sword of debt hanging over his head.\n\n“We knew that if we wanted to expand, we had to reach outside Mahabaleshwar. So we started taking part in exhibitions. At one such exhibition, there came a couple who worked at Infosys. It was their wedding anniversary. I gave them a small gift from my side. They were so impressed that they invited me to stay at Infosys for three days and mailed all the 25,000 employees of Infosys to encourage them to buy my products.”\n\nIt’s miraculous what a small act of kindness can do. A ₹60 gift brought in a business of ₹23 lakhs. The whole debt was paid off, with interest.\nBy now, Bhavesh was employing about 30 people. The production was now far exceeding the selling capacity of a handcart. He had to find more places to sell his candles. Again, the tourism value of Mahabaleshwar came to the rescue.\n\n“A few hoteliers were now willing to put up a small selling unit of ours at their hotels. By now, even we’d understood where we should sell the candles, you know, tourist places and such. We put up our stall wherever we got the opportunity and the whole ownership of the stall was given to the guy running it. We could expand even more in this way. More than a thousand corporates are now associated with us including the Taj Group and Grand Hyatt Group.”\n\nHis business now ran smoothly. Yet, the hunger for adventures wouldn’t let him sit still. He took up mountaineering.\n\n“अगर आपको कभी trekking वगैरे करना हो, तो आओ हमारे साथ। (If you want to go on a trek, join us.) I have just finished climbing Kilimanjaro, and my dream is to climb Mount Everest. It’s, like, a real bucket list item.”\n\nWith an annual turnover of more than ₹200 crores, Bhavesh’s company, Sunrise Candles, enlightens more than 70 countries across the globe. It employs more than 10,000 people all over India at its 71 manufacturing units and more than 4,500 selling units.\nGood story, eh? But what is the big deal about Bhavesh Bhatia?\nThe big deal is that he is totally blind.\nBhavesh finished his double degree with the help of his mother who read all his books to him. The institute where he learned candle making was, in fact, the National Association for the Blind, Mumbai (NAB).\nHe was awarded the national award at the hands of the President of India, twice, out of which, one was for being the best employer in the country, which was the best among 58,000 nominations. Out of the 10,000 people he employs, about 9,500 people are blind.\nHe has won a staggering 114 medals in national Paralympics, and still competes for more. As if that wasn’t enough, he became the first-ever blind person to climb Mount Kilimanjaro and aspires to be the first blind person to climb Mount Everest.\nAnd that is a pretty big deal!\n\n\n\nAdvice to the Youth:\n\n“Never tell your destinations where your problems are. Tell your problems where your destinations are.”\n“Success is nothing but being able to sleep well at night. Do whatever you want but never do anything that’ll take away your night’s good sleep.”\n“And don’t wait. Each day is the best day to start doing what you want to do. Just start doing it.”\n\n\nBhavesh sees the world in a way none of us can see. He has a uniquely different perspective on life, a perspective that sits at the far end of the positivity spectrum—something we can emulate. Here’s a story he shared with me that illustrates my point:\n\n“The turning point of my life came when Baba Ramdev hosted a huge shibir of 40-50,000 people in Mahabaleshwar.”\n\n\n“I went there with my friend to see if I could get a cure to my mother’s illness and also, my own. Baba Ramdev was tired telling all these people, “आँखे बंद करो और अंदर झाँको। आँखे बंद करो और अंदर झाँको।” (Close your eyes and peek within, close your eyes and peek within.) Then, I heard an inner voice. It said that these people had to try to close their eyes, and even then, they were failing. And here I was, lucky to have been spared of the trouble. “Treatment तो नही मिला पर मेरा काम हो गया।” (I didn’t get a treatment to our illnesses but I got a cure for my problems.)”"
  },
  {
    "objectID": "posts/challenge-accepted/index.html",
    "href": "posts/challenge-accepted/index.html",
    "title": "Challenge Accepted!",
    "section": "",
    "text": "We’d gone to meet the soul of NAMCO Hospital, Shashikant Parakh. He was in a meeting regarding the construction of a Bone Marrow Transplant unit at the hospital.\n Photo with Shashikant Parakh\nI got to hear a few bits and pieces of it. Shashikant, a commerce graduate, was talking with no less depth of knowledge than a medical professional. He talked loud and clear, and never ever drifted away from the topic. A management authority, who himself was a doctor, showed us around the hospital.\nThe hospital was different from other hospitals in many ways. It didn’t have the hospital smell. Instead, it smelled of respect for Shashikant. Its cleanliness was striking and the equipment could’ve easily put to shame the finest of super speciality hospitals. All this for patients who cannot pay for their treatment. All this because of one man — Shashikant.\n\n“I was born and brought up in the religious town of Shirdi, the town of Sai Baba. We were a joint family and owned a small shop of religious goods in front of a temple.”\n\nShirdi was, and still is, the destination of pilgrims. But the thing is that the pilgrims don’t come to visit Shirdi only. There’s a chain of destinations ahead, which is why most of the pilgrims don’t stay in Shirdi for more than half a day. This was a brilliant opportunity to develop a lodging business and it took an innovative young chap, like Shashikant, to recognise this.\n\n“There was a 34-room lodging apartment to be rented in Shirdi. I convinced my family to pay the rent and said I would handle the business. They agreed.”\n\nShashikant started the hotel in three eight-hour shifts. Since the pilgrims didn’t need to stay for the whole day, they preferred Shashikant’s hotel over others. Immediately, it was a huge success.\n\n“The rent was ₹1,11,000 per year, and I managed to earn a sum of 7-8 lakhs in the first year. I was in my first year of college.”\n\nSoon, he’d earned enough to buy another hotel, and soon after, a third one. The business had settled without facing any serious challenges. But was he settled?\nNo! A smooth ride isn’t his type. He likes a roller coaster filled with challenges.\n\n“Once the lodging business had settled, I handed it over to my family and said, ‘You take care of this business and I, am going to Nashik.’”\n\nHe came to Nashik with no riches and no recognition. He would need to build it again. Soon, he started a distribution agency. Once it had settled, he ventured into real estate. Then construction, and then, warehousing. Today, in total, he runs eight businesses, with an annual total turnover of more than a hundred crores, and employs about a hundred people.\n\n“Opportunities kept on coming, and I kept on grabbing them.”\n\nBut a nagging question haunted him: is there an end to all this? And if there’s no end, then why expand the business? He stopped expanding it around 2008-09. Now, it was time to use his entrepreneurial skills to help others. That was the biggest challenge.\n\n“I volunteered at a few places before I was given the opportunity to work at NAMCO charitable hospital.”\n\nWhen I joined, NAMCO was totally deteriorated. The first day after he joined, he called a ‘staff meeting.’\n\n“I said to them, ‘I’m the new secretary here and we are going to transform NAMCO.’ They laughed. They literally laughed and said, ‘We’ve seen a lot of people like you. You just jabber and do nothing.’”\n\nWhen I joined, NAMCO was only treating cancer patients. Bats and rats roamed around. There were only two doctors, both of whom weren’t present most of the time. We had thirty beds, out of which, at maximum, only three were occupied.\nThis was 2015. Fast forward to 2020, and you’ll see an entirely different picture.\n\n“Today, NAMCO is a multi-specialty hospital en route to becoming a super-specialty hospital with state-of-the-art technology at the cheapest rates. There is a staff of 305, out of which, 40 are highly qualified medical professionals. It now has a total of a hundred beds with a few patients always in the waiting.”\n\nStill, Shashikant’s ambitions for NAMCO run quite high, quite literally.\n\n“I’m going to construct a twelve-storey tower with each floor dedicated to each specialty,” he says nonchalantly.\n\nShashikant’s entire life has revolved around one word: challenges. He loves taking up challenges; he thrives when challenged. His life will continue to revolve around that word. He had taken up the biggest challenge of helping others, but he has a wish for a personal challenge as well: Skydiving.\n\n“Skydiving is a dream. I couldn’t do it before, but I will do it soon.”\n\nIt will not be a surprise then, if he takes a jump out of his steady flight, to take up an entirely new challenge, falling fast towards the destination, with sheer determination to glide to safety.\n\nAdvice to the Youth\n\n“Dream big. It’s as simple as that. Ever since my childhood days, I’ve always dreamt of becoming the richest man of my town. Dream big but dream with intensity. Only those dreams come true.”\n\n\n“Keep learning. Be ready to learn. I’ve always had this mindset — whichever field I’ll dabble in, I’ll gain complete knowledge of it. When I started in real estate, I went through a lot of books. When I started working at NAMCO, I studied medical books, which I still do. Have that mindset.”\n\n\n“And be happy. Success is nothing but happiness. Don’t complain. Do whatever you want but be happy.”"
  },
  {
    "objectID": "posts/how-to-learn-dl/index.html",
    "href": "posts/how-to-learn-dl/index.html",
    "title": "Mastering Deep Learning as a Non-Techie",
    "section": "",
    "text": "Even if you closely follow AI and deep learning, chances are you haven’t heard of Radek Osmulski. He’s a deep learning engineer at Nvidia and a top competitor on Kaggle. But what’s really inspiring about Radek’s story is that he didn’t write a single line of code until he was 29! So how did he go from not knowing how to program to landing a job at Nvidia? How did he master deep learning so well? Radek answers these questions in his book, Meta Learning, which you can buy here.\nIn this blog post, I’ll summarize the key ideas from Meta Learning, so that even if you’re not a technical expert, you can get started and master deep learning yourself.\n\nThe Essential Skills\nYou might think deep learning requires advanced knowledge of statistics, algorithms, data structures, or calculus. But in reality, Radek argues that what you really need are these four skills:\n\nNavigating Stack Overflow: Get familiar with the interface, learn to navigate the site.\nReading documentation: Start with open-source projects—it’s intimidating at first, but it gets easier. By seeing how others code, you’ll improve your own. Take any open-source project in your preferred language and start exploring it.\nUnderstanding code repositories: No matter which one you use, editors have powerful features that make your life easy. Know them!\nUsing version control (Git): Nearly all of the world’s code is managed through Git, so learning how to use basic Git is extremely important. Get started here.\n\nIt sounds simple, right? None of these are deep learning-specific skills, but they are essential for implementing deep learning projects (or any software project, for that matter). If you have these skills, you can build on these to learn anything!\nYou can parallely take FastAI’s deep learning course as well to get familiar with Deep Learning. More on this later.\n\n\nShare Your Work\nYou learn best by doing, but even better by sharing. Sharing isn’t about showing off; it’s about reflecting. If, like me, you’re not someone who posts on social media often, this can be tough. But it’s worth breaking the barrier.\nSharing what you’re learning forces you to reflect, and reflection means deeper understanding. Start a blog, even if it’s just for yourself. Write about what you’re learning, then share it. Remember, you don’t have to be an expert to start writing a blog. Your journey as a beginner is just as important, especially for your own growth.\n\n\nBUILD. BUILD. BUILD.\nOne of the biggest barriers to learning deep learning is there’s just too much theory. You are told that you need to know statistics, calculus, and basic machine learning to just get started with deep learning. Radek’s advice is clear: stop focusing on theory, and start building. It’s better to build first and figure out the theory later. In his words, a better approach is: “Use one cup of theory, one cup of practice. Rinse and repeat.”\nDon’t overdo it with too many courses—pick one. By far, the best course on learning deep learning is the FastAI’s Deep Learning course. In fact, engineers at OpenAI are required to take this course before joining. You can start with this course, build the basics, and get your hands dirty!\n Meta Learning by Radek Osmulski\n\nI claim no credit for the information presented here. All insights are from Radek’s book. My goal was to present a small summary and to absorb the learnings better myself."
  },
  {
    "objectID": "posts/mastering-life-like-a-grandmaster/index.html",
    "href": "posts/mastering-life-like-a-grandmaster/index.html",
    "title": "Grandmaster-ing Life",
    "section": "",
    "text": "Recently, I came across Vishy Anand’s book- “Mind Master”. For anyone who admires Vishy, and anyone who wants to succeed in life, the book is a delight. Vishy shares his experiences and the lessons he learned from playing chess. In this post, I share the top three lessons from Vishy’s book.\nThose who want to read the book can buy it here.\n1. Don’t Obssess About Your Progress\nWhile it’s important to keep track of your progress, it’s not at all helpful to obsess over how far you’ve come. Sometimes, it feels like you’re getting nowhere, and then, out of nowhere, situations may change and you may achieve your goals within a week.\nFor Vishy, it took seemingly forever to get his grandmaster norms. He missed out on the norms by the smallest margins- as small as half a point. He got frustrated and impatient. He was so close to achieving a goal he had worked so hard for. Fortunately, he had mentors and friends to support him through the journey. This slump was definitely difficult, but when he did get the norms, he earned all the three within a span of just a year!\nIf you’re feeling like you’re getting nowhere, that’s totally fine! If you’re not landing that dream job, that’s okay! The key is to not obsess over your progress but to be tenacious. Have someone to support you. And who knows, the tides may turn within a week!\n2. What Should You Do After You Achieve Your Goals?\nOnce Vishy decided that he wanted to become a chess grandmaster, he spent all his energy into the pursuit of achieving that goal. Becoming a grandmaster is what gave his life meaning. But what happened after he became grandmaster?\nBelieve it or not, Vishy says that his life was empty. There was no meaning left once he’d achieved his goal. And Vishy wasn’t the exception in this. Most grandmasters feel this way once they become GMs.\nSome of us may be fortunate enough to achieve our goals, but some of us may not be, and we may have to quit. Then it may be all too easy to despise ourselves for wasting efforts and time. It’s all too easy to not find the purpose of life.\nBut we need to put our trust in time. For Vishy, it took him six months to get back to being excited about life. With time, we will get over this void and move on. But during this time, perhaps we take up a hobby, travel, or do something that we always wanted to do!\n3. Will AI Take My Job?\nFor so long, brilliant chess was solely a human feat. Grandmasters in the olden days relied on nothing but their effort and intellect. With time and the advances in technology, computers started defeating chess players. Now, no chess grandmaster prepares without using a chess engine.\nChess witnessed the rise of AI. Vishy is perhaps the only active player to have played in all three eras of chess. He saw what AI can do and how AI can impact us. Of course, he has some advice for all of us.\nWe cannot deny the rise of AI. It’s definitely going to change things. As professionals, it’s up to us to adapt, learn, and unlearn. The way Vishy sees it, his work begins where AI’s work ends. The job of an engine is to study the positions and come up with analyses and conclusions. Once the conclusions are ready, it’s when Vishy’s job starts. He needs to understand why the conclusions make sense and then use those conclusions to enhance his understanding of his game.\nThere’s an open interpretation here- if we want, we can apply the same reasoning to any other field, and not just Chess. Is AI going to take over software developer jobs? It’s definitely going to change them. Those who can adapt can brilliantly make use of AI’s power to do their jobs better.\nRegardless of whether AI takes over or not, it’s certainly our duty to be adaptable. Always be asking ourselves the questions: What do I need to learn? What do I need to unlearn?\n\n\n\nMind Master By Vishy"
  },
  {
    "objectID": "posts/navigating-gold/index.html",
    "href": "posts/navigating-gold/index.html",
    "title": "Navigating Gold",
    "section": "",
    "text": "A magnificent three-storey building, proudly displaying the name Govind Dande and Sons, was my next stop. When you enter GDS, everything around you is exquisite and you are blinded by the resplendence. But that is not the most impressive thing. Instead, it is how you are treated when you enter GDS. A middle-aged man, smiling—not because his boss tells him to, but because he wants to—greets you and makes you feel truly welcome.\nThe director, Anil Dande, sits in his cabin at the far end of the store. He is who I am meeting. GDS has grown from a 3 crore business to a 150 crore industry, and its success owes a lot to Anil Dande.\nGDS was established first in Amaravati in 1927. In 1935, Anil Dande’s father, Shri Govind Dande, moved the business to Nashik. In his later years, his elder sons shouldered the responsibility of the business.\n\n“Before I joined, my two elder brothers were running the business. I didn’t like the way it was run; the growth was too slow.”\n\nChanged the business way he did, with fortune favouring the brave.\n\n“Back in those days, the gold trade had restrictions. Just when I joined, many of them were lifted.”\n\nThe door was opened. The sky was the limit, and they reached for it.\n\n“When I joined, we had a total stock of 120 gm, out of which 60 gm was my mother’s wedding jewellery, and we were running the business in a small 180 sq. ft. rented room. With trade restrictions lifted, our business boomed. We took out loans to increase our stock, which in turn, increased our customers, for whom our rented room fell short. We moved to a more spacious apartment, started doing the trade in silver as well, and just when we felt the ship was sailing smoothly, we were robbed.”\n\nIn 1987, GDS was robbed—robbed big time. 42 kgs of silver, 2 kg of gold just vanished. But surely they had insurance, didn’t they?\n\n“We had insurance, but the insurance company altogether denied that there had been a robbery. We won the case against the company, but it took years. Something had to be done immediately to restart our business.”\n\nMadhavrao Patil, the then chairman of Janalakshmi Bank, came to the rescue.\n\n“He lent us ₹4,00,000 on the very next day of robbery without any documentation. He put faith in us. Those 4 lakh rupees were game changers. They helped us rebuild and grow. Wherever GDS is today, it couldn’t have been without his help at the time.”\n\nGDS rebuilt and has kept growing ever since. In the year 2007, GDS moved to a grand 10,000 sq. ft. construction. In 2018, it was awarded as the ‘Best Retail Store’ of the entire country. But such awards and recognitions don’t lure Anil Dande.\n\n“Awards are something which others give you. It’s not something that is yours. What is yours, is the joy with which the customer leaves the store. That joy is what we work for.”\n\nThis joy is not just limited to their customers; it extends to their staff and their vendors too.\n\n“Our definition of a customer has three aspects: the customer (the person who buys from us), the staff (the person who sells to the customer), and the vendor (the person from whom we buy). We have identified the needs of all three customers, then we have worked to solve for that need ( no wonder why you’re welcomed with a heartwarming smile by the staff ), and that has generated money. So we haven’t worked for money either; it has been the byproduct of value creation.”\n\nGDS has grown a lot. And it wants to grow further. At 58 years young, Anil Dande still anchors the GDS ship. There is no retirement in sight.\n\n“People retire in their mind befoer they retire in reality. I never retire in my mind, and thus, I have no reason to retire in reality.”\n\nThe next generation of Dande’s, Devyani and Yogeshwar, has also entered the business with new vision and new energy. Anil Dande’s goal is to put GDS in such a position in the next 7 years, from where the next generation can take off smoothly and fly high for the coming years.\nAlthough Anil Dande has been a GPS of GDS’s long drive, his entry in the business was totally unplanned.\n\n“I did my B.Com first, then my L.L.B. And then, basically, I had nothing else to do, so I came into the family business.” He says as a matter of fact.\n\nGDS is not just a name. It’s a culture. A culture of transparency. A culture of positivity. A culture of respect.\nA culture which Anil Dande developed.\nA culture he lives.\n\nAdvice to the Youth:\n\n“Fitness is threefold—financial, mental, physical. If you want to be successful, in business or in life, you’ve got to be fit in all three dimensions. We have no debt, at 58, I ride a bicycle 20 km each day, and both of these things keep my mind fit and fresh.”\n\n\n“The youth is not persistent in one pursuit. You know what the word teenage means? It’s ‘Tin-age’. It means, you’re like a metal tin; you can make a lot of noise. You’ve got to give direction to that noise and you’ve got to be persistent with that direction. Give that direction it’s due time. Don’t just jump from one passion to another.”\n\n\n“Success, to me, is the combination of a good opportunity and 100% efforts. If you’re not successful, then it either means you’re not giving your 100% or it’s not a good opportunity. Whatever the reason is true for you, it has the solution in itself.”"
  },
  {
    "objectID": "projects/gpt-2/index.html",
    "href": "projects/gpt-2/index.html",
    "title": "GPT-2",
    "section": "",
    "text": "Project Overview\nIn this project, I tried to implement the full GPT-2 architecture from scratch using PyTorch. I pretrained the model using the FineWeb_Edu dataset. The model is an implementation and an improvement on the GPT-2 124M model.\nI relied heavily on Andrej Karpathy’s tutorial and Mitesh Khapra Sir’s lectures to understand the internals of GPT-2 better.\n\n\nTech Stack\n\nPyTorch\n\nGitHub Repository\nFor more details, the full source code can be found on GitHub: Source Code"
  },
  {
    "objectID": "projects/shakespeare-in-me/index.html",
    "href": "projects/shakespeare-in-me/index.html",
    "title": "The Shakespeare In Me",
    "section": "",
    "text": "Project Overview\nIn this project, I tried to create a character level, decoder only GPT from scratch. I used the “Tiny Shakespeare” dataset to train the model, and implemented the entire transformer architecture including multi-headed attention blocks, residual connections and layer normalizations using PyTorch.\nI relied heavily on Andrej Karpathy’s tutorial and Mitesh Khapra Sir’s lectures to understand the internals of transformers better.\nI trained the model on Google Colab GPU for 40 mins, and after training the model for 5000 epochs, I got a pretty convincing Shakespeare-like output, which I have added in the more.txt file. The loss at this point was around 1.40, which produces a decent output.\n\n\nTech Stack\n\nPyTorch\nPython Jupyter Notebooks\n\nGitHub Repository\nFor more details, the full source code can be found on GitHub: Source Code\nAnd for a curious reading, the output could be found here: more.txt"
  },
  {
    "objectID": "projects/money-map/index.html",
    "href": "projects/money-map/index.html",
    "title": "Money Map",
    "section": "",
    "text": "Project Overview\nFinancial planning is of great importance, especially if you’re young and starting out in your career. As a part of the CFA curriculum, I created simulations for my personal financial planning. These simulations, I figured, were important to keep in the back of the mind as we went about our lives. They give us a sense of what decisions should we take and what decisions should we avoid. Not only that, but they make us think about budgeting and expenditures.\nMoney Map does exactly that. It lets you run simulations that you can use for your financial planning. It also includes additional resources that you can explore as you go about planning your finances. You can access the project live here.\n\n\nFeatures\n\nSimulator based on different input parameters\nPlots of the simulation\nResources for further study\n\n\n\nTech Stack\n\nReactJS\nPlotly\n\nGitHub Repository\nFor more details, the full source code can be found on GitHub: Source Code"
  },
  {
    "objectID": "projects/screener-scraper/index.html",
    "href": "projects/screener-scraper/index.html",
    "title": "Screener Scraper",
    "section": "",
    "text": "Project Overview\nA few years ago, I came across a book Warren Buffett’s Ground Rules by Jeremy Miller. In the book, we find discussions on how Warren used to invest in his early years. But for me, the real treasure was the Appendix section. There you got a worked out example of how Warren valued a business when he was running his partnership.\nThe computation was simple, really, and might apply to most use cases, but not all. Since then, I used to go on Screener, and meticulously try to value each and every company from a screen (a custom filter for the companies) of mine. The screen itself was inspired from the advice of Benjamin Graham from the book The Intelligent Investor.\nThen I figured, I could use the Python and Selenium to automate this process. Instead of manually going over each company, I’ll let me script shortlist a few companies for me and then I’ll evaluate the shortlisted companies. That’s why I built Screener Scraper.\nScreener Scraper takes as input a screen on Screener, and filters out the free puffs based on the book. This is by no means a definitive valuation, but it saves me a ton of time!\n\n\nTech Stack Used\n\nPython\nLibraries like Selenium and BeautifulSoup\n\n\n\nHow to Use?\n\nEnsure you have provided your cookies and CSRF tokens from Screener in a file named secrets.env.\nWhen prompted, input the URL of your custom screen from Screener.\nThe scraper will go through each of the companies in your screen, annd computes the liquidation valuation for each company.\nA .csv file will be generated containing all the crucial data you need for your analysis, along with the liquidation valuation.\n\nHappy analyzing!\nGitHub Repository\nFor more details, the full source code can be found on GitHub: Source Code"
  }
]